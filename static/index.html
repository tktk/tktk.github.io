<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>tekuto.net</title>
        <link rel="stylesheet" href="style.css" />
        <script type="text/javascript">
            var _gaq = _gaq || [];
            _gaq.push(['_setAccount', 'UA-23511137-1']);
            _gaq.push(['_setDomainName', '.tekuto.net']);
            _gaq.push(['_trackPageview']);

            (function() {
                var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
            })();
        </script>
    </head>
    <body>
<!--過去ログ用
        <div>
            <p><a href="/">戻る</a></p>
        </div>
-->
        <h1>tekuto.net</h1>
        <div>
            <p>メール:g.tekuto@gmail.com</p>
            <p><a href="http://twitter.com/tekuto" target="_blank">twitter</a></p>
        </div>
<!--テンプレート
        <hr />
        <div>
            <h2>YYYY/MM/DD hh:mm</h2>
            内容
        </div>
-->
        <hr />
        <div>
            <h2>2013/07/19 05:35</h2>
            <p>pulseaudioいじくってた。</p>
            <p>＊</p>
            <p>ストリームAPIの使い方がようやく分かった気がする。</p>
            <p>pa_stream_write()で波形データを書き込むというのは分かっていたのだが、ループでそれを呼び出しまくり、WAVファイルの音楽を再生しようとしてもうまくいかなかった。</p>
            <p>最初はうまくいっているように見えるのだが、10、20秒程度すると再生が途中で終わってしまう。pa_stream_write()で書き込んでも再生されない。</p>
            <p>色々試した結果、一言で言うならpa_stream_drain()を呼び出す必要があるという結論に達した。</p>
            <p>だがしかし、ただ呼び出すだけでは不十分。pa_stream_drain()の処理は非同期に実行されるため、pa_stream_drain()を呼び出し、処理が返ってきたからといって、処理が完了しているわけではないのだ。</p>
            <p>そこで、pa_stream_drain()を呼び出してから、次にpa_stream_write()を呼び出すまでに、pa_stream_drain()の処理が完了させる必要があり、つまり待機処理が必要になる。</p>
            <p>具体的には、pa_threaded_mainloop_lock()とpa_threaded_mainloop_unlock()をpa_stream_write()、pa_stream_drain()の前後に入れ、pa_stream_drain()の後にpa_threaded_mainloop_wait()で処理を待機させる。</p>
            <p>で、pa_stream_drain()の処理が完了…したかは知らないが、正確にはバッファに空きができればいいわけなので、pa_stream_set_write_callback()で、ストリーム書き込み時のコールバック関数設定をあらかじめ行なっておく。そして、そのコールバック関数内でpa_threaded_mainloop_signal()を呼ぶ。</p>
            <p>というわけで、pa_stream_write()、pa_stream_drain()、pa_threaded_mainloop_wait()と呼び出し、pa_threaded_mainloop_signal()をストリーム書き込み時に呼び出す、という流れになる。</p>
            <p>しかしながら、これは検証のためにそれなりに適当にやったので、実際にはチェック処理とか入れるべきだと思う。</p>
            <p>例えば、pa_threaded_mainloop_wait()とかpa_threaded_mainloop_signal()とかは、引数がpa_threaded_mainloop_mainloopのポインタしかない。つまり、ロックが1つしか存在しないため、pa_threaded_mainloop_wait()から処理が復帰した時に、チェック処理を入れ、場合によっては再度待機するとか、そういう風なことをする必要がある。</p>
            <p>今回の場合は、バッファに空きがあるかどうかが問題なので、pa_stream_writable_size()を呼び出し、書き込めるかどうか確認する必要がある。</p>
            <p>そもそも、pa_threaded_mainloop_wait()を使わなくても、std::mutexとstd::condition_variableでいいんじゃないか、という気がしないでもない。C++11以前は環境非依存な同期処理がなかったから、用意されたもんだと思うし。C++11の環境非依存同期処理を使える今、わざわざ使う必要もなさそう。</p>
            <p>pa_threaded_mainloop_lockの処理、見てみたけど、結局pthread_mutex_lock()呼び出してるだけだったわ。waitとかもpthread_cond_wait()呼び出してるだけだった。じゃあいいわC++11のやつで。</p>
            <p>＊</p>
            <p>とまぁ、これ調べるのも一苦労だ。サンプルねぇし。audaciousやらvlcやらmplayer2やらのソースを読んだが、今回の問題には大した助けにならなかったし。</p>
        </div>
        <hr />
        <div>
            <h2>2013/07/11 12:46</h2>
            <p>疲れた。</p>
            <p>＊</p>
            <p>androidアプリ作るの疲れた。飽きた。優先順位は低いわけだし、そろそろdpの方に戻るべきか。</p>
            <p>dpよりもビルドに時間がかかるのと、できたものの動作確認をするのに時間がかかるのがとてもめんどくさい。すごい勢いでモチベーションが削がれていく。</p>
            <p>しかも、XMLとかいじくると稀によく、ビルドして動作確認しようとしても不正終了する。そういう場合、1回クリーンしてビルドし直さないと直らない。ただでさえ時間がかかるのにめんどくさすぎる。</p>
            <p>というわけでまた今度。</p>
            <p>＊</p>
            <p>前回の日記から1週間以上経っているなぁ。さすがに時間使い過ぎた感。</p>
        </div>
        <hr />
        <div>
            <h2>2013/07/03 22:28</h2>
            <p>antroidは機能縮小した。</p>
            <p>＊</p>
            <p>で、androidのサービスをアクティビティからバインドしてどうのこうのというのを試してみたんだけど、今回は使えなさそう。</p>
            <p>サービスは使うけど、通信はソケット通信かな。アクティビティからのバインドは、アクティビティからサービスの機能を使う、ということが目的なら便利に使えそうなんだけど、1対1の通信を確立するとか、そういうのには向いてなさそうな空気。</p>
            <p>アンバインドした時に、どのバインドをアンバインドしたのか、それが判別できない。putExtra()とか使って、IDみたいのを作ればできないこともないだろうけど、絶対に被らないという保証がどこにもない。</p>
            <p>また、既にバインド済みの時に別のバインドを確立すると、サービス側にバインドしたことが通知されないっぽい。もちろんアンバインドも通知されない。</p>
            <p>そんな感じ。</p>
            <p>あーでも、リモコンとの通信には使わないけど、バインド自体は使うかな。サービスと通信するためのものは別のライブラリプロジェクトにまとめるけど、通信処理の実装はライブラリプロジェクトに含めない。含めるのはインターフェースだけで、実装はサービスから取得する形にしたい。通信処理に修正が入ったから、ライブラリプロジェクトを使ったプロジェクトに再ビルドが必要、とか嫌だし。</p>
            <p>＊</p>
            <p>なんとなくまとまってきたぞ。</p>
        </div>
        <hr />
        <div>
            <h2>2013/07/02 19:24</h2>
            <p>antroid、機能縮小しようかなぁ。</p>
            <p>＊</p>
            <p>ビルドとかクリーンとか、SDKに付属してるbuild.xmlに搭載されている機能を再実装するのは無駄だと思った。現時点でリリースビルドすら実装できていないし、実装してもSDKの更新で処理が変更されるかもしれないし。それにいちいち追随するのはめんどくさすぎる。</p>
            <p>でも、プロジェクト作成ウィザードやアプリの実行、logcatの開始など、SDKに付属しているbuild.xmlに存在しないが自動化でより便利、簡単に扱える機能は使いたい。なので、そういった機能だけに絞ろうかなと。</p>
            <p>今までビルドやクリーンもサポートしていたのはなんでだったかなと思ったら、デバッグビルドとリリースビルドの出力先を分けることが目的なんだった。しかし、最近依存するライブラリプロジェクトとリンクできるようにしたところ、クソみたいな原因で正常に動作しなくなったため、出力先を分けられなくなったんだった。</p>
            <p>思い出したらまた嫌な気分になった。なんだよあのクソ実装は。antの独自タスクに、出力先がbinとハードコーディングされてやがる。定数が使われてるからハードコーディングとはちょっと違うが、実質的に同じようなもんだ。build/debugとbuild/releaseに分けたかったのだが、bin以下にライブラリのjarがねぇよとか言い出してこける。忌々しい。</p>
            <p>独自タスク内はさすがにどうしようもない気がする。なんとかして定数を、リフレクションとか使って書き換えられないかなぁ。</p>
            <p>＊</p>
            <p>androidからいじくるために、<a href="http://www.amazon.co.jp/gp/product/B000KF3RRS/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=247&creative=1211&creativeASIN=B000KF3RRS&linkCode=as2&tag=tekutonet-22" target="_blank">wiiのクラシックコントローラ</a>を買ってきた。中古。</p>
            <p>なぜかLとRがアナログらしい。あとZLとZRの位置がすごい。人差し指が疲れそうだ。<a href="http://www.amazon.co.jp/gp/product/B002C1AUP0/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=247&creative=1211&creativeASIN=B002C1AUP0&linkCode=as2&tag=tekutonet-22" target="_blank">PRO</a>も入手したいところだが、PROじゃない方でも大体同じように使えるだろうし、まぁいいかといった感じ。欲しくないわけではないが。</p>
            <p>＊</p>
            <p>androidのアプリ間通信、アクティビティとサービスは接続できるらしいなぁ。その辺知らんかった、というかサービスについて詳しく知らない。なにやら、接続してデータをやりとりできるようだ。アクティビティからサービスのメソッドを呼んだりできるらしい？</p>
            <p>ソケット通信にしようかと思っていたが、アクティビティとサービスの連携がうまいこと使えそうなら採用しようかな。ポート番号とかのめんどうなことを決めなくてもよくなるだろうし。</p>
            <p>その辺、検証してみよう。</p>
        </div>
        <hr />
        <div>
            <h2>2013/07/01 15:44</h2>
            <p>1ヶ月毎に別ファイルにすることにした。</p>
            <p>＊</p>
            <p>昨日あんなことを書いておきながら今日もandroidからwiiリモコンをいじくろうとしている。</p>
            <p>BluezIMEのソースを読んで接続方法は把握した。ペアリング？そんなものはなかった。</p>
            <p>想像はできていたが、なかなか無理矢理な方法だった。<a href="http://developer.android.com/reference/android/bluetooth/BluetoothSocket.html" target="_blank">android.bluetooth.BluetoothSocket</a>の非公開なコンストラクタを、リフレクションで呼び出す。SDKのリファレンスにも当然コンストラクタの仕様なんぞ載ってないし、その辺の実装が変わったら簡単に動かなくなりそうだ。</p>
            <p>私の使っている環境はandroid4.1.2だけど、4.2からは内部で使っているBluetoothのライブラリが別物になるらしい。その辺の変更でインターフェースが変わってたら動かなくなるなぁ。</p>
            <p>で、接続して、LEDの制御をするところまでできた。あとは入力データの解析とかすればいいわけだが、かなりいい加減に作っていたので、この先を進めるにはちょっと整えないとめんどうなことになりそうだ。</p>
            <p>入力データの処理は別スレッドでやるべきだと思うが、スレッド分割することを全く考慮していないので、ひどいことになりそう。何をどうすればいいのかも分かってきたし、本格的に作り始めるべきか。</p>
            <p>そういえば、BluezIMEのソース読んでたら、LEDの点灯は右端の1つを点灯させるの固定になってて残念な気分になった。せっかく4つあるのに。まぁ、BluezIMEはwiiリモコンだけを制御するわけじゃないし、LEDの点灯が全部同じだったからといってソフト側にはなんの不自由もないわけだし、いいんだけど。</p>
        </div>
<!--過去ログ用
        <hr />
        <div>
            <p><a href="/">戻る</a></p>
        </div>
-->
        <hr />
        <div>
            <h2>過去ログ</h2>
            <p><a href="201306.html">201306</a></p>
        </div>
        <div id="for-nostylesheet">
            <hr />
            <img src="images/uni.png" />
        </div>
    </body>
</html>
