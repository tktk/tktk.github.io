<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>tekuto.net</title>
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-23511137-1"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'UA-23511137-1');
        </script>
    </head>
    <body>
        <div>
            <p><a href="/">戻る</a></p>
        </div>
        <hr />
        <div>
            <h2>2015/12/19 04:15</h2>
            <p>最近はraspberrypiをいじくりまくってた。</p>
            <p>＊</p>
            <p>そのかいあって、常にxlink kaiを動かすraspberrypiがほぼできた。</p>
            <p>私の作ったプログラムにより、raspberrypi側の無線LANアダプタを自分で操作しなくても、MACアドレスに対応したPSPのネットワークに自動接続できる。</p>
            <p>また、起動時にメモリ上にSquashFSのrootfsを配置する形にした。</p>
            <p>これにより、起動後はSDカードを取り外しても動作し続けることができる。</p>
            <p>raspberrypiにSDカードは完全には差さらず、出っ張るためうっかり触って抜けてしまったり、カードやスロットなどが破損したりということが起きかねない。</p>
            <p>それに、マウントした状態で取り外したり、電源コードを抜いたりすると、ファイルシステムが破損する可能性だってある。</p>
            <p>実際、それでSDカードのファイルシステムの再構築が必要になったことが何度かある。</p>
            <p>そもそもraspberrypiに電源スイッチなどないし、普通に終了するためには何らかの方法でログインし、shutdownコマンドを叩かなければならない。</p>
            <p>それが電源コードを抜いて電源を落としても多分大丈夫になった、というのは大きい。</p>
            <p>＊</p>
            <p>私の作ったプログラムはもう少し修正する必要がある。</p>
            <p>周囲のアドホックネットワークの検索処理を実行する間隔が短すぎて、他の通信に悪影響が出てしまっている。</p>
            <p>しかし、どうスリープしたものか。固定時間か、一定間隔毎に処理するように計算してスリープするか。</p>
        </div>
        <hr />
        <div>
            <h2>2015/11/29 00:20</h2>
            <p>昨日、いつにも増してやる気が出ん、だるいと思ったら微熱が出ていた。</p>
            <p>＊</p>
            <p>それでも、なんとかパッケージ情報に記述したゲームについての情報を取り出す処理は追加できた。</p>
            <p>月曜には、ゲームのロード処理をメイン関数に追加したいところ。</p>
            <p>明日はraspberrypiをいじくるとしよう。</p>
        </div>
        <hr />
        <div>
            <h2>2015/11/27 00:27</h2>
            <p>ショートカットファイルからゲームの参照情報を取り出すのはできた。</p>
            <p>＊</p>
            <p>まぁ、記述内容がベースシステムの参照情報とほぼ同じだから、処理をコピーして少し修正して作ったんだけど。</p>
            <p>次はパッケージ情報にゲームについての情報を追加して、それを取り出す処理かな。</p>
            <p>こっちも、ベースシステムの情報と大体似たような感じだから、処理をコピー、修正して作れば楽だろうな。</p>
            <p>その取り出した情報を使ってゲームをロードし、ベースシステムの実行時に引数として渡す、というところまで明日中にできればいいんだが。</p>
        </div>
        <hr />
        <div>
            <h2>2015/11/25 19:51</h2>
            <p>というわけで、0.5.0できた。</p>
            <p>＊</p>
            <p>ベースシステムの起動までできたところで0.5.0とした。</p>
            <p>この次はゲームの生成、破棄とゲームの制御となるわけだが、どうするかちょっと考え中。</p>
            <p>昨日の日記書いてた時には、ゲームの生成や破棄はベースシステム内でやろうかと考えたりしていたのだが、それはあまり望ましくない気がする。</p>
            <p>ゲームの生成や破棄は、色々な実装方法が思い付くような処理ではない。</p>
            <p>簡単に言えば、newとdeleteなわけだ。</p>
            <p>ならば、わざわざベースシステム側にそれを任せることもない気がする。</p>
            <p>そうすれば、ベースシステム側が設定ファイルを解析したり、モジュールをロードしたりする必要はなくなる。</p>
            <p>＊</p>
            <p>どちらにせよ、まずはショートカットファイルからゲームについての情報を取り出す処理を追加するところからだろうか。</p>
            <p>どこに記述したところで、その処理自体は変わらないだろうし。</p>
        </div>
        <hr />
        <div>
            <h2>2015/11/25 02:30</h2>
            <p>モジュールのロード、ロードしたモジュールからの関数取得も完了。</p>
            <p>＊</p>
            <p>これを使ってベースシステムの起動をするわけだが、それにはダミーのベースシステムを作る方が先か。</p>
            <p>中身空っぽでいいから、これはさっとできるだろうな。</p>
            <p>次はどうするべきかな。</p>
            <p>ベースシステムの実行の次、となるとゲームの起動だろうか。</p>
            <p>それをするとなると、ベースシステムから設定ファイルを読んだりモジュールをロードしたりする必要があるだろうから、ライブラリを作る必要がありそうだなぁ。</p>
            <p>＊</p>
            <p>3連休中、raspberrypiをいじくっていた。</p>
            <p>とりあえずの成果として、比較的簡単にraspberrypi用のgentooのrootfsを生成できるようになった。</p>
            <p>私は出来合いのカーネルとか使いたくないので、というよりカーネルの機能を増やしたい時とかに備えてカーネルは時前でビルドしたいので、その辺は自分でやる必要があるけど。</p>
            <p>で、raspberrypi版のxlink kaiとかあったんで、xlink kaiを使うためだけのraspberrypiを作れないか画策中。</p>
            <p>xlink kaiは昔windows版を使っていたことがあったが、PSPとパソコンをアドホックで接続するために、わざわざパソコン側で操作が必要になるのが面倒だった。</p>
            <p>なので、その辺の操作を自動化してみたい。</p>
            <p>しかし、アドホック接続についての情報がうまく見つからない。</p>
            <p>特定のPSPを示す識別子みたいのってないのかな。</p>
        </div>
        <hr />
        <div>
            <h2>2015/11/17 00:15</h2>
            <p>とりあえずテストプログラムのビルドルールを分離させた、のだけど。</p>
            <p>＊</p>
            <p>今のままでは、configure時にテストプログラムについてもビルドするよって指定しないとビルドしてくれない。</p>
            <p>確か前は、そういう風になってしまうのを嫌ってテストプログラムのビルド処理を分けなかったんだった気がする。</p>
            <p>実際面倒だし、テストプログラムが増えるたびにconfigureコマンドのオプション指定が増えることになる。さすがに嫌だ。</p>
            <p>＊</p>
            <p>依存関係を定義できるようにするべきかもしれない。</p>
            <p>このプログラムをビルドする場合、他のプログラムもビルドする、みたいな指定。</p>
            <p>そういう仕組みを作れば、あるプログラムに関連するテストプログラムの自動的なビルドも可能になる。</p>
        </div>
        <hr />
        <div>
            <h2>2015/11/14 00:18</h2>
            <p>いかんいかん。典型的な三日坊主じゃないか。</p>
            <p>＊</p>
            <p>微妙に詰まっている。</p>
            <p>モジュールロード機能のテストコードを作ったので、そのテストを通そうとしたところで困った。</p>
            <p>テストでモジュールをロードする必要があるので、そのためのダミーモジュールを作る、それはいい。</p>
            <p>しかし、現状ではテストコードにライブラリやらなんやらを関連付けることができない。</p>
            <p>なので、どう変えるべきか考え中。</p>
            <p>よく考えたら、テストプログラムの在り方がおかしい気がする。</p>
            <p>なんらかのプログラムに付随するものとしてるから、テストに対して他の何かを関連付けられないのだ。</p>
            <p>最初からテストプログラムも独立したプログラムとして扱えば、こんなことにはならないはずだ。</p>
            <p>不要にビルド処理を複雑にしてしまっている雰囲気がする。</p>
            <p>改善しなければ。</p>
        </div>
        <hr />
        <div>
            <h2>2015/11/11 00:17</h2>
            <p>0.4.0できた。</p>
            <p>＊</p>
            <p>パッケージ情報ファイルとショートカットファイルの内容から、取得できる範囲の情報を取得、表示するところまでやって0.4.0とした。</p>
            <p>取得した情報を使えばベースシステムの起動までできるはずだが、そのためには起動するベースシステムも中身からっぽでいいから作らないといかん。</p>
            <p>ベースシステムの起動まで作ったら、次はどうしようか。</p>
            <p>ベースシステムの中身を詰めていくべきかな。</p>
            <p>パッケージ設定ファイルの処理とかもないわけではないけど、これ以上同じような作業はきついものがある。</p>
            <p>それに前にも書いた通り、パッケージ設定ファイルは今のところ無くても問題ないのだ。</p>
            <p>これ以上モチベーションを落としたくないし。</p>
        </div>
        <hr />
        <div>
            <h2>2015/11/10 02:03</h2>
            <p>やはりそう簡単にはやる気は戻らんらしい。</p>
            <p>＊</p>
            <p>リファクタリングしたり、パッケージ情報ファイルを解析したデータからデータを取得する関数を追加したりしてたら、今日中に0.4.0を作りきれなかった。</p>
            <p>でもまぁ、パッケージ情報ファイルから名前に対応したベースシステム情報を取得する関数の処理を実装したら、あとはメインの処理を追加して、デバッグ出力を追加すれば完成だろうか。</p>
            <p>道筋は見えているので、起きたらさくさくっと完成させたい。</p>
        </div>
        <hr />
        <div>
            <h2>2015/11/09 00:38</h2>
            <p>前回から1ヶ月程度か。結構さぼってしまった。</p>
            <p>＊</p>
            <p>作業はしてたんだけど、やはり牛歩。</p>
            <p>やる気が出なかったのは、退屈な作業というか、前のバージョンで追加したのと同じような作業をやることになったからだろうな。</p>
            <p>前はショートカットファイルの解析で、今回はパッケージ情報ファイルの解析。</p>
            <p>必要なことではあるのだが、なんとも退屈な作業だった。</p>
            <p>＊</p>
            <p>パッケージ情報ファイルの解析処理はなんとかできたので、それを使って得られた情報を出力して、それを0.4.0とすることにしよう。</p>
            <p>明日にはパパッと作ってしまって、さっさと次に進みたいところ。</p>
            <p>ベースシステムの情報は取得できるようになったわけだし、次はいよいよベースシステムの起動に入れるか。</p>
        </div>
        <hr />
        <div>
            <h2>2015/10/03 00:00</h2>
            <p>機能を実装したと仮定した処理を記述していっているのだが、つまずいている。</p>
            <p>＊</p>
            <p>パッケージ情報ファイルを読み込む、これはいい。</p>
            <p>読み込んだパッケージ情報ファイルからベースシステムの情報を取り出す、これもいい。</p>
            <p>この次がしっくりこない。</p>
            <p>手順としては、まずモジュールをロードするんだろうけど。</p>
            <p>モジュールをロードして、ロードしたモジュールからベースシステムの関数を取り出し、取り出した関数を実行する。</p>
            <p>急に処理のレイヤーが低くなるから違和感を覚えるのかしら。</p>
            <p>＊</p>
            <p>ベースシステムの情報を取り出すのではなく、パッケージ情報ファイルの内容とベースシステム名を引数にベースシステムを実行する、の方がいいのかなぁ。</p>
            <p>だったら、パッケージのパスとベースシステム名を引数にベースシステムを実行する、の方がよりいいかもしれない。</p>
            <p>後のことを考慮すればもっとまとまるだろうか？</p>
            <p>パッケージ設定ファイルを読むようにした場合だ。</p>
            <p>パッケージ設定ファイルを読み、使用するパッケージのパッケージ情報ファイルを読み、使用するモジュールを列挙、ロードし、ベースシステムを含むモジュールからベースシステムの関数を取り出し、実行。</p>
            <p>関数をどう、とかなると低レイヤーすぎるから、ベースシステムの実行として1つの処理にまとめるべきだろうな。</p>
            <p>可変長の引数を取り、それを共有ライブラリから取り出した関数ポインタの引数に渡して呼び出す、みたいなことできればいいんだけどそんな簡単にできるだろうか。</p>
        </div>
        <hr />
        <div>
            <h2>2015/10/01 18:40</h2>
            <p>0.3.0できた。</p>
            <p>＊</p>
            <p>設定ファイル要素の集合体からショートカットファイルを表す構造体を生成する処理を追加した。</p>
            <p>こういう構成の設定ファイルがショートカットファイル、というのを定めたことになる。</p>
            <p>とはいえ、ベースシステム実行に必要な要素だけが記述された、暫定的なものだけど。</p>
            <p>具体的には、ベースシステムが含まれるパッケージのパスと、ベースシステム名、この2つ。</p>
            <p>この2つの情報が記載されたファイルをショートカットファイルとする。</p>
            <p>＊</p>
            <p>次は、その2つの情報を使い、ベースシステムを実行する処理を作ろう。</p>
            <p>それを0.4.0とする。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/26 00:55</h2>
            <p>昨日、方針を固めたのはいいのだが。</p>
            <p>＊</p>
            <p>実際に作業を進めようとしたものの、なんだかやりにくい。</p>
            <p>どうにも、処理が不完全な感じがある。</p>
            <p>ショートカットファイルの読み込み、解析を行なっているものの、最終的に生成しているのがショートカットファイルを表す構造体でないのが分かりにくい原因か。</p>
            <p>現状、設定ファイル要素の集合体としてしか扱っていない。</p>
            <p>データを取り出すにも、例えばマップにキーに対応するデータが存在するか、とかから始めないといけない。</p>
            <p>ショートカットファイルとして正しいのかどうかのチェックを行なっていないから、そのようなめんどうなことになるのだ。</p>
            <p>設定ファイルとして文法が正しいか、の次にショートカットファイルとして正しい構成になっているか、のチェックが必要だ。</p>
            <p>そうすれば、データを取り出す際にいちいちデータの存在チェックとかやらんで済む。</p>
            <p>＊</p>
            <p>どうしよう、それを0.3.0として作るか？</p>
            <p>機能として完全に分離させた方がよさそうだし、そうするかなぁ。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/24 23:55</h2>
            <p>考えて考えて、ようやく方針が固まった。</p>
            <p>＊</p>
            <p>次は、ベースシステムを実行する処理を作る。</p>
            <p>ベースシステムとゲームの構成についても変更する。</p>
            <p>前のプロジェクトでは、ベースシステムは生成・破棄するもの、ゲームは実行するものという扱いだったが、これは逆にする。</p>
            <p>ベースシステムは実行するもの、ゲームは生成・破棄するもの。</p>
            <p>ゲームは完全に動作を制御したいのだ。</p>
            <p>だから実行する、つまり制御を完全に移す形にするのは適切ではない。</p>
            <p>ベースシステムは制御できる形にしたところで、じゃあそれを誰が制御するんだよって話になる。</p>
            <p>起動プログラム？そんなめんどうなことはさせたくない。</p>
            <p>よって制御を完全に移す形にする。</p>
            <p>＊</p>
            <p>というわけでベースシステムのライブラリをロード、関数を取り出し呼び出す、ということをすることになるが、まずはできるだけ規模を小さくする。</p>
            <p>ライブラリを扱うということはパッケージを扱うことになるのだが、本来想定している処理の流れは以下の通りだ。</p>
            <p>・パッケージ設定ファイルを読み込み、利用するパッケージ、モジュールを特定</p>
            <p>・利用するパッケージのパッケージ情報ファイルを読み込み、ベースシステム実行関数が含まれるモジュールや、モジュールの実体（ファイル名）などを把握</p>
            <p>・利用するモジュールを全てロード、ベースシステム実行関数が含まれるモジュールから関数を取り出し呼び出す</p>
            <p>こんな感じだが、まずは最初のパッケージ設定ファイルの読み込みを行なわないことにする。</p>
            <p>単にモジュールを読み込んで関数を取り出し呼び出すだけなら、パッケージ情報ファイルを読めばできるのだ。</p>
            <p>パッケージ設定ファイルは、モジュールの利用する・しないの判断や、依存パッケージの指定、パッケージとセーブデータの関連付け、パッケージやモジュールへのパラメータの設定などなど、より高度なことを行うために必要となるが、最低限の動作では必要ない。</p>
            <p>よって、0.3.0ではパッケージ情報ファイルを読み込み、ベースシステムを実行するところまで作る。</p>
            <p>＊</p>
            <p>パッケージ設定ファイルを使う前提で考えていたから、どう進めるべきか決まらなかった感じがある。</p>
            <p>もし無理矢理その方向で進めていたら、またしても泥沼の展開だっただろうな。</p>
            <p>こんなに長く考えたのだから、それを避けられればいいのだが。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/24 12:40</h2>
            <p>連休を利用して、マシンの環境を構築し直していた。</p>
            <p>＊</p>
            <p>今までは、64bitと32bitの環境を完全に分けて構築していた。</p>
            <p>64bit環境で32bitプログラムを動かすために、エミュレーションライブラリを使う必要があるのを嫌ったためだ。</p>
            <p>しかしながら、今年の3月頃だったか、エミュレーションライブラリの使用は非推奨になった。</p>
            <p>64bit環境で32bitプログラムを動かすために必要となるライブラリも、ソースからビルドできるようになったからだ。</p>
            <p>わざわざ環境を作り直すのはめんどうなのでやってこなかったが、2つの環境を扱うのも色々めんどうがある。</p>
            <p>例えばパッケージの更新は2環境にそれぞれ実行しなければならないし、設定ファイルなんかも2箇所に置くことになるし、そもそも2環境作ると容量結構取るし。</p>
            <p>そんなわけで環境を作り直した。</p>
            <p>＊</p>
            <p>今のところ、問題なく動いているようだ。</p>
            <p>skypeなんかは、前は32bit環境で動かしていたため、32bit環境に移行→skype起動、などとするスクリプトとか用意してたんだけど、そんな必要もなくなった。</p>
            <p>32bit環境に移行する必要がなくなったからか、前より起動が速くなった気がする。</p>
            <p>＊</p>
            <p>後は、raidをマシンの外に出したいけれど、これをやるとなるとまためんどうそうだなぁ。</p>
            <p>封印してある玄箱T4を使おうと思っているが、これを普通に使おうとすると、4つ入るハードディスクのうち、どれか1つの中に環境を構築しないといけないとかいう残念なやつだし。</p>
            <p>それを避けるには、外部に環境を作りNFSでマウントして使う、とかしないといけないんだけど、これまためんどい。</p>
            <p>ちょうど使ってないraspberrypiもあることだし、それを使おうと考えているが、結局そっちの環境構築も必要になるわけだし。</p>
            <p>やるなら次の土日だろうけど、土日で完了できるだろうか。</p>
            <p>いや、まず無理だな。できてraspberrypiの環境構築くらいなものだろう。</p>
            <p>＊</p>
            <p>ちなみに環境というのはどれもGentooだ。Gentoo Linux。</p>
            <p>柔軟で扱いやすくていい。</p>
            <p>しかし、パッケージをソースからビルドする形なので時間がかかりがちなのが難点。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/16 23:50</h2>
            <p>昨日のうちに、0.2.0は完成した。</p>
            <p>＊</p>
            <p>のだが、次はどうするべきか決めかねている。</p>
            <p>ベースシステム情報が得られているのだから、ベースシステムの構築・起動をするべきだろうか。</p>
            <p>しかし、ベースシステムとゲームをどう連携させるかまだ決まってないしなぁ。</p>
            <p>最低限決まっているのはベースシステムを起動した後にゲームを起動させるという順番くらいなものだろうか。</p>
            <p>とりあえずをそれをやってしまうべきか？</p>
            <p>中身はほぼ空でも。</p>
            <p>＊</p>
            <p>しかし、それはまた行き当たりばったりな感じがするし。</p>
            <p>もうちょい考えをまとめるべきだろうなぁ。</p>
            <p>ゲームはどこでロードするのか？</p>
            <p>今作っている起動プログラムか？もしくはベースシステム内の処理か？</p>
            <p>前者の場合、ゲームをロードする必要がある時には起動プログラム側に制御を戻さなければならなくて、なんだか奇妙だ。</p>
            <p>後者の場合、起動プログラムからベースシステムをロードして動かし、ベースシステムからゲームをロードして動かす、という流れになって、見た目きれいな感じがする。</p>
            <p>しかしながら、ゲームのロードには設定ファイルの読み込みが必要になるものの、そもそもベースシステムからして設定ファイルの読み込みを行なった上でロードするのだ。</p>
            <p>設定ファイルの読み込み処理は、普通に考えたら起動プログラム部分に配置することになる。</p>
            <p>それをどうやってベースシステムから呼び出すのか？</p>
            <p>案はないわけではないが。</p>
            <p>モジュールの設定という概念を追加して対応する、というのが今考えている案。</p>
            <p>それにより起動プログラム内の関数名を指定し、モジュールロード時に関数を取得、という感じだ。</p>
            <p>そんな関数が用意されているかは謎だ。</p>
            <p>＊</p>
            <p>うーん、設定ファイル形式の解析処理はできているわけだから、解析を行なった次の段階、設定ファイルを読み込みデータを取得するための関数を実装すべきだろうか。</p>
            <p>だとして、その目的はどうするべきか？</p>
            <p>これまでは、それぞれファイルの内容を出力するためにファイル読み込み処理を追加したし、読み込んだファイルから意味あるデータを取得するために解析処理を追加した。</p>
            <p>目的を持たない機能追加はその実用性に疑問が残る。</p>
            <p>次にやる事を考えれば、ベースシステムの構築なわけで、つまりモジュールのロードや、ロードしたモジュールからの関数取得か。</p>
            <p>それらの処理を行なうための入力データとして、ファイルから読み込んだデータを構造体にまとめる、という感じになるか。</p>
            <p>＊</p>
            <p>ということで、目的はベースシステムの構築、もといベースシステムの生成・破棄関数の呼び出しか。</p>
            <p>それに付随して、モジュールのロードや、設定ファイルの形式を定めていったりする必要がある。</p>
            <p>まずは、すごい簡単なベースシステム生成・破棄関数を持ったライブラリを作るところから始めるべきか？</p>
            <p>その辺ができてこないと、設定ファイルにどう記述していいか分からないしなぁ。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/15 01:55</h2>
            <p>ちょっと不調。データ取得関数を一通り追加したところまで。</p>
            <p>＊</p>
            <p>多分、これで設定ファイルに関する関数は一通りできたはず。</p>
            <p>あとはこれらを使ってメイン処理を組み立てる。</p>
            <p>明日には0.2.0を仕上げたい。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/11 18:40</h2>
            <p>マップ要素まで完了した。</p>
            <p>＊</p>
            <p>後は、解析したデータからのデータ取得関数とか追加しながらメイン処理を組み立てて、0.2.0の完成といったところか。</p>
            <p>次はどうするべきか。</p>
            <p>設定ファイルからベースシステムについての情報とゲームについての情報を得られるわけだから、ベースシステムの生成だろうか。</p>
            <p>ベースシステムはどこで作ろうか。</p>
            <p>暫定的なものはcandymakerで作ってしまおうか。</p>
            <p>それが、とりあえずはコンパクトでいい気もする。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/11 02:05</h2>
            <p>リスト要素はできたが、マップ要素はまだ。</p>
            <p>＊</p>
            <p>来週には持ち越したくないなぁ。</p>
            <p>明日中にマップ要素を完成させて、来週からは作った処理を使って読み込んだショートカットファイルの内容を解析したいところ。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/09 23:40</h2>
            <p>リスト要素の解析は完成には至らなかった。</p>
            <p>＊</p>
            <p>しかしもう少しだ。</p>
            <p>残件は複数の要素を含むリストの場合の処理。</p>
            <p>要素が単一の場合については完了している。</p>
            <p>なので、30分、あるいは1時間もあれば十分できるんじゃないかな。</p>
            <p>ソースファイルを要素毎に分けたりしたので、作り切れなかったんだろうか。</p>
            <p>ならば、明日中にリスト要素の完成に加えて、マップ要素も完成させてしまいたいところだが。</p>
            <p>マップ要素の処理はリスト要素と似ているので、案外早く片付きそうな気がする。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/08 22:15</h2>
            <p>設定ファイルの文字列要素の解析処理はできた。</p>
            <p>＊</p>
            <p>想定よりも時間がかかってしまった感じがある。</p>
            <p>しかし、これから追加する予定のリスト、マップ要素でも共通して利用することになる処理も含んでいるので、案外こんなものかもしれない。</p>
            <p>明日はリスト要素の対応。</p>
            <p>ちゃっちゃと片付けてしまいところだが、現状の文字列要素の処理を別ファイルに分離したりとかそういう作業が必要になってくるので、意外と面倒かも。</p>
            <p>＊</p>
            <p>今回作った文字列要素解析処理のソースはおよそ300行。</p>
            <p>全てが文字列要素についての処理というわけではなく、要素共通の処理も含まれているが。</p>
            <p>それに比べて、前回のプロジェクトで作ったソースは文字列要素についてのファイルがおよそ150行、要素共通のファイルがおよそ550行。</p>
            <p>前回のプロジェクトの要素共通のファイルでかすぎない？と思って中を見てみたら、デバッグ出力に結構行数使ってた。</p>
            <p>そういや前回のは、動作確認のために読み込んだデータの内容を1つ1つ出力してたな。</p>
            <p>今回はその辺のチェックがテストコードで済むので、こんなでかいデバッグ出力処理はいらないだろう。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/08 00:05</h2>
            <p>というわけで、テストファーストで作るのを試している。</p>
            <p>＊</p>
            <p>前に作ったソースを流用する予定だったけど、テスト駆動開発の練習も兼ねてほぼ1から作っている。</p>
            <p>最初にごく単純な処理を実装するために、まずテストを書く。</p>
            <p>アサートを先に書き、そのアサートに至るための処理を書いてテストコードとする。</p>
            <p>次にそれを失敗するコードを書き、そのテストコードがテストで実行されることを確認する。</p>
            <p>次に、テストを通すことだけを目的とした、固定値を返すような不完全な仮実装を行ない、テストが通ることを確認する。</p>
            <p>仮実装では不完全ということを示すために、別の入力を行なった場合のテストを書く。</p>
            <p>本実装をして、両方のテストが通ることを確認し、完了。</p>
            <p>最後の方はなんか違うような気がするけど。</p>
            <p>確か、テストは1つで、不完全な仮実装でテストを通し、後はテストが通ることで処理が正しいことを確認する、みたいな感じだったような。</p>
            <p>テストを2つ書くのは三点測量とかいう、なんか不安な時にやる方法とかだったような。</p>
            <p>でもこっちの方がより納得できるんだよなぁ。</p>
            <p>仮実装でもテストが通るというのが気に食わない。</p>
            <p>で、仕様を追加する場合も同じ手順で進めていく。</p>
            <p>＊</p>
            <p>その結果、前に書いた時とは処理方法が変わった。</p>
            <p>まだ前に書いた機能には達していないので変わりそう、が正しいが。</p>
            <p>単純、コンパクトな実装でテストを通すようにしているためか、前に書いたのより見やすく、分かりやすくなっている気がする。</p>
            <p>前はテストとか書いてなかったから、処理ありきで書いていたため、頭の中にある処理をそのまま書き出していたからごちゃごちゃしていた。</p>
            <p>今回はテスト、つまり結果が先に来て、その結果にするためにどうするか、という考え方に加えて、機能を細かく1つずつ実装していっているので、ごちゃごちゃしてない感じがある。</p>
            <p>これなら、機能を増やしていっても見やすい、分かりやすいコードが書けそうだ。</p>
            <p>＊</p>
            <p>初日ということもあってかあまり進んでいないが、大体分かってきたので明日からはもっと進められればいいのだが。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/06 01:25</h2>
            <p>CppUnit？知らない子ですね。</p>
            <p>＊</p>
            <p>Google Testに切り替えた。</p>
            <p>他にもBoost.Testとかあったらしい。</p>
            <p>完全に調査不足である。</p>
            <p>Google Testに決めたのは、出力に色が付くのでテストの成否が一目で分かるというのが一番の理由。</p>
            <p>その結果、CppUnitをより扱いやすくするために書いたコードは全て不要になった。</p>
            <p>悲しい。</p>
            <p>＊</p>
            <p>元々、CppUnitはJUnitをC++用に書き直したようなものだからか、クラスありきな書き方が気に入らなかった。</p>
            <p>Google Testなら、クラスを作らずにテストを書けるし、必要に応じてクラスを使ったテストも書くことができていい感じっぽい。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/05 13:15</h2>
            <p>昨日は久々に朝方まで作業してしまった。</p>
            <p>＊</p>
            <p>その甲斐もあって、CppUnitを利用した自動テスト実行環境は大体整った感ある。</p>
            <p>wafの自動テストサポートも使い、ビルド成功時にテストプログラムが自動的に実行されて、テストが通ったか通らんかったか表示されるようにした。</p>
            <p>ただ、テストの通った通らないはテストプログラム単位なので、テストが通らなかった時にどのテストが通らなかったのかは表示されない。</p>
            <p>なので、その場合は自分でテストプログラムを実行してどのテストが通らなかったのか確認する必要がある。</p>
            <p>そこが少し面倒だが、かといって全テストの出力を表示すると量が多すぎるか。</p>
            <p>＊</p>
            <p>テストコードのファイル数が増えれば増えるほど、テスト対象コードの全く同じコンパイル処理の回数が増えると思われる。</p>
            <p>ビルド時間の増大が懸念されるが、全く同じということはコンパイルキャッシュなるものを使えば時間短縮できるんだろうか。</p>
            <p>＊</p>
            <p>もうちょい整えたらテストファーストで作業を開始するつもりだけど、それは月曜からにしようかなぁ。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/04 02:45</h2>
            <p>タグとか初めて使った。</p>
            <p>＊</p>
            <p>使い方これでいいのかよく分からんけど。</p>
            <p>とりあえず<a href="https://bitbucket.org/tekuto/candymaker" target="_blank">リポジトリを作っておいた。</a></p>
            <p>読んだファイルの内容を処理するところまでやろうかとも思ったけど、とりあえずファイルを読み込んでその内容を出力するだけ。</p>
            <p>それでバージョン0.1.0ということにした。</p>
            <p>次は読んだ内容を処理し、データを抽出して出力する。</p>
            <p>それを0.2.0ということにしよう。</p>
            <p>基本的には、処理内容は今までに作ったやつから持ってくればいいと思う。</p>
            <p>でも今回は、自動テストを作ってから作る、テストファーストというやつをやってみよう。</p>
            <p>そのためにCppUnitをインストールしたのだ。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/02 22:45</h2>
            <p>超久しぶり。</p>
            <p>＊</p>
            <p>正直詰まってる感じある。</p>
            <p>思うに、やはり行き当たりばったりすぎるのだろう。</p>
            <p>筋道が立たずにところどころ肥大化しつつあるような、どうしようもない進め方になってしまっている。</p>
            <p>こんなことしても進んで戻ってを繰り返すことになりそうでさすがに躊躇しているのだが、1から作り直すべきかもしれない。</p>
            <p>一体何回目になるのだ。4回？5回？</p>
            <p>経験はどんどん蓄積されているわけなのだから、それをうまく利用できればいいのだけれど。</p>
            <p>＊</p>
            <p>まずは単純なものを作らなくては。いつもここが抜けている気がする。</p>
            <p>色々考えた結果、とりあえずベースファイルとかいらん。</p>
            <p>環境に1つの設定ファイルなんぞ見るとかそんなんもっと後でいい。今はいらん。</p>
            <p>コマンドライン引数から設定ファイルのパスを受け取り、そのファイルの内容を処理する。これだ。</p>
            <p>いっそそのファイルのパスも固定してしまえばもっと単純になるかもしれないが、さすがに実用性がなさすぎる気がする。</p>
            <p>＊</p>
            <p>ここまで書いといて今更だが、作ろうとしてるプログラムの大まかな流れは、</p>
            <p>・ベースシステムという機能集合体を生成</p>
            <p>・ベースシステムを利用して動作するゲームをロード</p>
            <p>・ゲームを動かす</p>
            <p>という感じになる。</p>
            <p>前述のコマンドライン引数で渡す設定ファイルのパスというのは、ゲームについての情報が書かれているファイルだ。</p>
            <p>現状では、ベースシステムについての情報は何一つ書かれていない。</p>
            <p>これまでの想定としては、ベースシステムについての情報は環境に1つの設定ファイルに記述しておく形だった。</p>
            <p>しかしよく考えると、それだと使用するベースシステムが固定的になりすぎる気がする。</p>
            <p>別のベースシステムの上でゲームを動かしたいなーとかなった時に面倒だ。</p>
            <p>なので、コマンドライン引数で渡す設定ファイルの中に、ベースシステムについての情報も書いておくべきかななどと思った。</p>
            <p>そもそもコマンドライン引数で渡す設定ファイルはショートカットファイルという名前だ。</p>
            <p>それ1つ読めば、とりあえずゲームが起動するところまでできるべきファイルなのだ。</p>
            <p>ならば、ショートカットファイルにはベースシステムの情報とゲームの情報、どちらも記述するべきだろう。</p>
            <p>後々既定のベースシステムとか作る場合には、ベースシステムの情報の記述は必須ではないとかにすればよかろう。</p>
            <p>＊</p>
            <p>そこからまた展開させようとすると、どんどん肥大化していく悪寒がする。</p>
            <p>なのでとりあえず決まったそこまで作ろう。</p>
            <p>まずコマンドライン引数でショートカットファイルパスを受け取る。</p>
            <p>次にそのファイルを読む。</p>
            <p>最後に読んだ内容を出力する。</p>
            <p>これだ。これで行こう。</p>
            <p>ここまで作ったらまた書く。</p>
        </div>
        <hr />
        <div>
            <h2>2015/03/02 20:49</h2>
            <p>パッケージ設定に対応するパッケージ情報と、依存パッケージ設定の読み込み処理まで作った。</p>
            <p>＊</p>
            <p>次は、その読み込んだ設定ファイル群からベースシステム情報を取得する処理と、その構築に必要なモジュール群の列挙処理か。</p>
            <p>それを終えて初めてモジュールマネージャに取りかかれるな。</p>
        </div>
        <hr />
        <div>
            <h2>2015/02/25 16:02</h2>
            <p>設定ファイル、JSONじゃない方がいいかもしれない。</p>
            <p>＊</p>
            <p>思いの他扱いやすいし見づらくもないので大体問題はないんだけど、JSONの仕様には存在しない要素がほしい。</p>
            <p>具体的に言うと集合がほしい。</p>
            <p>現時点では、やろうとするとリストとして記述し、JSONを読み込んでデータを取り出した後に、重複するデータは削除するなどすればできるけど、なんだか回りくどい。</p>
            <p>JSONを読み込んだ時点で、重複するデータは削除するようにしてしまいたいところ。</p>
            <p>[]はリストで、{}はオブジェクトだから、適当なところで()だろうか。</p>
            <p>pythonと同じような感じになりそうだな。</p>
            <p>ただこれをやるとなると、JSONの比較処理も追加しなければならないな。</p>
            <p>＊</p>
            <p>JSON読み込み処理は現時点ではかなり限定的でJSONとは呼び難いのだけど、この機能を追加するとJSONの定義から完全に外れることになる。</p>
            <p>だからどうだということも、特にないが。</p>
        </div>
        <hr />
        <div>
            <h2>2015/02/25 13:01</h2>
            <p>設定ディレクトリ内にあるコンフィグディレクトリってなんだろうな。</p>
            <p>＊</p>
            <p>パッケージのモジュールの使用許可やセーブデータディレクトリとの関連付けなどを記述した設定ファイルなんだけど、パッケージ設定とは呼びにくい。</p>
            <p>パッケージディレクトリに配置されている各パッケージ内にも設定ファイルが存在するからだ。</p>
            <p>現時点では、後者を読み込む時にPackageConfigという構造体にデータをつっこんでいる。</p>
            <p>しかし、このファイルは基本的にユーザーが変更することはないため、設定というよりは情報が記述されているだけのファイル、と考えるべきかもしれない。</p>
            <p>そう考えると、PackageConfigではなくPackageInfo、パッケージ情報ファイルと呼ぶべきかもしれない。</p>
            <p>そうすれば、モジュールの使用許可などを記述したファイルのことをパッケージ設定ファイルと呼べるし。</p>
            <p>今まで脳内ではコンフィグ設定ファイルとか呼んでいたが、コンフィグと設定って同じ意味だし、構造体にしようとするとConfigConfigになっちゃうしで困っていたが、これでどうにかなりそうだ。</p>
            <p>＊</p>
            <p>前の記事に書いた作業については昨日のうちに終わらせておいた。</p>
        </div>
        <hr />
        <div>
            <h2>2015/02/23 23:31</h2>
            <p>思うに、ソースコードが読みにくい。</p>
            <p>＊</p>
            <p>情報を表すデータと、情報を参照するための情報を表すデータがほぼ同じ名前で定義されているため分かりにくい。</p>
            <p>前者をXXとしたら、後者はXXRefという感じに命名するようにしようかなぁ。</p>
            <p>デバッグ出力も、後者もXXとほぼ同じ出力になっちゃってるから分かりにくいし。</p>
            <p>＊</p>
            <p>モジュールマネージャに取りかかる前に、まずはそこらのリファクタリングからだな。</p>
        </div>
        <hr />
        <div>
            <h2>2015/02/23 19:29</h2>
            <p>牛歩、牛歩。</p>
            <p>＊</p>
            <p>ようやくモジュールマネージャに取りかかれそう。</p>
            <p>パッケージ設定ファイルからベースシステムの設定を取得するところまではできたので、ベースシステムを生成するために生成関数と破棄関数の取得を行なわねばならない。</p>
            <p>関数の取得の前にはモジュールのロードを行なわなければならないし、つまりいよいよモジュールマネージャというわけである。</p>
            <p>＊</p>
            <p>基本データ型の定義を変えるべきかもしれない。</p>
            <p>現時点では、typedefを使ってintをfg::Intと定義したりしてるのだけど、モジュールがエクスポートするシンボルのことを考慮すると、これはあまりよくない気がする。</p>
            <p>fg::Intはシンボルとしてはintと同じように扱われてしまう。</p>
            <p>これはあまり都合がよくない。</p>
            <p>fg::Intはfg::Intとして扱われていた方が都合がいいのだ。</p>
            <p>主に、シンボル名のマングリングとかそこらの処理のために。</p>
            <p>それをやるためには、fg::Intをtypedefではなくクラスとして定義すればいいのだろうけど、ソースコード上での扱いは今までのから変更したくはない。</p>
            <p>演算子のオーバーロードを駆使することで達成できるのかなぁ。不安だ。</p>
        </div>
        <hr />
        <div>
            <h2>2015/02/10 22:35</h2>
            <p>このところ、raspberrypiをいじくっていた。ちょうど日記が途切れた辺りから。</p>
            <p>＊</p>
            <p>raspbmcをつっこんでみたり、openelecをつっこんでみたり。</p>
            <p>raspberrypiでradiko使ってラジオが聴けるようになったり、インターネットラジオ聴けるようになったり、youtube見れるようになったり、天気予報確認できるようになったりなど。</p>
            <p>テレビにHDMIでつなげばテレビのリモコンで操作できるようになったりしておもしろい。</p>
            <p>＊</p>
            <p>で、bindとdhcpを動かしてるraspberrypiにこれらの機能をつっこめないか、と思って色々試していたのだが、結局今動いているようなgentooにxbmcをインストールするのが一番手っ取り早そう、という結論に達した。</p>
            <p>raspbmcはなぜか無線LANがうまくつながらんし、openelecはbindとdhcpを追加するのがかなりめんどそうだし。</p>
            <p>＊</p>
            <p>しかしながら、gentooをまた構築するのもそれはそれでめんどうだったり。</p>
            <p>いい加減dropmakerの方進めたくなってきたし、休みの日とかに気が向いたらちょっとずつ進めてみようかと。</p>
            <p>って明日祝日？明日はやらん。どうもraspberrypiに関わると頭が痛くなりやすい気がする。</p>
        </div>
        <hr />
        <div>
            <h2>2015/02/04 00:12</h2>
            <p>モチベーションが下がっているが、ちょっとずつ進んでいる。</p>
            <p>＊</p>
            <p>パッケージ設定ファイルも、大部分は処理できている。</p>
            <p>例によって、暫定的な実装であるため穴だらけだが、そのうちなんとかする予定。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/29 21:11</h2>
            <p>進みが遅くなっている。</p>
            <p>＊</p>
            <p>パス型の扱いを少し変えたり、パッケージ設定を読み込む際の処理で、今まで書いた処理を共通関数化して使えるようにしてから処理したりなど。</p>
            <p>パッケージ設定ファイルを見てて思ったのは、これまた割と適当に決めた感じがあるなぁということ。</p>
            <p>でもまぁ、とりあえず全部読み込んで型に落とし込む。</p>
            <p>そうしないと始まらん。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/28 00:28</h2>
            <p>パス型を文字列に変換する暫定的な処理ができた。</p>
            <p>＊</p>
            <p>しかし、本当に暫定的だ。</p>
            <p>機能も少ない。循環参照エラーの検出ができないため、設定ファイルでまずい記述をすると無限ループが発生する可能性もある。</p>
            <p>その辺の問題は後々解決していくとしよう。めんどいので。</p>
            <p>＊</p>
            <p>とりあえずパス型を文字列に変換し、ファイルを読み込むところまではできたが、読み込んだものの処理はまだ実装していない。</p>
            <p>その辺は明日やる。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/26 19:49</h2>
            <p>パッケージ設定の読み込み処理を作っているところ。</p>
            <p>＊</p>
            <p>ファイルをJSONとして読み込む処理とかは、ベース設定の読み込みでも使っているので使い回せるが、パスの扱いは今回が初になるため、そこで少し手間取っている。</p>
            <p>具体的にはパス型を文字列型に変換し、ファイルオープンなどに使えるようにする処理なのだが、今回作成するものは限定的な機能を持ったものでいいだろう。</p>
            <p>とにかく、パッケージ設定のパスを文字列にできればいいのだ。そのために全機能は必要ない。</p>
            <p>後々きちんと全機能作らなければならないだろうけど、今それをやると間違いなくだれる。</p>
            <p>今回作らない機能についても、大体どのように実装すればいいのかはイメージできているので多分大丈夫。多分。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/23 21:06</h2>
            <p>ひとまず、ベースシステム生成、破棄関数取得までの流れは作った。</p>
            <p>＊</p>
            <p>ベースシステムの生成、破棄に関わるモジュール群生成までの流れも作ってしまいたいところだったが、これにはモジュールローダの設計が大きく関わってくる。</p>
            <p>そして、今のところモジュールローダは中身が空っぽの状態だ。</p>
            <p>よってまだ書けない。書くのはモジュールローダの設計をまとめて、というかモジュールローダを作ってからだな。</p>
            <p>＊</p>
            <p>やはり今週中は無理だったな。来週中ならいけるかしら。</p>
            <p>来週の作業手順は、とりあえず流れを作ってあるベースシステム生成、破棄関数取得までの部分の実装を作るところからだろう。</p>
            <p>それを終えたら、モジュールローダを作るのとベースシステムの生成、破棄に関わるモジュール群生成を並行して行なう感じだろうか。</p>
            <p>大体後者が主導になると思うが。部品を先に作ってしまって、実際に使う場面でやっぱりびみょう、使い物にならんとかなったら目も当てられん。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/23 14:00</h2>
            <p>というわけで、サイトをgithub pagesに移行した。</p>
            <p>＊</p>
            <p>何日か前に書いたような気がしたけど書いてなかったので、経緯を書いておこう。</p>
            <p>gaeのツールが動かんくなった。</p>
            <p>どうもpythonのバージョンとうまく噛み合っていないらしく、バグ報告も上がっているようだけどツールのバージョンアップが来ない。</p>
            <p>現状やってることと言えば静的ページの公開だけだし、記事書いた後にコミットとは別にアップロードコマンド打つのもめんどうなので、github pagesに移行した。</p>
            <p>github pagesなら独自ドメイン使用時にサブドメイン付けなくていいし、サブドメインからリダイレクトさせることもできるので、URLをtekuto.netにできていい感じ。</p>
            <p>今までのwww.tekuto.netにアクセスすれば、tekuto.netにリダイレクトしてくれる。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/23 00:15</h2>
            <p>今週中に終わらせられれば、とか昨日書いたけど早速今日、諸事情により作業できなかった。</p>
            <p>＊</p>
            <p>明日から本気出す。</p>
            <p>でもさすがに明日1日で終わらせるのは無理だろうなぁ。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/21 18:10</h2>
            <p>ベース設定ファイルからベースシステムとシェルについての情報を読み込む処理を書いた。</p>
            <p>＊</p>
            <p>Baroqueのサントラ流しながら作業すると集中できていいな。</p>
            <p>歌が入ってるタイプの曲は、作業中の私にはあまり向かないようだ。</p>
            <p>気が散りやすいというか、ヘッドホンで聞きながら作業すると頭痛くなったりする。</p>
            <p>＊</p>
            <p>さて、ベース設定ファイルに記述する内容はひとまず全て読み込む処理を書いたので、次はそれを元にベースシステムを生成するための情報を生成する処理か。</p>
            <p>まずはどこからだろうか。ベースシステム情報に記述してある、パスに対応した設定ファイルを読み込む処理からかな。</p>
            <p>その設定ファイルには、対応するパッケージについて、そのパッケージのパスや、対応するセーブデータのパス、使用を許可するモジュールのリストなどが含まれている。</p>
            <p>ので、その設定ファイルを読んだら次はパッケージの設定ファイルを読み込んで、とかそういう流れになるんだろうな。</p>
            <p>なかなか負荷の高そうな内容だ。今週中に終わらせられればいいのだが。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/21 16:00</h2>
            <p>パス型の定義変更に対応完了。</p>
            <p>＊</p>
            <p>昨日に済ませておきたかったところだけど、ちょうどその直前できりがよかったため、昨日の作業はそこで切り上げてしまった。</p>
            <p>で、今日その辺をさくっと終わらせた。</p>
            <p>次はベースシステムやシェルについての情報をベース設定ファイルから読み込む処理と、ベース設定ファイルの情報を元に、色々設定ファイルとか読み込んで、ベースシステム生成に必要な情報を構築する処理かな。</p>
            <p>ベースシステムについての情報が記述されてるんならそれでいいじゃないかと思うかもしれないが、記述されているのは設定ファイルのパスとベースシステム名だけなので、具体的にどのモジュールをロードし、なんて関数を呼び出して生成し、破棄するか、といった情報は他の設定ファイルを読まないと分からない。</p>
            <p>なので、その辺どうにかする処理を書く、といった感じだ。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/20 14:38</h2>
            <p>やはりきちんと毎日書かんとだめだな。すっかり習慣がなくなってる。</p>
            <p>＊</p>
            <p>昨日の作業としては、設定ファイルの記述を修正したり、パス型の読み込み処理を独立させたりなど。</p>
            <p>パス型の定義を変えてあるため、現時点の処理では対応できないので、使う場面になったら修正することになるだろう。</p>
            <p>今日はベースシステム構築のためにコンフィグマネージャから情報を取得する処理とか書くつもりなので、前述の修正はやることになるかも。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/17 00:38</h2>
            <p>できるだけ忘れずに書いていくことにする。</p>
            <p>＊</p>
            <p>早速忘れかけていた上に、ツールがちゃんと動作するようになるまでネット上に上げられんけども。</p>
            <p>さて、結局設定ファイルの扱いについては、いっそのこと全ての設定ファイルを1箇所で管理した方が分かりやすいのでは、ということで話が進んでいる。</p>
            <p>設定ファイル間で関連性があるものも結構あるわけだし、管理オブジェクトに対し、情報を要求すれば必要に応じて設定ファイルを読み込んで情報を生成して返す、みたいな。</p>
            <p>一度読み込んだ設定ファイルはキャッシュしておいたり、もし要求があればキャッシュを削除したりなども考えているけど、前者はともかく後者は後回しだろうな。</p>
            <p>いや、前者も別に必須ではないな。</p>
            <p>もやもやは晴れつつあるし、ペース上げていきたいところだが。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/15 20:42</h2>
            <p>過去ログは年単位で分ければいいのでは、という声が一部でささやかれている。</p>
            <p>＊</p>
            <p>進みはスローペース。もっとさくさくやりたいところだが。</p>
            <p>ベース設定の一部を読み取る処理はできた。</p>
            <p>一部というのはパスの別名定義。パスに名前を付けて管理する形を取るので、そう呼んでいる。</p>
            <p>これにより、それぞれのデータのパスを指定できるようになった。</p>
            <p>最終的には、ベースシステムの構築→シェルの起動→ゲームの起動となるわけだが、それまでにどういう処理が必要になるだろうか。</p>
            <p>ベースシステムの構築やシェル、ゲームの起動のためには、やはりモジュールのロードが不可欠。</p>
            <p>よって、モジュールマネージャの生成が必要になるだろう。</p>
            <p>モジュールのロードには、パッケージディレクトリとコンフィグディレクトリに置かれているファイルの読み込みが必要になってくるはずだ。</p>
            <p>しかしその処理はモジュールマネージャ内で行うべきだろうか？難しいところだ。</p>
            <p>それを含めてしまうと、モジュールマネージャが肥大化してしまう気がする。</p>
            <p>とはいえ、どこかでは設定ファイル間の関連付けを解決する処理をやらねばならない。</p>
            <p>いっそ、モジュールマネージャではなく設定ファイルマネージャと考えるべきだろうか。</p>
            <p>モジュールのロードとかは、それとは別にモジュールローダというか、モジュールロードマネージャというか、そんな感じの機能を別に作り、そこでやらせる。</p>
            <p>パッケージディレクトリの設定ファイルと、コンフィグディレクトリの設定ファイル読み込み処理については、別々の機能に分けることはできないだろうな。</p>
            <p>パッケージに含まれるモジュール一覧とその詳細情報は前者に書かれているが、どのモジュールの読み込みが許可されているかどうかは後者に書かれている。</p>
            <p>あるモジュールを読み込むだけなら、後者の設定ファイルを読んだ後に前者の設定ファイルを読めばいいだけだが、モジュールによっては依存モジュールが存在する。</p>
            <p>依存モジュールについては、また後者の設定ファイルから読み直す必要がある。</p>
            <p>これを別々の機能に分けるとなると、循環参照になってしまって気持ちの悪いことになりそうな感じがある。</p>
            <p>＊</p>
            <p>書いてたら、ちょっともやもやが晴れた気がする。</p>
            <p>完全にクリアになったわけではないのだが。</p>
        </div>
        <hr />
        <div>
            <p><a href="/">戻る</a></p>
        </div>
    </body>
</html>
