<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>tekuto.net</title>
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-23511137-1"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'UA-23511137-1');
        </script>
    </head>
    <body>
        <div>
            <p><a href="/">戻る</a></p>
        </div>
        <hr />
        <div>
            <h2>2016/11/15 02:15</h2>
            <p>日数かけすぎたけど、設定ファイルに関数のシンボル情報を書かないようにする対応できた。</p>
            <p>＊</p>
            <p>その変更に対応するように、sucroseとかへびゲームとかを修正すれば完了。</p>
            <p>次はパッケージパスを利用してパッケージ内のファイルにアクセス、という本来やるべきだった作業に戻ろう。</p>
        </div>
        <hr />
        <div>
            <h2>2016/10/25 01:35</h2>
            <p>モジュール初期化時に情報を引数で渡すのはできた。</p>
            <p>＊</p>
            <p>ちょっと考えていたが、ゲームとベースシステムの情報を独立させているのはそのままでよかった。</p>
            <p>モジュール内に記述してしまうと、ショートカットファイルに記述する際にもモジュール名が必要になり、よくない。</p>
            <p>もう一方の関数のシンボル情報に関しては、予定通り進めよう。</p>
        </div>
        <hr />
        <div>
            <h2>2016/10/19 23:45</h2>
            <p>ひとまずテストの作成から。</p>
            <p>＊</p>
            <p>何を焦っていたのか知らないが、テストも作らずに始めようとしていた。</p>
            <p>なので、ひとまずテストを作った。</p>
            <p>明日にはそのテストを通す処理を実装するとしよう。</p>
        </div>
        <hr />
        <div>
            <h2>2016/10/19 00:45</h2>
            <p>久しぶり。</p>
            <p>＊</p>
            <p>まだ体調は不完全だが、今日無理しなければ明日には万全になるだろう。</p>
            <p>＊</p>
            <p>今更ながら、パッケージ情報ファイルの構成がおかしい気がする。</p>
            <p>おかしい点は2つ。</p>
            <p>1つは、パッケージ内のゲームとベースシステムの情報を独立させていること。</p>
            <p>まとめてあることで、見た目は分かりやすいが処理はしにくかった。</p>
            <p>それがどのモジュールに入っているのかという情報があるが、そもそもモジュール情報内に書いておけば済むことだ。</p>
            <p>もう1つは、ゲームやベースシステムの情報に関数のシンボル情報を含めていること。</p>
            <p>設定ファイルに記述する情報としては、ちょっと低レイヤーすぎる。</p>
            <p>設定ファイルには関数のシンボル情報を含めない形にした方がいいかもしれない。</p>
            <p>＊</p>
            <p>ちなみに、モジュール初期化時に渡すパッケージ情報に関するどうのこうの、もまだ終わっていない。</p>
            <p>正直、渡す内容についても再度検討するべきではと考えている。</p>
            <p>いっそ、パッケージ情報ファイルの中身も渡してしまった方が分かりやすいような。</p>
        </div>
        <hr />
        <div>
            <h2>2016/10/05 00:40</h2>
            <p>ひどくやる気が出ない。</p>
            <p>＊</p>
            <p>しかし、このままではまずいので直近でやるべきことをリストアップし、とりあえずfgに関数の宣言を追加した。</p>
            <p>明日はcandymakerにその関数の実装を追加するのをやろう。</p>
        </div>
        <hr />
        <div>
            <h2>2016/09/28 00:50</h2>
            <p>軽く熱が出ている。</p>
            <p>＊</p>
            <p>最近気温の変化が激しいので、それにやられたのかもしれない。</p>
            <p>作業しようにも頭が痛くてうまく思考がまとまらない。</p>
            <p>とりあえずいくつかファイルを追加したが。</p>
            <p>＊</p>
            <p>モジュール初期化時に渡すパッケージ情報に関する型を追加して、関数も追加しようと思ったけど、手順違うかも。</p>
            <p>パッケージ情報に含む情報として、パッケージディレクトリのパスがあるが、これもただの文字列とかでなく型を作る予定。</p>
            <p>なので、そっちの方を先にやるべきだろうな。</p>
        </div>
        <hr />
        <div>
            <h2>2016/09/24 01:25</h2>
            <p>やる気が出ない。</p>
            <p>＊</p>
            <p>とりあえず、関数の仕様だけまとめるプロジェクトとしてfgを作った。</p>
            <p>過去に作ったプロジェクトと同じ名前。</p>
            <p>ここに最初に追加するものは、やはりcandymaker内で使用する関数や構造体の宣言だろうな。</p>
            <p>sucroseのものについても宣言を追加するけど、量が多いし今やったら絶対だれる。</p>
            <p>そういうのは後回し。</p>
        </div>
        <hr />
        <div>
            <h2>2016/09/22 00:40</h2>
            <p>cmmainの記述を整えて、candymakerも試しにライブラリ化して動作するところまで確認。</p>
            <p>＊</p>
            <p>関数の仕様だけまとめたプロジェクトも必要な気がしてきている。</p>
            <p>今のままでは、モジュール初期化時にファイル読み込みをするためだけに、candymakerのヘッダファイルを読み込む必要があるし。</p>
        </div>
        <hr />
        <div>
            <h2>2016/09/21 03:25</h2>
            <p>コアライブラリのダミーを作って、それをロードし、関数が呼び出されるところまで確認。</p>
            <p>＊</p>
            <p>cmmainはとりあえずこんなところだろうな。</p>
            <p>明日からcandymakerの方を修正していく。</p>
        </div>
        <hr />
        <div>
            <h2>2016/09/15 01:45</h2>
            <p>やる気絶不調。</p>
            <p>＊</p>
            <p>とりあえず、cmmainとかいうプロジェクトを作った。</p>
            <p>あともう少しでコアライブラリのロードまでできる。</p>
        </div>
        <hr />
        <div>
            <h2>2016/09/08 23:30</h2>
            <p>昨日の時点で実験は済んでいる。</p>
            <p>＊</p>
            <p>今日から作業に入ろうとしたのだけど、どのように構成するのが最適なのか、色々考えていた。</p>
            <p>まず、candymakerのほぼ全てをライブラリ化したものとそれを読み込むメインプログラムは、別のプロジェクトにするべきなのか？</p>
            <p>前者はモジュール側から参照されることはあるが、後者にはそれがないため、分けるべきかもしれない。</p>
            <p>しかし、その場合双方の名前はどうしよう。</p>
            <p>そもそもcandymakerとかいう名前、あんまかっこよくないし別のに変えたい気もする。</p>
            <p>名前空間がcandymakerだとなかなか長いので、もうちょい短めので。</p>
            <p>＊</p>
            <p>少し考えたが、プロジェクトの分割はやろう。</p>
            <p>メインプログラムの方は、一度作ったら多分ほぼ修正しない感じになりそう。</p>
            <p>コアライブラリのロードと、メイン関数の呼び出しくらいしかやることないし。</p>
        </div>
        <hr />
        <div>
            <h2>2016/09/07 00:10</h2>
            <p>確実にやる気落ちてる。</p>
            <p>＊</p>
            <p>方針変更。昨日のはなし。</p>
            <p>candymakerのほぼ全てを共有ライブラリ化する。</p>
            <p>これにより、モジュールからcandymakerの関数を参照可能にする。</p>
            <p>＊</p>
            <p>こっちの方が、昨日の案よりずっと現実的だと思う。</p>
            <p>そういった構成が可能なのか、簡単なコードで実験しなければと思うのだが、まだやってない。</p>
            <p>明日にはやってしまう予定。</p>
        </div>
        <hr />
        <div>
            <h2>2016/09/05 17:00</h2>
            <p>思ったよりも大規模な変更が必要になりそう。</p>
            <p>＊</p>
            <p>モジュールロード時の初期化関数に渡すデータは、仮にパッケージコンテキストと呼称することにした。</p>
            <p>このパッケージコンテキストは、ゲームの初期化関数にも引数として渡す。</p>
            <p>そうしないと、ゲーム内からパッケージのファイルにアクセスする場合に、必ずモジュール初期化関数を用意しなければならず、面倒だ。</p>
            <p>＊</p>
            <p>と、そこまではいい。</p>
            <p>問題は、モジュールのロードを行うcandymakerで生成したデータの内部に、モジュール側からどうやってアクセスするのか、ということだ。</p>
            <p>パッケージコンテキストの仕様は後々変更することはもちろんあると思うので、メンバを直接アクセスするなんてのは現実的ではない。</p>
            <p>ではパッケージコンテキストに関するモジュールを作って、ってやるとそのモジュール初期化時にパッケージコンテキストを渡せないではないか。</p>
            <p>＊</p>
            <p>現在の構成として、candymakerは完全に独立している。</p>
            <p>ゲームやベースシステムは、candymakerが一方的にモジュールをロードし、関数を呼び出すだけであって、その呼び出された関数の中からcandymaker内のデータにアクセスするような仕組みを作っていない。</p>
            <p>なので、その仕組みを作る必要が出てきたな、という感じ。</p>
            <p>具体的には、candymaker内のデータにアクセスするための、ラッパーのようなモジュールを作ろうと思う。</p>
            <p>モジュールロード後に、ラッパーモジュール内に用意した初期化関数を呼び出し、candymaker内の関数にアクセスできるようにする。</p>
            <p>パッケージコンテキスト内のデータを参照するには、ラッパーモジュールの関数を呼び出し、その関数を経由してcandymaker内の関数にアクセス、データを参照する、といった流れ。</p>
            <p>＊</p>
            <p>さて、そんなに都合よくできるかどうか。</p>
        </div>
        <hr />
        <div>
            <h2>2016/09/03 00:45</h2>
            <p>パッケージ内のファイル読み込み方法考え中。</p>
            <p>＊</p>
            <p>ゲーム内で使うテクスチャであれば、BaseContextにパッケージのパスを追加しておけばいいかー、と思ったけど違う気がする。</p>
            <p>BaseContextは、読み込んだモジュールすべての関数が参照する可能性のあるものだ。</p>
            <p>パッケージが違っていても関係ない。</p>
            <p>そういう性質のものに対して、1パッケージのみに関係する情報を乗っける、というのは違和感がある。</p>
            <p>＊</p>
            <p>モジュールロード時のデータを追加するべきかもしれない。</p>
            <p>現状のモジュールロードは、初期化関数が指定されていれば、引数のないその関数を呼び出すだけ。</p>
            <p>これに対し、引数を付け加えるべきかも。</p>
            <p>その引数のデータとして、そのモジュールが属するパッケージのパスなどを乗っける。</p>
            <p>＊</p>
            <p>しかしその場合、そのデータはどうやって管理しよう。</p>
            <p>実体はモジュールをロードしたところに置いておいて、初期化関数でポインタをモジュールのグローバルに配置する、というのがセオリーだろうか。</p>
            <p>できるだけグローバルとか使いたくないんだけど、さすがにこれは仕方ない気がするなぁ。</p>
        </div>
        <hr />
        <div>
            <h2>2016/09/01 17:00</h2>
            <p>まずファイル入出力に対応することに決めた。</p>
            <p>＊</p>
            <p>セーブをできるようにするにも、テクスチャや音声を扱うにも、まずはファイルに対する入出力ができないことには始まらない。</p>
            <p>差し当たっては、どれを実現する目的で作ろうかな。</p>
            <p>音声はまだ無理だし、テクスチャかセーブデータか。</p>
            <p>現状、この前作ったへびゲームは、スコア表示が存在しない。</p>
            <p>描画が面倒だったので。</p>
            <p>比較的簡単にスコア表示を行なうために、テクスチャ読み込みに対応してもいいかもしれない。</p>
            <p>そしてハイスコアを保存するために、セーブデータに対応する、という形はどうだろう。</p>
            <p>＊</p>
            <p>まだセーブデータという概念自体作ってないわけだから、先にテクスチャに対応するのは道理かも。</p>
            <p>テクスチャはパッケージのディレクトリに置けばいいだけだし。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/31 00:35</h2>
            <p>ウィンドウクローズイベントハンドラ追加。</p>
            <p>＊</p>
            <p>ベースシステムに、メインウィンドウのクローズイベントの対応を追加し、メインウィンドウが閉じたら正常終了するようにした。</p>
            <p>付随して、起動中はwhile(1)によってCPU1コアの使用率が100%になってしまっていた状態も解消。</p>
            <p>きりがいいと思ったので、sucroseをv0.9.0とした。</p>
            <p>＊</p>
            <p>次はどこを進めようか。</p>
            <p>一度よく考えるべきだろうな。</p>
            <p>過去の記事を見直せば、ある程度計画のようなものも出てくるかもしれない。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/29 20:10</h2>
            <p>メインウィンドウやゲームパッドマネージャに対するイベントハンドラの設定方法を変更。</p>
            <p>＊</p>
            <p>これにより、とりあえずゲーム側のソースコードが50行少なくなった。</p>
            <p>まぁそれはおまけ程度であり、割とどうでもいい。</p>
            <p>＊</p>
            <p>メインウィンドウやゲームパッドマネージャに対し、特定のイベントハンドラの設定を阻止できるようにインターフェースを変更した。</p>
            <p>メインウィンドウのウィンドウを閉じる時のイベントハンドラなんかは、ゲーム側から触らせたくなかったので、想定通りに変更できて満足。</p>
            <p>＊</p>
            <p>とりあえず、ウィンドウを閉じるイベントに対応しようと思う。</p>
            <p>今のベースシステムは、ウィンドウを閉じた時の不正終了で落ちているので気に食わない。</p>
            <p>＊</p>
            <p>ちなみに、体の描画に付け足したい要素が、とかいうのは土曜に片付けておいた。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/27 03:10</h2>
            <p>体の描画と、衝突による進行停止、つまりゲームオーバーも作った。</p>
            <p>＊</p>
            <p>これで、とりあえずゲームとしての体裁は整ったはず。</p>
            <p>もうちょい、体の描画に付け足したい要素があるので、来週の頭にそれをやって、0.1.0としよう。</p>
            <p>＊</p>
            <p>実際にゲームを作ってみて、ベースシステム側の改善点も少し見えた。</p>
            <p>来週はその辺から手を付けていくか。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/26 02:00</h2>
            <p>へびが動くようになった。</p>
            <p>＊</p>
            <p>餌の配置と、餌を食って体が伸びるようになった。</p>
            <p>しかし、体の描画処理を行なっていないため、見た目にはほぼ反映されていない。</p>
            <p>そのせいもあって、食った後の挙動がこれで合ってるのか、ちょっと判断がつかない。</p>
            <p>＊</p>
            <p>でも体を描画するためのデータはできているわけだし、明日体の描画処理を作る。</p>
            <p>そして衝突判定も作り、明日中の完成を目指す。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/25 00:10</h2>
            <p>本格的に描画を開始した。</p>
            <p>＊</p>
            <p>とりあえず、へびと外壁を描画。<a href="images/201608250010_00.png" target="_blank">こんな感じ。</a></p>
            <p>テクスチャとかまだまともに使えるようにしてないし、というよりも面倒なので見た目がしょぼいのは仕方がない。</p>
            <p>緑色のがへび。</p>
            <p>左側の、ぱかっとなってる方が口。</p>
            <p>コントローラによる向き変更にも対応している。<a href="images/201608250010_01.png" target="_blank">こんな感じ。</a></p>
            <p>体の描画はまだなので、頭としっぽが千切れそうになってるのは仕方がない。</p>
            <p>＊</p>
            <p>それに、向き変更が可能なだけであってまだ動くこともできない。</p>
            <p>その処理はなんとか今日作ったので、明日動かしてみる予定。</p>
            <p>それがうまくいけば餌を食べて体を伸ばす処理と、餌の配置処理。</p>
            <p>最終的に外壁や体との衝突判定処理も追加する。</p>
            <p>そして、衝突でゲーム停止、つまりゲームオーバーになるようにすれば一段落といったところかな。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/24 00:40</h2>
            <p>ソースを機能ごとに分割した。</p>
            <p>＊</p>
            <p>へびの描画を先にやってから、それに対してコントローラ動かした時の挙動を付けていく形にしようとしたが、うまく行かず。</p>
            <p>どうも作る順を間違えたらしい。</p>
            <p>コントローラでどのようにデータを変動させるか決めないと、そもそもどのようなデータを用意するべきか、がはっきりしない。</p>
            <p>なのでコントローラの挙動の方が先だな。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/23 01:00</h2>
            <p>背景黒く塗ることはできた。</p>
            <p>＊</p>
            <p>別にそれ自体、全然難しくないんだけど。</p>
            <p>すぐにソースが肥大化しそうで、どうやって機能分割したものかと考えていた。</p>
            <p>しかしそれも大体見えてきたので、明日にはもっと機能分割し、手を付けやすくする予定。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/20 01:30</h2>
            <p>ゲームパッドイベントハンドラの設定処理も完了。</p>
            <p>＊</p>
            <p>次からイベントハンドラの中身を詰めていくわけだけど。</p>
            <p>基本的には、ゲームパッドの操作→描画処理、という流れになると思うけど、なにもしてなくてもへびを動かす処理も必要になる。</p>
            <p>なので、ゲームパッドとは別に待機処理を動かしておいて、一定時間ごとにへびを動かす→描画、という流れも必要になるだろう。</p>
            <p>ウィンドウ描画イベントについては、単に描画処理流すだけで問題ないはず。</p>
            <p>＊</p>
            <p>ゲーム自体の処理はそんな感じだけど、ゲームオーバーになったら処理の流れを変える必要があるだろうな。</p>
            <p>ゲーム開始前の画面は、とりあえずは省いてしまってもいいだろう。</p>
            <p>起動と同時に開始、ゲームオーバーでもう動かなくなる、みたいな感じ。</p>
            <p>あとから、タイトル画面とゲームオーバー時になんか押すとタイトルに戻る、といった処理を追加するか。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/19 00:35</h2>
            <p>やる気びみょうだけど、感覚はだいぶ戻ってきた。</p>
            <p>＊</p>
            <p>とりあえずウィンドウイベントハンドラ設定処理は書いた。</p>
            <p>描画イベントの処理は空っぽだが。</p>
            <p>ちゃっちゃとゲームパッドイベントの方も設定処理書いて、中身を詰めていきたい。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/17 15:50</h2>
            <p>そろそろcandymakerの開発に戻る。</p>
            <p>＊</p>
            <p>簡単なゲームを作ってみようと思う。</p>
            <p>現状、フォントファイルを読んで文字を出すとかできないし、かといって自分で線引いて文字書くのもめんどくさい。</p>
            <p>というわけで、そういった表示が必要なさそうなゲームを作る。</p>
            <p>＊</p>
            <p>思いついたのは、なんていうの？</p>
            <p>へびが餌食ってどんどん伸びていくあれ。</p>
            <p>あれなら得点などの表示がなくても問題ないし。</p>
            <p>あれ作る。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/16 00:45</h2>
            <p>というわけで中継ツールを作った。</p>
            <p>＊</p>
            <p>xlinkkaiだとゲームスピードが落ちてしまうゲームも、ローカル内での中継ではさすがにスピードが落ちなかった。</p>
            <p>ネット越しの中継をした場合どうなるかは、まだ確認していない。</p>
            <p>＊</p>
            <p>xlinkkaiでどうしようもないくらい遅延していたゲームは、ローカルでの中継の時点で既にどうしようもないくらい遅延してた。</p>
            <p>もしやデータ到着順が入れ替わったりとかいう、UDPで起きるらしい現象が頻発してこんなことになっているのでは、と思いTCP版を作ってみたが変わらず。</p>
            <p>他のゲームの場合、ローカル内で中継する限りではUDP版とTCP版、どちらでもこれといった違いは見られなかった。</p>
            <p>なんなんだろう。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/15 13:00</h2>
            <p>pspautoconnector2は想定通りに動いているようだ。</p>
            <p>＊</p>
            <p>しかし、一部のゲームでゲーム性が変わってしまう程度にゲームスピードが遅くなってしまうのが気に食わない。</p>
            <p>これはpspautoconnector2ではなくxlinkkaiの問題だと思うけど。</p>
            <p>というわけで、xlinkkaiの代わりのツールを簡単に作ってみようかと。</p>
            <p>＊</p>
            <p>昨日試した限りでは、パソコンに無線LANアダプタを2つ差して、2台のPSPとそれぞれ通信し、単純にデータを中継すれば、チャンネルが違っていても通信が可能ということが確認できた。</p>
            <p>その中継を行なうために作ったプログラムに多少手を加えれば、遠隔地とP2P通信するためのツールにできるはずだ。</p>
            <p>＊</p>
            <p>とはいえ、xlinkkaiもおそらくP2P通信なんだよなぁ。</p>
            <p>ポート開放が必要なのも、きっとそのためだし。</p>
            <p>しかし、その通信部分の処理が甘くて処理遅延の原因になっているとすれば、改善の余地があるかもしれない。</p>
            <p>まぁ、やるだけやってみよう。</p>
            <p>今日1日で完成させられると思うし。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/10 03:00</h2>
            <p>無理なダイエットはよくないと思った。</p>
            <p>＊</p>
            <p>pspautoconnector2がきちんと動作していない原因が判明。</p>
            <p>無理に環境全体のサイズを小さくしようとした環境を使っていたことが原因のようだった。</p>
            <p>ようだった、というのはそうでない環境を使ったらきちんと動作するようになった、というだけなので、他の原因ということも考えられる。</p>
            <p>しかし、その2つの環境の相違点は、より多くのプログラムをbusyboxへのシンボリックリンクに差し替えていることが大きいので、やはりその辺が原因かな、と。</p>
            <p>他にも、xlinkkaiのエンジンの停止でこけるなどしていたので、無理に小さくしようとした環境は今後使わないようにする。</p>
            <p>必要がなくなったらすぐ消そう。</p>
            <p>＊</p>
            <p>起きたら、新たに作ったmicroSDの動作確認をする予定。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/09 03:45</h2>
            <p>過去にやったことをすっかり忘れていた。</p>
            <p>＊</p>
            <p>カーネルモジュールのソースに修正を加えていた件について忘れていたこともあり、あまり進まなかった。</p>
            <p>とりあえずカーネルモジュールは使えるようになった、はず。</p>
            <p>＊</p>
            <p>しかし、pspautoconnector2がきちんと動作していない。</p>
            <p>いや、期待通りの動作はしていると思うのだが。</p>
            <p>SSIDとチャンネルはきちんと設定されているので、そこに至るまでにPSPのネットワークも検索しているはずなのだが、既存のネットワークに繋がず新しいネットワークを作っていて接続できていない。</p>
            <p>アドレスを指定する処理も必要なんだろうか。</p>
            <p>とりあえず明日追加してみるけど、それでうまくいくのかどうか。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/08 00:15</h2>
            <p>今日設定ファイルいじくったので1.0.0にした。</p>
            <p>＊</p>
            <p>pspautoconnector2はとりあえず一区切り。</p>
            <p>次は自動生成したgentooの小型化するスクリプトを作るつもり。</p>
            <p>だけど、とりあえず前に作ったやつを差し替えて試してみようかな。</p>
            <p>正直、そんなに簡単にできるような作業でもないと思うのだ。</p>
            <p>なかなかに期限も迫っているし。</p>
            <p>＊</p>
            <p>pspautoconnectorについては、また新たな問題が浮上した。</p>
            <p>SSIDが変動する一部のゲームで、接続がうまくいかない。</p>
            <p>PSPのSSIDを変動させる前に、対象のSSIDを検索する処理を行なっているらしく、PSPが変動後のSSIDに変わらないのだ。</p>
            <p>簡単に言えばpspautoconnectorと同じ動きをしている。</p>
            <p>双方、変動後のSSIDを探そうとするけれど見つからないので、接続がうまくいかない。</p>
            <p>解決するには、パソコンの無線LANアダプタのSSIDを変更する必要がある。</p>
            <p>＊</p>
            <p>一番簡単な手段としては、手動変更だろう。</p>
            <p>しかし、それを自動化したくてpspautoconnectorを作ったわけで、それをしては意味がない気もする。</p>
            <p>とはいえ、それすらも自動化したい、となると、pspautoconnector同士で通信を行なう必要が出てくる。</p>
            <p>親のPSPについては、子のPSPが接続するために自動でSSIDが変動する。</p>
            <p>それを検知したpspautoconnectorは、他のpspautoconnectorに通知し、SSIDを変更させる、といった具合だ。</p>
            <p>でもそれをするとなると、中継するサーバーを何かで作るとかか、P2P通信するとかが必要になって、かなり大掛かりになる。</p>
            <p>難しいところだ。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/06 03:45</h2>
            <p>大きな勘違いをやらかしていたため修正。</p>
            <p>＊</p>
            <p>疲れた。</p>
            <p>設定ファイルの要素をいじくったら1.0.0にする予定。</p>
            <p>休日はできるだけ作業しないようにしているが、明日にやってしまおうかな。</p>
            <p>＊</p>
            <p>しかし、めちゃくちゃな作り方したのでソースがとても汚ない。</p>
            <p>次からは絶対こんなことしないよ。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/05 03:40</h2>
            <p>設定ファイル読み込み処理を作って、0.1.0とした。</p>
            <p>＊</p>
            <p>明日は特定のゲーム向けの、より迅速なSSID変更処理を追加する予定。</p>
            <p>明日中に完成までできればいいのだが。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/04 00:10</h2>
            <p>昨日の時点で、初回の接続がうまくいかない問題については解決済み。</p>
            <p>＊</p>
            <p>接続前に、接続用アダプタで対象のネットワークが見つかるまでネットワーク検索をかけ、見つかり次第接続する形で対応。</p>
            <p>前バージョンよりも短い時間で接続できるようになった気がする。</p>
            <p>比較するために前バージョンでも試そうとしたんだけど、うまく動いてなかった。</p>
            <p>設定値がおかしいのかもしれないが。</p>
            <p>＊</p>
            <p>今日から、設定ファイル読み込み処理を作っている。</p>
            <p>前バージョンでは、設定値をコマンドライン引数で直接設定していた。</p>
            <p>しかし今回はコマンドライン引数で設定ファイルのパスを指定し、それを読み込む形にする。</p>
            <p>後々、多少複雑な設定値を扱えるようにするためにはその方がいいと判断した。</p>
            <p>で、設定ファイルの記述形式はcandymakerのものと同じ物、つまり簡易的なJSONにする。</p>
            <p>これであればマップやリストを利用できるし。</p>
            <p>何より、すでに作ってあるので手間が省ける。</p>
            <p>というわけで、candymakerから必要なソースを持ってくるところまではやった。</p>
            <p>明日中に、設定値をハードコーディングしている部分を全て差し替えたいところ。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/02 18:40</h2>
            <p>前回接続時から一定時間経過しないと再接続できない仕組みは追加した。</p>
            <p>＊</p>
            <p>で、今は初回の接続がうまくいかない原因を探っていて、大体把握できた。</p>
            <p>大まかに言えば、アダプタを2つにしたのが原因だった。</p>
            <p>接続用のアダプタが、接続先のネットワークの存在を把握できていないのがいけない。</p>
            <p>把握するための方法は、ネットワークの検索。</p>
            <p>検索用と接続用に分け、接続用のアダプタではネットワークの検索をしていなかったからいけなかったのだ。</p>
            <p>接続前にネットワーク検索をかけて、ネットワークの存在を把握してから接続、という形にすれば多分いける。</p>
            <p>となると、処理の流れ自体に手を加えるべきかもしれない。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/02 00:50</h2>
            <p>やる気がびみょう。</p>
            <p>＊</p>
            <p>ネットワーク検索時の重複を消す処理は追加した。</p>
            <p>他にも、PSPの検索を開始した後にSSIDを変更した場合、接続失敗にせず再度PSPの検索をする処理も追加した。</p>
            <p>現在のSSIDと同じSSIDに再度接続しようとする問題については、ちょっと考え中。</p>
            <p>前回接続時の時間を記録しておいて、一定時間経たないと再接続できない仕組みを追加しようかと考えている。</p>
            <p>その仕組みを追加したとしても、ネットワークが変わらない場合再接続を禁止する処理は必要だと思うけど。</p>
            <p>＊</p>
            <p>もしくは、接続できなかった場合はSSIDを空にしておくことで対応するべきだろうか。</p>
            <p>前バージョンはアダプタが1つだから問題なかったけど、今回は2つなので、SSIDをそのままにしておくと検索に引っかかってしまう。</p>
            <p>ネットワークが消滅してから10秒程度経たないと検索から消えてくれないので、今すぐ追加したところで効果は確認できないが。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/01 12:00</h2>
            <p>金曜の時点で、とりあえず動作する状態にはなった。</p>
            <p>＊</p>
            <p>まだまだ完成ではないが。</p>
            <p>コマンドライン引数か設定ファイルから設定するデータがハードコーディング状態だったりとか。</p>
            <p>現在のSSIDと同じSSIDに再度接続しようとしてしまうのもよくない。</p>
            <p>前バージョンならそれほど問題でもなかったかもしれないが、今回は違う。</p>
            <p>ネットワーク検索用アダプタで検索をかけた時に出てくるSSIDが増えてしまうのだ。</p>
            <p>全く同じSSID、チャンネルのネットワークが複数検出される。</p>
            <p>検出時に被りがある場合は無視する処理も追加する予定だが、ネットワークが変わらないのに接続しようとすることに意味はないので、こちらも処理を追加して抑制する。</p>
            <p>＊</p>
            <p>色々試していて気がついたのだが、同じメーカーのチップセットで同じカーネルモジュールを使っていても、チップセットが違うと細かい動きが違う気がする。</p>
            <p>xlinkkaiを使うためralinkのアダプタを使っているが、古いアダプタと新しいアダプタで違いが出ている。</p>
            <p>アドホック接続をするためにSSIDとチャンネルを設定すると、新しいアダプタの場合は既に存在するネットワークに接続しようとするので問題ない。</p>
            <p>古いアダプタの場合、既にネットワークが存在しても、とりあえず新しいネットワークを作る。</p>
            <p>それからちょっと経つと、既に存在するネットワークに接続する。</p>
            <p>いや、もしかしたら既に存在するネットワーク側がアダプタのネットワークに擦り合わせているのかもしれない。</p>
            <p>そこまでは確認していない。</p>
            <p>とにかく、そのような動作をしているため、古いアダプタだと素早いネットワーク接続に向いていないのでは、と思っている。</p>
            <p>SSID変動型のゲームでうまくいかない場合があるのもそのせいなのでは、と思っている。</p>
        </div>
        <hr />
        <div>
            <h2>2016/07/29 03:15</h2>
            <p>ネットワーク接続処理を作った。</p>
            <p>＊</p>
            <p>PSP検知処理はまだまだ。</p>
            <p>最終的な作りは見えた感じ。</p>
            <p>ネットワークへの接続とPSP検知処理を別々のスレッドでやるので、次に接続するネットワークの決定をどうするか、が問題だった。</p>
            <p>古いバージョンの処理は列挙、接続、検知を順々にやっていたので、列挙したネットワークに順番に接続するだけで済んでいた。</p>
            <p>しかし今回は別々のスレッドなので、ループで順々にネットワークに接続しては検知、という手段は使えない。</p>
            <p>そこで、接続したネットワークの履歴を残す、という方法を考えた。</p>
            <p>一度ネットワークに接続したら、そのネットワークの情報を履歴リストにつっこんでいく。</p>
            <p>次にネットワークに接続する時には履歴リストを参照し、今まで接続したことがないネットワークに優先的に接続する。</p>
            <p>全て接続済みの場合は一番古いものを優先。</p>
            <p>一度接続したことがあるネットワークに接続した際には、そのネットワークの情報を一番上に持ってくる。</p>
            <p>この方法であれば、同じネットワークばかり接続しようとしてしまう、というようなことにはならない。</p>
            <p>＊</p>
            <p>実際には、今接続しているネットワークと同じゲームのネットワークが出現したら、すぐさまそのネットワークに切り替える、という機能も作る予定。</p>
            <p>SSIDが切り替わるタイプのゲームで、タイムアウトがかなり短いゲームへの対策だ。</p>
            <p>それでうまくいくのかどうかは分からないが。</p>
        </div>
        <hr />
        <div>
            <h2>2016/07/28 03:40</h2>
            <p>古い処理から引っ張ってきて、周囲のネットワークの列挙処理を作った。</p>
            <p>＊</p>
            <p>ネットワークの列挙とネットワークへの接続はそれぞれ別のアダプタでやることもあり、スレッドで処理している。</p>
            <p>色々試して気付いたことには、あまり短すぎる間隔で処理を呼び出しまくるとおかしくなる、という点だ。</p>
            <p>大雑把に試してみた感じだと、100ミリ秒間隔が限界点。</p>
            <p>それよりも短い、10ミリ秒間隔以下で呼び出すと、新たに出現したネットワークを検知できなかったり、消滅したはずのネットワークがいつまでも検知されたり。</p>
            <p>そもそも、前に作った時は検知開始してからデータが取れるまでに1秒程度かかってた気がするのだが。</p>
            <p>まぁいいか。</p>
            <p>＊</p>
            <p>次は検知したネットワークに接続する処理を作ろう。</p>
            <p>今回作った処理と同じく、スレッドで処理する。</p>
            <p>それが出来たら、その次はネットワーク内のPSP検知処理だな。</p>
        </div>
        <hr />
        <div>
            <h2>2016/07/27 00:40</h2>
            <p>windows10インストール完了。</p>
            <p>＊</p>
            <p>使う機会はずっと後になると思うが。</p>
            <p>＊</p>
            <p>pspautoconnector2の開発開始。</p>
            <p>基本的には既存のソースから引っ張ってくるので、そんなに時間かからないと思うのだけど。</p>
            <p>設定項目が多少増えるから、コマンドライン引数で与えるのではなく設定ファイルを作った方がいいかもしれない。</p>
            <p>でもそうなると面倒が増えるから、とりあえずはコマンドライン引数からにするか。</p>
            <p>設定ファイルにするかどうかは、メインの処理が出来上がってからでも遅くはない。</p>
        </div>
        <hr />
        <div>
            <h2>2016/07/26 00:40</h2>
            <p>アップグレードの期限が迫っているので、そろそろwindowsを10にしようかと思っている。</p>
            <p>＊</p>
            <p>で、今日ちゃっちゃとアップグレードしようとしたのだが、結果から言えばまだできていない。</p>
            <p>1つのパソコンに2環境作ってあるため、とりあえずインストールディスクを作ろうとしたのだが、まずそこがうまくいかない。</p>
            <p>ツールを使って落とそうとしたが、Cドライブに8GBの空きが必要などと言われた。</p>
            <p>Cドライブは基本的に、必要最低限の領域しか確保しないため、そんなに空きがないのだ。</p>
            <p>Dドライブなら余裕があるのに。</p>
            <p>クリーンインストールするのだし、と色々消してみたが7.8GB程度までしか空きができない。</p>
            <p>windowsアップデート関連のファイルをクリーンアップすれば空きが10GB程度になりそうだが、再起動しないと消せないようだった。</p>
            <p>で、再起動してみたらログイン画面から画面真っ黒。</p>
            <p>マウスポインタだけは見える状態。</p>
            <p>セーフモード起動もできない状態になってしまった。</p>
            <p>＊</p>
            <p>仕方ないのでgentooを起動して調べてみたら、公式サイトからディスクイメージをダウンロードできるとか。</p>
            <p>もっと早く言ってほしかった。</p>
            <p>＊</p>
            <p>そんな感じでまごまごしていたので、本日は全然進んでいない。</p>
            <p>実は昨日、騙し騙しカーネルインストールスクリプトを書いていたので、とりあえずそれを追加しておいた。</p>
            <p>この後rootfsインストールスクリプトも書いてしまうか。</p>
            <p>それができたら軽量化などと言っていたが、正直めんどくさいので、先にpspautoconnectorの新バージョンの方をやろうと思う。</p>
            <p>最悪、軽量化などできなくてもいいのだ。</p>
        </div>
        <hr />
        <div>
            <h2>2016/07/23 03:50</h2>
            <p>とりあえずrootfs生成まで完了。</p>
            <p>＊</p>
            <p>次はカーネルインストールだが、これも過去のスクリプトから持ってくればすぐできるはずだ。</p>
            <p>そこまでできたら、実際にrootfsとカーネルをSDカードにインストールし、動かしてみる。</p>
            <p>特に問題ないようなら、その次は軽量化か？</p>
            <p>必要ないパッケージのファイルの除去などを、スクリプトでまとめてできるようにする。</p>
        </div>
        <hr />
        <div>
            <h2>2016/07/21 17:10</h2>
            <p>昨日の時点で、必要なファイルのダウンロードとカーネルビルド処理まではできた。</p>
            <p>＊</p>
            <p>あとはrootfs生成について。</p>
            <p>そこまでは、過去に組んだスクリプトを参考にして進められる。</p>
            <p>＊</p>
            <p>過去のスクリプトでは、rootfs生成時にカーネルのインストールもやっていたけど、今回のは別にしようと思っている。</p>
            <p>カーネルは複数インストールすることもあるんだし、それをシェルスクリプトで対応させるのはなかなかめんどうだ。</p>
            <p>特に今回の場合はraspberrypiなので、1用と2用で別のカーネルを積む予定だ。</p>
            <p>場合によって1のみ、あるいは両方、あるいは1用のを複数、などというのを1つのスクリプトで全パターン網羅する、というのは困難を極める。</p>
            <p>それなら、1つのカーネルをインストールするスクリプトを作っておいて、それを自分で複数回動かした方が分かりやすそうだ。</p>
        </div>
        <hr />
        <div>
            <h2>2016/07/20 00:30</h2>
            <p>8月中旬頃までは別の作業することにした。</p>
            <p>＊</p>
            <p>raspberrypiで動作するgentooの自動生成関係をやる。</p>
            <p>それが済んだら、pspautoconnectorの新バージョンを作る。</p>
            <p>それをraspberrypiに乗っけて出来上がり。</p>
        </div>
        <hr />
        <div>
            <h2>2016/07/16 00:20</h2>
            <p>candymaker-0.12.0完成。</p>
            <p>＊</p>
            <p>前に作ったpainttestとかgamepadtestで試したが、いい感じ。</p>
            <p>sucroseを別パッケージに分離したが、ちゃんと動作している。</p>
            <p>結構それっぽくなってきた感じがある。</p>
            <p>＊</p>
            <p>気になった点としては、設定ファイルの記述ミスの場所が分かりにくいというところか。</p>
            <p>エラーログの内容を変えることで対応できると思うけど。</p>
        </div>
        <hr />
        <div>
            <h2>2016/07/15 02:15</h2>
            <p>同パッケージ内の依存解決完成。</p>
            <p>＊</p>
            <p>古い処理も片付けた。</p>
            <p>これで他に何もなければ、明日バージョンを確定させよう。</p>
            <p>＊</p>
            <p>次はどうしよう。</p>
            <p>とりあえず、今回の追加で複数のパッケージを扱えるようになったわけだな。</p>
            <p>candymakerに何か追加するとしたら、設定ファイルマネージャやモジュールマネージャとかその辺だろうな。</p>
            <p>しかし、それらは現状必須ってわけでもないし。</p>
            <p>いよいよ簡単なゲームでも作ってみるか？</p>
        </div>
        <hr />
        <div>
            <h2>2016/07/14 02:30</h2>
            <p>同パッケージ内の依存解決の目処は付いた。</p>
            <p>＊</p>
            <p>明日完成させる。</p>
            <p>そこまでできたら、古い方の構成は削除するとしよう。</p>
            <p>それでとりあえずバージョンを確定させるか。</p>
        </div>
        <hr />
        <div>
            <h2>2016/07/13 03:00</h2>
            <p>基礎はできたかも。</p>
            <p>＊</p>
            <p>細部はまだできていないが、インターフェース情報と依存情報、そして有効モジュールリストを使い、適切なモジュールを検索する処理を作った。</p>
            <p>山場は越えたのでは、と思うけど、ちょっと処理がぐちゃぐちゃな気がするんだよなぁ。</p>
            <p>強引に解決した箇所もあるし。</p>
            <p>しかし、その箇所は小手先の修正では解決できない気がする。</p>
            <p>きちんと書くには、新たな仕組みを追加するべきだろう。</p>
            <p>＊</p>
            <p>まぁ、その辺りはやはり後回しで。</p>
        </div>
        <hr />
        <div>
            <h2>2016/07/12 03:00</h2>
            <p>やる気はいまいちだが順調だと思いたい。</p>
            <p>＊</p>
            <p>先週の時点では、またしてもうっかり忘れていた部分の機能追加のみだった。</p>
            <p>やはり先週末で完成は無理だった。</p>
            <p>現時点で、完成までの目処は立った感じがある。</p>
            <p>うまくいけば明日には完成するのでは、と思っている。</p>
            <p>＊</p>
            <p>しかし、インターフェース情報と依存情報、どちらもパッケージ情報に固定データとして書かれてるのはどうなんだろう。</p>
            <p>ちょっと融通が効きにくそう。</p>
            <p>すぐに追加する必要はないと思うけど、パッケージ設定によって調整できるようにするべきか。</p>
            <p>インターフェース情報を追加、あるいは変更をできるようにしたりとか。</p>
        </div>
        <hr />
        <div>
            <h2>2016/07/08 00:15</h2>
            <p>うっかり忘れていた。</p>
            <p>＊</p>
            <p>パッケージ情報ファイルの依存モジュール情報の記述方法を、他パッケージへの依存に対応したものに変更するのを忘れていた。</p>
            <p>なので、今日はとりあえずそこを作った。</p>
            <p>ちなみに、現時点では古いものもまだ消していない。</p>
            <p>現状ではそれで動いているわけだし、消したら消したでめんどうなので。</p>
            <p>＊</p>
            <p>やる気が残念なことになっていたので、そこまでしかできなかった。</p>
            <p>明日は金曜日だし、明日で完成させたいところではある。</p>
            <p>しかし、大きく違う処理を新規に作ることになるわけだし、そう簡単にいくかどうか。</p>
        </div>
        <hr />
        <div>
            <h2>2016/07/07 00:20</h2>
            <p>パッケージ情報ファイル読み込み処理に、インターフェース情報についての処理を追加した。</p>
            <p>＊</p>
            <p>これでとりあえず下準備はできた感じか。</p>
            <p>これらの情報を元に、他パッケージへのモジュール依存の解決を可能にする。</p>
        </div>
        <hr />
        <div>
            <h2>2016/07/06 00:20</h2>
            <p>パッケージ設定ファイル解析処理を作った。</p>
            <p>＊</p>
            <p>インポート機能は未対応。</p>
            <p>そのうちやる。</p>
            <p>忘れないように、課題管理に追加しておいた。</p>
            <p>＊</p>
            <p>次はパッケージ情報ファイルへの記述追加対応。</p>
            <p>インターフェース情報の読み込みに対応する。</p>
        </div>
        <hr />
        <div>
            <h2>2016/07/05 15:35</h2>
            <p>昨日は既存処理を整えていた。</p>
            <p>＊</p>
            <p>で、今日からパッケージ設定ファイルに入ろうとしたのだが、昨日書いたのは多分間違ってる。</p>
            <p>時間が経ちすぎたため、当初の構成を忘れてしまっていたようだ。</p>
            <p>＊</p>
            <p>パッケージ設定ファイルで依存モジュールのマッピングはしない。</p>
            <p>依存モジュールの解決は、パッケージ情報ファイルのモジュール情報に記載する実装済みインターフェース情報と、パッケージ設定ファイルのモジュール使用許可リストで行なう。</p>
            <p>他パッケージへの依存モジュールの指定はインターフェース名で行なう。</p>
            <p>モジュール使用許可リストから、そのインターフェースが実装されているモジュールを探し出す形。</p>
            <p>＊</p>
            <p>そんなわけで、パッケージ情報ファイルにも手を加える必要がある。</p>
            <p>どこから手を付けたものだろうか。</p>
            <p>パッケージ情報ファイルの依存モジュール情報かな、と思ったがこれは最後か？</p>
            <p>少なくともインターフェース情報がなければ動作しないし。</p>
            <p>インターフェース情報より先に、パッケージ設定ファイルを作るべきか？</p>
            <p>その2つは直接的な関わりはないから、どっちから手を付けても大丈夫かな。</p>
            <p>＊</p>
            <p>インターフェース情報とパッケージ設定ファイルを作って、それを元に依存モジュール情報の内容を変更、最終的にモジュールロード処理らへんを変更する感じか。</p>
            <p>しかし、同パッケージについても依存モジュールの指定をインターフェース名でやるべきかと思ったが、正直二度手間な気がする。</p>
            <p>インターフェース名でやることによるメリットもあるため可能にはしたいが、モジュール名の直接指定でもできるようにしたい。</p>
        </div>
        <hr />
        <div>
            <h2>2016/07/04 21:15</h2>
            <p>パッケージ設定ファイルを先に作るべきでは、という気がしてきた。</p>
            <p>＊</p>
            <p>今のところの問題は、他のパッケージのモジュールへの依存モジュール指定ができないという点だ。</p>
            <p>これを、依存パッケージを直接指定して解決する、というのは分かりやすいが、最終的な構成とは割と異なる。</p>
            <p>そこから最終的な形に持っていこうとすると、設定ファイルの記述から変えていかなければならない気がする。</p>
            <p>それなら、そこはまだ現状のままにしておいて、パッケージ設定ファイルを追加した後に対応した方が楽なのでは、という気がしている。</p>
            <p>＊</p>
            <p>パッケージ設定ファイルには何を書くんだったか。</p>
            <p>とりあえずはモジュールの使用許可リストと、依存モジュールのマッピングか？</p>
            <p>他のパッケージ設定ファイルを参照したりするから、それも書くか。</p>
            <p>後々、パッケージとセーブデータディレクトリの関連付けも書く。</p>
            <p>＊</p>
            <p>この中の、最低限必要なものはどれだろうか。</p>
            <p>モジュール使用許可リストは後回しでいいだろう。</p>
            <p>他の設定ファイルの参照、つまりインポートも後でいい。</p>
            <p>そうなると、依存モジュールマッピングだけか。</p>
            <p>依存モジュールマッピングの後に、インポートも対応しよう。</p>
            <p>＊</p>
            <p>依存モジュールマッピングの記述方法はどうしよう。</p>
            <p>細かい指定方法と、大まかな指定方法、少なくともその2種類は用意したい。</p>
            <p>具体的には、細かい指定方法というのはモジュールレベルのマッピング。</p>
            <p>多まかな指定方法というのはパッケージレベルのマッピングだ。</p>
            <p>その中間もあれば、より便利だろうな。</p>
        </div>
        <hr />
        <div>
            <h2>2016/07/01 00:00</h2>
            <p>やる気減退がかなりやばい。</p>
            <p>＊</p>
            <p>しかし、とりあえず0.11.0確定まではやった。</p>
            <p>次は他のパッケージにあるモジュールに対し、依存モジュール指定をできるようにする。</p>
            <p>そこまでできれば、とりあえずcandymakerは一段落だろう。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/28 20:30</h2>
            <p>昨日はうっかり書き忘れた。</p>
            <p>＊</p>
            <p>wafのタスク生成がよく分からんので、昨日1日では完了できなかった。</p>
            <p>なんとなく分かってきた上で、多分明日までかかりそうだな、といった感じ。</p>
            <p>現在のビルドルールが、C++のソースファイルをコンパイルする、という作業を前提に書かれているため、融通が効かない。</p>
            <p>そこから修正していく必要がある。</p>
            <p>＊</p>
            <p>しかしモチベーションが上がらない。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/25 00:30</h2>
            <p>モジュール参照を作った。</p>
            <p>＊</p>
            <p>それをパッケージ情報ファイルで使うようにした。</p>
            <p>結果、パッケージ情報ファイル内のモジュールのパス指定が、パッケージ内の相対パスになった。</p>
            <p>これで、ベースシステムとゲームに必要なパッケージに加え、ショートカットファイルを1つのディレクトリにまとめることで、candymakerにショートカットファイルを読み込ませればゲームが動作するようになった。</p>
            <p>＊</p>
            <p>どうしよう、きりがいいしここで0.11.0としてしまうべきか。</p>
            <p>しかしながら、開発上の問題点が新たに浮上している。</p>
            <p>自動テストで使用するパッケージ情報ファイルの位置と、モジュールの位置が噛み合わないため、自動テストが失敗してしまうのだ。</p>
            <p>一応、ビルド後に自分でモジュールをコピーして、テストが通ることは確認したものの、こんなこと毎回やりたくない。</p>
            <p>毎回やってたら、いずれコピーし忘れとかで問題が出てくるだろうし。</p>
            <p>何よりめんどくさい。</p>
            <p>＊</p>
            <p>wscriptに手を加えて、その辺を対応してから0.11.0とすることにしよう。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/23 22:40</h2>
            <p>パッケージ参照を作った。</p>
            <p>＊</p>
            <p>それをショートカットファイルで使うようにした。</p>
            <p>結果、ショートカットファイルからのベースシステム、ゲームのパッケージ指定が、ショートカットファイルからの相対パスになった。</p>
            <p>今まではcandymakerからの相対パスで、実用度は皆無だったため、これは大きな進歩だ。</p>
            <p>現状の構成からすると、ショートカットファイルの内容は完成したと言っていいはずだ。</p>
            <p>＊</p>
            <p>しかしながら、パッケージの参照についてのみ対応したのであって、それ以外は未対応だ。</p>
            <p>例えば、パッケージ情報ファイルのモジュール指定なんかは、まだcandymakerからの相対パスで指定しなければならない。</p>
            <p>できるだけ早く対応してしまいたいが、パッケージ参照ができたということはモジュールの依存関係にそれを使用できるということだ。</p>
            <p>どちらを先にやるべきか、悩ましい。</p>
            <p>＊</p>
            <p>前者は型の変更であって、処理の流れ自体は変わらない。</p>
            <p>後者は型の追加に加え、それを利用した処理の追加、となるだろう。</p>
            <p>であれば、負荷の軽いモジュール指定の記述、つまりモジュール参照型の作成を先にやってしまうか。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/22 22:40</h2>
            <p>早まらなくてよかったかもしれない。</p>
            <p>＊</p>
            <p>煮詰まってはいるんだが、よく考えたら始まりから間違っていたのかも。</p>
            <p>ショートカットファイルのベースシステム参照について、パッケージパスの記述を色々考えていたんだが、想定では、</p>
            <p>{ "base" : "基点ディレクトリ名", "path" : [ "ディレクトリ名", "ディレクトリ名", "パッケージディレクトリ名" ] }</p>
            <p>といった感じの記述で、基点ディレクトリからの相対パスを表現しようとしていたんだけど。</p>
            <p>しかし、基点ディレクトリから見ても深い階層に配置することなんてないよなぁ、と考え、</p>
            <p>{ "base" : "基点ディレクトリ名", "path" : "パッケージディレクトリ名" }</p>
            <p>こうでいいよな、と思った。</p>
            <p>更に、これならいっそのこと、</p>
            <p>{ "at" : "基点ディレクトリ名", "name" : "パッケージディレクトリ名" }</p>
            <p>という感じにキーの名前を変えた方が分かりやすそうだな、と。</p>
            <p>で更に、この構成は既存のベースシステム参照やゲーム参照の構成と酷似している。</p>
            <p>ならば、これはパスというより参照情報という括りで扱った方がよさそうだな、と思った。</p>
            <p>＊</p>
            <p>ゲーム中で使用する素材なんかは、ある程度区分けされてるディレクトリ構成を扱えた方がいいだろうから、パスの概念が必要になると思う。</p>
            <p>しかしながら、現状ではそこまで自由度の高い要素は必要ないのでは、という話。</p>
            <p>少し希望が見えてきたかもしれない。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/21 22:00</h2>
            <p>確実にやる気減退している。</p>
            <p>＊</p>
            <p>今日も全然進んでない。</p>
            <p>このままではよくないので、candymakerのソースを眺めていたが、ちょっと整理した方がいい気がしてきた。</p>
            <p>なんとなくでファイルを置いてしまっている感じがある。</p>
            <p>特に設定ファイル周り。</p>
            <p>ショートカットファイルの要素、ベースシステム参照とゲーム参照の定義が、ベースシステム側やゲーム側に置かれてるのが違和感ある。</p>
            <p>設定ファイル側、あるいはどちらにも属しない独立したディレクトリに置くべきでは。</p>
            <p>生成時の引数として、設定ファイルの要素を渡すことになると思うから、設定ファイル側でいいとは思うけど。</p>
            <p>＊</p>
            <p>その辺から、ソースファイルの配置を整えるところから始めようかな。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/20 22:00</h2>
            <p>どこを進めるべきか考えていた。</p>
            <p>＊</p>
            <p>ひとまずsucroseはここで中断しておく。</p>
            <p>設定ファイルのパスの扱いをどうにかしようと思う。</p>
            <p>現状では、ベースシステムとゲーム、どちらも1つのパッケージで完結してなければならないという制限がある。</p>
            <p>パッケージをまたぐ依存関係を解決できないためだ。</p>
            <p>しかし、ゲームやベースシステムが汎用的なパッケージを利用する、などというのはよくあることだと思うので、できないと非常に困る。</p>
            <p>というわけで、依存モジュールの指定にパスを含めるようにする。</p>
            <p>付随して、今まで環境依存の文字列として扱ってきたパスを、共通的に扱うべく書式を定めようと思う。</p>
            <p>＊</p>
            <p>しかし、一気に全部をやろうとしてもうまくいかないと思うので、段階的に作っていく。</p>
            <p>まずやるべきは、型の関係だろうな。</p>
            <p>後に回せば回すほど、影響箇所が増えて面倒になるし。</p>
            <p>なので、まずはパスの型を作る。</p>
            <p>次に、設定ファイルのパスの箇所について対応し、これで一段落。</p>
            <p>その次はどうするか。</p>
            <p>最終的には、パッケージ設定ファイルを追加することになるけど、さすがにそこまで一気にはやりたくないなぁ。</p>
            <p>パッケージからパッケージに、直接依存する形を取るか？</p>
            <p>現状の依存モジュールの記述は、</p>
            <p>{ "deps" : [ "依存モジュール名" ] }</p>
            <p>といった具合だが、ひとまず</p>
            <p>{ "deps" : [ { "path" : パス型(依存モジュールのパス), "name" : "依存モジュール名" } ] }</p>
            <p>という形にするか。</p>
            <p>で、最終的には</p>
            <p>{ "deps" : [ { "package" : "依存パッケージ名", "name" : "依存モジュール名" } ] }</p>
            <p>という形にするかな。</p>
            <p>実際のモジュールとのマッチングは、パッケージ設定ファイルでやる感じ。</p>
            <p>＊</p>
            <p>今回の作業の最終的な落としどころも考えておこう。</p>
            <p>ショートカットファイルと必要なパッケージ群を1つのディレクトリにまとめた上で、</p>
            <p>candymaker ショートカットファイルパス</p>
            <p>と実行すれば、ディレクトリがどこに配置してあってもゲームが動かせる、といったところか。</p>
            <p>それを実現するには、前述した作業以外にも工程が必要になるが、やりたいことはつまりそういうことだろう。</p>
            <p>ショートカットファイルを基点とするファイル配置への対応。</p>
            <p>現時点では、candymakerを実行したティレクトリを基点とした配置にしか対応できてないし。</p>
            <p>むしろそんなものはなんの役にも立たないし。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/19 00:55</h2>
            <p>休みだし、久々にraspberrypi関係をやっている。</p>
            <p>＊</p>
            <p>raspberrypiで動作するgentooの自動生成をスクリプトにまとめようとしている。</p>
            <p>とりあえず、最新のstage3をダウンロードするスクリプトを書いた。</p>
            <p>昔書いたスクリプトでは、落とすstage3のパスを直書きしていたので、stage3が新しくなったら修正が必要だった。</p>
            <p>今回はサーバーにあるlatest-stage3なんちゃらファイルを参照して、現在の最新版をダウンロードするようにした。</p>
            <p>おまけで、stage3の最新版がダウンロード済みで、最新版が更新されていない場合にダウンロードをスキップする処理も追加した。</p>
            <p>＊</p>
            <p>休日に地道に進めて、起動後ディスクレス化する環境の自動生成までやりたいところ。</p>
            <p>スクリプトを使って試行錯誤し、最終的に生成できた、というのは昔やったんだけど。</p>
            <p>手動で手を加えたことも色々あって、今ではどうやったら確実に生成できるか覚えてないので。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/17 20:40</h2>
            <p>0.8.0確定。</p>
            <p>＊</p>
            <p>sucroseの.hと.cppの総行数が1万を越えた。</p>
            <p>試しに、バージョン毎のファイル数と行数を簡単なシェルスクリプトで出力したところ、</p>
            <table>
                <tr><th>バージョン</th><th>ファイル数</th><th>行数</th></tr>
                <tr><td>v0.1.0</td><td>16</td><td>495</td></tr>
                <tr><td>v0.2.0</td><td>39</td><td>2676</td></tr>
                <tr><td>v0.3.0</td><td>40</td><td>2810</td></tr>
                <tr><td>v0.3.1</td><td>40</td><td>2810</td></tr>
                <tr><td>v0.4.0</td><td>40</td><td>3032</td></tr>
                <tr><td>v0.5.0</td><td>40</td><td>3253</td></tr>
                <tr><td>v0.6.0</td><td>88</td><td>8790</td></tr>
                <tr><td>v0.6.1</td><td>91</td><td>8685</td></tr>
                <tr><td>v0.7.0</td><td>105</td><td>9449</td></tr>
                <tr><td>v0.8.0</td><td>129</td><td>13001</td></tr>
            </table>
            <p>こんな具合だった。</p>
            <p>0.3.0から0.5.0にかけてファイル数が一向に増えてないのは、ウィンドウ周りの機能追加をするたびにバージョンを上げてたんだろう、多分。</p>
            <p>過去の記述を見返したら、0.6.0でゲームパッドがどうたら言ってて、行数も一気に倍以上増えてるので多分そう。</p>
            <p>＊</p>
            <p>0.8.0で追加したスレッドプールとタスクにより、非同期処理が多少書きやすくなった、はず。</p>
            <p>しかし、タスクマネージャ書いてる時にデッドロック見つけちゃってやばかった。</p>
            <p>スレッド内でロックしてるmutexをロックしながらjoinしようとしてた。</p>
            <p>やはり非同期処理で厄介なのは、バグが再現しないことがある、という点か。</p>
            <p>今回の件も、たまたまjoinの方が早くロックを取得すると発生するのであって、毎回起きるわけじゃないし。</p>
            <p>また、停止してしまうだけで不正終了はしないから、どこで止まってるのかも特定が面倒だし。</p>
            <p>久々にgdbとか使って停止箇所特定などしようとしたが、久々すぎてうまく使えず。</p>
            <p>結局printfデバッグで発生箇所を特定し、解決した。</p>
            <p>まだどこかにバグが潜んでいそうで怖い。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/17 00:30</h2>
            <p>ゲームパッドの対応も完了。</p>
            <p>＊</p>
            <p>しかし、0.8.0はまだ確定しない予定。</p>
            <p>タスク管理の共通化のアイデアがひらめいたので。</p>
            <p>明日それを作ってから確定する予定。</p>
            <p>＊</p>
            <p>問題となっていたのは、タスクを括る必要がある、という点だった。</p>
            <p>どういうことかと言えば、</p>
            <p>{</p>
            <p>bool ended;</p>
            <p>タスク</p>
            <p>タスク</p>
            <p>タスク</p>
            <p>Ender ender;</p>
            <p>}</p>
            <p>これで伝わるかどうかは謎だが。</p>
            <p>排他制御関係やEnderの定義を省いて簡略化しているが、タスクを管理する構造体の定義だ。</p>
            <p>endedは終了フラグで、trueの場合タスクの実行できなくなる。</p>
            <p>それにより、各タスクが他のタスクに遷移することなく終了する。</p>
            <p>enderは、破棄のタイミングでendedをtrueに設定する。</p>
            <p>この構成によって、構造体を破棄すれば安全にタスク群を破棄できるのだ。</p>
            <p>不用意にタスクを破棄しようとすると、まだ動いているタスクから破棄済みのタスクに遷移しようとして死ぬ、などということが起きる可能性がある。</p>
            <p>＊</p>
            <p>これをどう共通化したものか、いい案が浮かばなかった。</p>
            <p>仮に、TaskManagerというものを用意して、そこにタスクを登録していく形、とすると各タスクのメンバ名が消えるようなものなので、タスクの遷移がやりにくくなりそうだ。</p>
            <p>自分で生成したものの破棄を他でやる、という構成も気に食わない。</p>
            <p>＊</p>
            <p>早い話が、endedに2回破棄処理をかける必要があるのが問題なのだ。</p>
            <p>1回目の破棄でendedをtrueに設定、2回目で物理的に破棄、つまりメモリ領域の解放。</p>
            <p>そこで思い付いたのが、</p>
            <p>{</p>
            <p>TaskManagerBegin taskManager;</p>
            <p>タスク</p>
            <p>タスク</p>
            <p>タスク</p>
            <p>TaskManagerEnd taskManagerEnd;</p>
            <p>}</p>
            <p>このような構成だ。</p>
            <p>実際にはBeginとEndをユニークポインタで管理するだろうが、それ以外に違いはない。</p>
            <p>TaskManagerBeginに、終了フラグや排他制御関係のものを持たせる。</p>
            <p>TaskManagerEndは、生成時にTaskManagerBeginの参照を要求する。</p>
            <p>TaskManagerEndの破棄時に、TaskManagerBeginの終了フラグを設定する。</p>
            <p>といった具合だ。</p>
            <p>他にも、WaitTaskCancellerみたいなものをBeginとEndの間に配置することで、待機タスクをキャンセルによって終了させる、ということもできるようにする予定。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/16 02:20</h2>
            <p>待機スレッドプール完成。</p>
            <p>＊</p>
            <p>出来たそれを使って、早速ウィンドウの処理に待機タスクを追加した。</p>
            <p>ゲームパッドマネージャの処理も、タスクで処理するように書き換えた。</p>
            <p>あとはゲームパッドだけ。</p>
            <p>それが完了したら0.8.0として確定するか。</p>
            <p>＊</p>
            <p>現時点で、スレッドプールで稼働しているスレッドが1つでも、ウィンドウとゲームパッドマネージャがきちんと動作することを確認している。</p>
            <p>待機スレッドプールを作る前は、どちらかのタスクが待機を行なっている間、もう片方のタスクを処理できなかった。</p>
            <p>…はず。</p>
            <p>残念ながら確認したわけではない。</p>
            <p>絶対やばいよなぁ、ということで対応したので。</p>
            <p>＊</p>
            <p>ウィンドウとゲームパッドマネージャのタスクの管理部分は、ほぼ同じ構成になった。</p>
            <p>共通化できそうな気がするが、そううまくいくだろうか、とも思う。</p>
            <p>うまく共通化できれば、かなり有用なものになりそうなのだが。</p>
            <p>ゲーム側のタスク管理にも使えるし。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/15 12:20</h2>
            <p>普通のスレッドプールのタスクについても破棄処理が間違っている気がする。</p>
            <p>＊</p>
            <p>現状、タスクの破棄処理は未稼働タスクの削除と稼働中タスクの待機をした後に行なっている。</p>
            <p>しかし、未稼働タスクの削除はいらないのではないか？</p>
            <p>確かにタスクの破棄までの時間が短縮されるが、そもそも稼働させたいから未稼働タスクに蓄積されているのだ。</p>
            <p>それを稼働させずに消してしまう、というのはおかしい気がする。</p>
            <p>それに、普通のスレッドプールは待機が発生することがないのだから、ちょっと待てばすぐ終了するはずだ。</p>
            <p>なので、未稼働タスクと稼働中タスク、どちらからも破棄対象のタスクがなくなるまで待機するのが正しいかな、と。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/15 00:00</h2>
            <p>待機スレッドプール、まだ出来てないが構成ははっきりした感じ。</p>
            <p>＊</p>
            <p>pthread_cancel()で待機を強制的に切って終了させる、というのは多分やらない方向になる。</p>
            <p>pthread_cancel()による強制終了処理自体は用意するが、それはあくまで例外的な処理であり、通常は待機が終わるまで待って終了させる。</p>
            <p>そもそも、pthread_cancel()を使わざるを得ない状況というのがあまりないのだ。</p>
            <p>read()やpoll()などの、条件を満たさなければ処理が進まない、というような関数を使う場合にのみ使うべきだ。</p>
            <p>例えばミューテックスと条件変数によるwait()であれば、notify()で起こしてやればいい。</p>
            <p>破棄したい場合には、例えば終了フラグなどをセットしてから起こしてやれば上出来だろう。</p>
            <p>そんなわけで、昨日書いた想定は間違い。</p>
            <p>＊</p>
            <p>待機スレッドプールは、私が考えていた以上に便利な面もありそう。</p>
            <p>pthread_cancel()を使う場合、今までのやり方では想定しているポイント以外でキャンセルが発生しないか不安に思っていた。</p>
            <p>それが、待機スレッドプールを使うことにより、pthread_cancel()の影響する範囲を待機タスクの部分のみに絞ることができる。</p>
            <p>普通のスレッドプールで処理する範囲に関しては、pthread_cancel()でキャンセルがかかることは絶対になくなったわけだ。</p>
            <p>この安心感は大きい。</p>
            <p>＊</p>
            <p>しかし、今作ってるこれ、動作的にはファイバのようなものだな。</p>
            <p>固定数のスレッドと、それを利用する無数の処理の断片、という構図になるので、効率的に処理を回せそうな雰囲気はある。</p>
            <p>でも、処理と処理を繋ぎ合わせてるのは実質的にgotoのようなものなんだよな。</p>
            <p>あまり複雑な繋ぎ方はしない予定だけど、やろうとすれば簡単にスパゲティ化するだろうし、ちょっと怖い。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/14 02:45</h2>
            <p>ゲームパッドのスレッドについては後回しにした。</p>
            <p>＊</p>
            <p>だって現状が中途半端すぎるもんで。</p>
            <p>ウィンドウのイベント読み込み待機中、スレッドプールの1スレッドを占有してしまうのが痛い。</p>
            <p>処理の詰まりを分かりやすくするために、スレッドプールは1スレッドのみで動かしていて、その1スレッドがメインウィンドウのイベント処理だけに使われちゃってもうだめ。</p>
            <p>スレッドプールでは待機無しの処理だけを流すので、待機処理は待機スレッドプールというのを別に用意し、そこでやろうと考えている。</p>
            <p>＊</p>
            <p>待機スレッドプールは、プールっていうよりキャッシュなんだけど。</p>
            <p>待機処理が必要になった時にスレッドを起動し、そのスレッドで待機処理をする。</p>
            <p>待機処理を終えたスレッドはそのまま保持しておき、別の待機処理に使い回す。</p>
            <p>＊</p>
            <p>とまぁ、そんな具合。</p>
            <p>スレッドプールのタスクは待機が発生しない処理だけを流すので、破棄は処理が終わるのを待ってからにしている。</p>
            <p>一方、待機スレッドプールのタスクはpthread_cancel()で待機を強制的に切って終了させる予定。</p>
            <p>pthread_cancel()で終了したスレッドは使い回せないので、joinしてから破棄、という流れになるだろうな。</p>
            <p>＊</p>
            <p>待機スレッドプールについてはまだちょっともやもやしてるんだよなぁ。</p>
            <p>きちんと作れるのか不安だ。</p>
            <p>普通のスレッドプールと比べて、違うのは内部、つまり実装だけで、インターフェース自体はほぼ同じになる予定ではあるのだが。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/13 20:30</h2>
            <p>ひとまず、ウィンドウから使うところまではできた。</p>
            <p>＊</p>
            <p>ゲームパッドの方についても、ちゃっちゃとやってしまう予定。</p>
            <p>とりあえず、スレッドプール以外にstd::threadを使用している箇所が無くなるようにする。</p>
            <p>＊</p>
            <p>タスクの引数に、そのタスクの参照を追加したのはいいのか悪いのか。</p>
            <p>タスクの処理の最後でそのタスクを再度開始させることで、ループ処理をするために追加した。</p>
            <p>これが無い場合、タスクをなんらかの構造体のメンバとして追加したりしないと、自身の参照を得るのが困難だったからだ。</p>
            <p>しかしながら、実際の運用を考えた場合、自身を再度開始させることなんてないのでは？という気もしている。</p>
            <p>処理の待機が存在しないタスクを回し続けたらCPUの稼働率が無駄に高くなってしまうし。</p>
            <p>処理の待機は別の種類のタスクで処理する予定なので、それを利用すると処理タスク→待機タスク→処理タスク→…となるので、自身は参照しない。</p>
            <p>それにその場合、循環参照になるため全タスクをなんらかの構造体にメンバとして追加することになると思うし。</p>
            <p>とはいえ、今はウィンドウの処理で使ってるから、そこで使わなくなったらさっさと消してしまうかな。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/11 00:00</h2>
            <p>構成失敗したかも。</p>
            <p>＊</p>
            <p>スレッドプールの件。</p>
            <p>とりあえずできたので、実際に使おうとしたのだがうまくいかない。</p>
            <p>スレッドタスクというものを作り、それをプールに投げて実行する、という形を取っているのだが、処理が終了したかどうか確認できないという問題が浮上した。</p>
            <p>タスクを破棄したくても、まだ処理中かもしれないし、破棄しても大丈夫なのかどうかが判断できないのだ。</p>
            <p>プールが1つならまだどうにかできるかもしれないが、現在の仕様上だとタスクはプールに投げる時に対象のプールを指定する形を取っており、やろうとすれば複数のプールに投げることもできる。</p>
            <p>その場合、こっちのプールではどうだ、あっちのプールでは、といった感じの処理が必要になり、収拾つかなくなる感じがある。</p>
            <p>実際には、複数のプールを生成することに意味は全く無いので、そのようなことはやらないが、そうなる可能性があるという時点で構成が間違ってる気がするのだ。</p>
            <p>＊</p>
            <p>私が想定している運用からすると、タスクを生成するタイミングで、そのタスクを処理するプールを指定しておく形がいいのかもしれない。</p>
            <p>そうすれば、タスクを処理するプールが1つに固定されるので、処理の終了チェックなどがやりやすくなるはずだ。</p>
            <p>＊</p>
            <p>他の問題としては、あるタスクの処理内で、他のタスクをプールに投げる、とかについてか。</p>
            <p>通常時は問題ないと思うが、これまたタスクを破棄するタイミングで、タスクをプールに投げようとしたらそのタスクはすでに破棄済みでメモリ例外、なんてのは起きそうなものだ。</p>
            <p>どちらかといえばプールやタスクの問題というより、そもそもマルチスレッド処理だから起きる問題という感じなので、その辺考慮した記述をすれば問題ないのだろうけど。</p>
            <p>＊</p>
            <p>本当なら、今の構成を作るのは昨日中に終わってた気もするんだけど、やる気減退してたのか終わらなかった。</p>
            <p>終わってたところで、今日同じ問題にぶち当たって頭抱えてたか。</p>
            <p>さて、どのように修正加えていくかくらいは目星を付けておくか。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/09 00:40</h2>
            <p>とりあえず0.7.0は完了。</p>
            <p>＊</p>
            <p>スレッドプールについては、waitをどう処理するかまだ考えてないのだった。</p>
            <p>そこを考えるのは後回しにしてもいいような気がするけど。</p>
            <p>＊</p>
            <p>スレッドプールで動かす処理についても、イベントハンドラと同じ形にしようかと思っている。</p>
            <p>ファンクタを引数にスレッドプールハンドラとでも言うべきものを生成する。</p>
            <p>スレッドプールにそれを登録することで、プールしてあるスレッドで処理する。</p>
            <p>そう考えると、同じハンドラを複数回登録するのもありかな、と考えている。</p>
            <p>＊</p>
            <p>というのも、現状ではウィンドウやゲームパッドのイベントハンドラは、同じものを複数回登録できない仕様にしているのだ。</p>
            <p>この制限も、正直あまり意味がないので撤廃するべきかもしれない。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/08 00:10</h2>
            <p>ベースシステムデータの変更については完了したと言える。</p>
            <p>＊</p>
            <p>ゲームパッドのイベントからウィンドウの再描画要求出せるようになった。</p>
            <p>ゲームパッドいじくるとウィンドウに描画している三角形の色が変わっていい感じ。</p>
            <p>しかしながら、ウィンドウやゲームパッドマネージャのスレッド開始についても変更しておかないとまずい。</p>
            <p>その変更が完了したら、0.7.0としようと思う。</p>
            <p>＊</p>
            <p>0.8.0はどうしよう。</p>
            <p>スレッドプールの追加が妥当だろうか。</p>
            <p>しかし、それがないと困る、というレベルでも…なくはないか？</p>
            <p>イベント処理をスレッドプールでやるようになれば、描画イベントの処理遅延も改善できるはずだし。</p>
            <p>＊</p>
            <p>他の候補としては、sucroseではなくcandymakerの方か。</p>
            <p>ファイルパスの扱いをはっきりさせる。</p>
            <p>その辺ができれば、設定ファイルがより実用的になる。</p>
            <p>現状では、絶対パスもしくは作業ディレクトリからの相対パスしか指定できないからなぁ。</p>
            <p>ファイル入出力なども作り始めることができるようになるはずだ。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/07 00:10</h2>
            <p>ゲームパッドのイベント内でウィンドウの参照を取得できるように対応中。</p>
            <p>＊</p>
            <p>ベースシステムデータの中身を2つに分けることで対応することにした。</p>
            <p>片方は従来のものからデータ参照機能を取り除いたもの。</p>
            <p>もう片方は従来のもののデータ参照機能と、ウィンドウなどの実行中のデータ参照機能を合わせたもの。</p>
            <p>スレッド処理に関しては、とりあえず自前で実行する形にしようと思う。</p>
            <p>スレッドプールについてはまた今度。</p>
            <p>多分今やってるのが完了したらやる。</p>
            <p>＊</p>
            <p>今日中に2つに分割する作業は完了したいところだったが、ちょっと厳しそう。</p>
            <p>明日中には。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/06 12:40</h2>
            <p>色々考えた結果、やはり音は後回しにすることにした。</p>
            <p>＊</p>
            <p>位置付けとしては、テクスチャ、というより画像ファイルに近い感じがするのだ。</p>
            <p>あれば便利だろうけど、今すぐに必要というわけでもない。</p>
            <p>それに、音に関してはどのように構成するべきなのか、まだよく分かっていないのだ。</p>
            <p>その試行錯誤に時間を使ってしまうよりも、別のところを進めるべきかな、と。</p>
            <p>＊</p>
            <p>差し当たっては、ゲームパッドのイベントからウィンドウの再描画要求をするのが困難、という点をどうにかしよう。</p>
            <p>ゲームパッドの入力が即座に画面に反映されないので、これではゲームにならない。</p>
            <p>しかし現状、ウィンドウ生成時にイベント処理スレッドを開始しているのが問題になるか？</p>
            <p>ゲームパッドマネージャでも、生成時にイベント処理スレッドを開始している。</p>
            <p>全てのイベント処理が始まる前に下準備をしておく、ということができなさそうだ。</p>
            <p>今回の件では、ゲームパッドのイベントからウィンドウを参照できるようにしておく、というのがそれに当たる。</p>
            <p>対処方法としては、単純に考えて生成とスレッド開始を別々にしておき、準備が完了した後にスレッドを開始する、となるんだろうけど。</p>
            <p>しかしそれはあまりスマートじゃないなぁ。</p>
            <p>今はまだウィンドウとゲームパッドマネージャだけ、2つだからいいけど、今後スレッドを起動する要素が増えていったら大変そうだ。</p>
            <p>＊</p>
            <p>そこで、スレッドはスレッドプールで管理する、という方法を考えている。</p>
            <p>スレッドプールの生成と開始を別々にしておく。</p>
            <p>スレッド処理が必要な要素は、生成時にスレッド処理をスレッドプールに登録する。</p>
            <p>スレッドプールのスレッド開始命令で、登録されている処理を一斉に開始する。</p>
            <p>しかしながら、私はスレッドプールというものについて、言葉と大体のイメージしか知らんので、そんなにうまくいくものだろうか、という不安がある。</p>
            <p>できれば、イベント処理1つ1つについても、スレッドプールに投げてスレッドで処理したいのだけど。</p>
            <p>それによって、描画処理の垂直同期による、ウィンドウイベントの処理遅延も解決できる気もするし。</p>
            <p>＊</p>
            <p>さて、どこから手を付けるか。</p>
            <p>ひとまず、スレッドプールは置いといて、ゲームパッドのイベントからウィンドウの再描画要求ができるように、構成を変更するか。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/03 22:50</h2>
            <p>0.6.1できた。</p>
            <p>＊</p>
            <p>ウィンドウ生成とかに追加した、いらんデータの削除と、課題管理に上げてた2件を対応。</p>
            <p>＊</p>
            <p>次からは音と思っていたけど、うーん。</p>
            <p>音を扱うということは、まずファイル読み込みを使うことになりそうな気がする。</p>
            <p>ウィンドウやゲームパッドはそんなことないけど。</p>
            <p>＊</p>
            <p>別のところを進めるべきか。</p>
            <p>土日にじっくり考えてみよう。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/03 18:15</h2>
            <p>ぐーたらやってたら遅くなってしまったが、0.6.0できた。</p>
            <p>＊</p>
            <p>ゲームパッドを扱う簡単なプログラム、gamepadtestを作って思ったことには、ウィンドウを参照しにくいという点だ。</p>
            <p>ちょっと前に作った描画を行なう簡単なプログラム、painttestの時は、ウィンドウを参照するのが描画イベント内であり、イベントデータからウィンドウの参照が得られるため問題なかった。</p>
            <p>しかし今回は、ゲームパッドのイベント内からウィンドウの再描画リクエストをしようとしたけど、現状ではできていない。</p>
            <p>ウィンドウの参照を得られないからだ。</p>
            <p>そんなわけで、ゲームパッドの抜き差しやボタン押下などに反応して、描画色を変えるようにしているのだけど、ウィンドウを一旦隠すとかして、手動で再描画させないと色が変わらない感じ。</p>
            <p>実行中のベースシステムデータ、みたいなものを用意して、今動いてるベースシステムのデータ、つまりウィンドウの参照などを取得できるようにするべきか。</p>
            <p>＊</p>
            <p>とりあえず、細かい修正をやってしまおう。</p>
            <p>ウィンドウの生成時やら描画イベントやらに足してしまった、ベースシステムデータの参照削除と、あとは課題管理に追加してある件を何件か、といったところか。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/02 20:40</h2>
            <p>想像以上に疲れた。</p>
            <p>＊</p>
            <p>ゲームパッドIDの対応は完了した。</p>
            <p>やはり仕様変更は疲れる。</p>
            <p>テスト駆動でやってるからか、きちんとできてそうな実感があるのはいいのだけど。</p>
            <p>今回のは、さすがに最初に横着しすぎただろうか。</p>
            <p>最初からゲームパッドIDを文字列でなく独立した型にしていれば、こんなことには。</p>
            <p>処理内容だったらともかく、型についてはできるだけ後から変更をかけないようにしないといけないな。</p>
            <p>＊</p>
            <p>とりあえず、ベースシステムデータにゲームパッドのイベントハンドラを設定できるようにして、メインでゲームパッドマネージャを起動するところまでは書けた。</p>
            <p>なので、ゲームパッドを使用する簡単なプログラムを作りたいところだけど、いかんせん疲れた。</p>
            <p>明日でいいかなーという気がしている。</p>
            <p>プログラムが問題なく動くなら0.6.0として確定させるから、できれば今日やりたい気もするんだが。</p>
            <p>＊</p>
            <p>明日は金曜日か。</p>
            <p>明日中に0.6.1を作れればきりがいいな。</p>
            <p>簡単なプログラムの作成と細かい修正、これらをまとめて明日中に…やれるか？</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/01 23:35</h2>
            <p>ゲームパッドの扱い、ほぼ完成。</p>
            <p>＊</p>
            <p>ゲームパッドIDに関してはまだ生の文字列のままなので、明日直そう。</p>
            <p>それができたら0.6.0とする。</p>
            <p>＊</p>
            <p>次はゲームパッドに関するものをベースシステムに追加するとしよう。</p>
            <p>で、簡単なゲームを作る。</p>
            <p>あー、ウィンドウのイベントにベースシステム関係の参照追加しちゃったのも直すか。</p>
            <p>他にも細かい修正したらそれを0.6.1とするか。</p>
            <p>＊</p>
            <p>以前の記述を見直したら、ゲームパッドの次は音って書いてるな。</p>
            <p>それもそうか。</p>
            <p>音までやって、ゲームパッドで動かせて音も出るゲームを作れたら、中途半端にしてる部分もどうにかしていくべきだろうな。</p>
        </div>
        <hr />
        <div>
            <h2>2016/05/31 21:00</h2>
            <p>さすがに昨日の今日で本調子とは行かないか。</p>
            <p>＊</p>
            <p>とりあえず、ゲームパッド接続・切断に関しては出来上がった。</p>
            <p>ゲームパッドIDはただの文字列ではなく型を作るべきとは思うが、使えないこともないし今はこれでいいだろう。</p>
            <p>次はゲームパッドの入力だ。</p>
            <p>接続イベントを済ませた後にゲームパッドの入力を扱うオブジェクトを作り、切断イベントの前に破棄、という形になるだろうな。</p>
        </div>
        <hr />
        <div>
            <h2>2016/05/31 00:10</h2>
            <p>先週中にゲームパッド対応は終わらせたかった。</p>
            <p>＊</p>
            <p>でもそれはさすがに無茶だったようだ。</p>
            <p>金曜開始時点で、ゲームパッドの入力の扱いに関してはノータッチだったし。</p>
            <p>＊</p>
            <p>で、今日。</p>
            <p>体調が優れないのと、キーボードの調子が悪いのダブルパンチで作業はかどらず。</p>
            <p>キーボードのEnterキーが、1回押しただけなのに2回入力される現象が稀に発生していた。</p>
            <p>しかし、前に壊してしまった同じ型のキーボードからパーツを拝借したところ、どうやら改善できたようだ。</p>
            <p>＊</p>
            <p>明日こそ本気出す。</p>
        </div>
        <hr />
        <div>
            <h2>2016/05/26 17:00</h2>
            <p>evdevは地雷だったかもしれない。</p>
            <p>＊</p>
            <p>とりあえずわけがわからない。</p>
            <p>ゲームパッドのボタン数取得方法からしてもうだめ。</p>
            <p>かろうじて分かったことは、どうもそんなのなさそう、という空気だけ。</p>
            <p>evdevでのゲームパッドの扱いは多分、windowsのxinputに近いんじゃないかなと思う。</p>
            <p>決まった仕様にゲームパッドを当てはめていく感じ。</p>
            <p>xinputの方はまだいい。</p>
            <p>ゲームパッドのボタン数とかも仕様のうちに入っているため、ボタン数や軸数が固定だから。</p>
            <p>evdevの場合、とりあえずいくつか用意しておいたボタンのうち、接続したゲームパッドだとこのボタンとこのボタンと…が使えるよ！！みたいな情報を得てどうのこうのとか、なにやらすごいめんどくさい。</p>
            <p>多分evdevだと、ボタンが100個とか付いてるゲームパッドに対応できないんじゃないかな。</p>
            <p>そんなもの扱う予定などないが、古い仕様やDirectInputにはできた。</p>
            <p>evdevとxinputにはそれができなさそう。</p>
            <p>もうフォースフィードバックとかどうでもいいんで、古い仕様の方を使うとしよう。</p>
            <p>ゲームパッドが振動するみたいな機能、私基本的に嫌いだし。</p>
            <p>＊</p>
            <p>結構な時間とやる気を無駄にしてしまった。疲れた。</p>
        </div>
        <hr />
        <div>
            <h2>2016/05/26 11:50</h2>
            <p>ゲームパッド切断については、昨日すぐ作った。</p>
            <p>＊</p>
            <p>で、pthread_kill()もちょっと扱いめんどうそうだな、というのも大体理解した。</p>
            <p>というわけで、今日はゲームパッドの入力の扱いに入ろうとしている。</p>
            <p>のだが、いまひとつまとまらないような。</p>
            <p>＊</p>
            <p>過去のプロジェクトの構成とは、これまた少し変える予定。</p>
            <p>過去のプロジェクトでは、ゲームパッドの初期状態に関してもボタンや軸の状態変化イベントを呼び出していたが、これはやめる。</p>
            <p>ボタンの初期状態の通知と、ボタンの状態変化の通知というのは別物にするべきだと思うからだ。</p>
            <p>具体的には、初期状態についてはゲームパッド接続イベントのイベントデータから取得できるようにする。</p>
            <p>状態変化については変えなくてもいいと思う。</p>
            <p>過去のプロジェクトと同じく、変化があったものについてどう変化したかのみ通知する。</p>
            <p>ボタン数、軸数の取得については、過去のプロジェクトのやり方はさすがに頭が悪すぎる。</p>
            <p>要求があった時にゲームパッドから取得して返す、とかちょっと。</p>
            <p>ゲームパッドを扱うならまず使用するデータなんだし、接続時にゲームパッドから取得する。</p>
            <p>＊</p>
            <p>あと、今回は状態変化イベント、ということでボタンと軸の区別をなくそうと思っていたけど、やっぱりだめかも。</p>
            <p>変化したものだけ通知する場合、やはりこれは別々の方がいい。</p>
            <p>1つにするとなると、例えば変化したのがボタンなのか軸なのか、といったフラグのようなデータが必要になるし。</p>
            <p>あるいは、ゲームパッドのボタンや軸の状態を全て記録しておく形か。</p>
            <p>しかしそれは扱いにくそう。</p>
            <p>どのボタンもしくは軸に変化があったのか知りたい場合、直前のイベントデータと比較しなければならないわけだし。</p>
            <p>なにより、そのようなことがしたければイベントハンドラでやればいいと思う。</p>
            <p>提供する機能は、必要最低限にしたいのだ。</p>
            <p>＊</p>
            <p>まとめると、イベントで扱えるデータは、まず共通的なものが</p>
            <p>・ゲームパッドID</p>
            <p>接続時に扱えるデータが</p>
            <p>・ボタン数</p>
            <p>・軸数</p>
            <p>・ボタンの初期状態</p>
            <p>・軸の初期状態</p>
            <p>状態変化時に扱えるデータが</p>
            <p>・変化のあったボタンもしくは軸</p>
            <p>・値</p>
            <p>こんな具合だと思っている。</p>
            <p>ちなみにゲームパッドIDというのは、一意であればなんでもいい。</p>
            <p>デバイスのパスのようなデータになると思うが。</p>
            <p>あー、ゲームパッド名も接続時、もしくは共通データとして保持するべきか？</p>
            <p>ボタンと軸の数についても、接続時以外でも見られた方が便利だろうか。</p>
            <p>それなら、接続イベント時にどっかに退避しておく、というのをイベントハンドラでやればいいとも思っているのだけれど。</p>
            <p>＊</p>
            <p>さて、どこから手を付けるか。</p>
            <p>やはり接続時に参照できるデータから追加していくべきか。</p>
        </div>
        <hr />
        <div>
            <h2>2016/05/25 14:20</h2>
            <p>ゲームパッド接続検出処理ができた。</p>
            <p>＊</p>
            <p>過去のプロジェクトよりはましになった気がする。</p>
            <p>過去のプロジェクトでは、pthread_cancel()でスレッドをキャンセルして終了させるために、そのスレッド内では動的なメモリ確保を行なわないようにしていた。</p>
            <p>pthread_cancel()で終了するスレッドと、そのスレッドからデータを受け取って処理するスレッド、2つのスレッドを走らせていたのだ。</p>
            <p>＊</p>
            <p>今回は、とりあえず起動するスレッドは1つにした。</p>
            <p>スレッド内で使用するデータに関しては、スレッド起動前に生成し、sucrose::GamepadManagerに持たせるようにした。</p>
            <p>＊</p>
            <p>しかし、pthread_kill()を使えばもっとスマートにできるのではないか？</p>
            <p>使ったことないから確証はないが、スレッドに対してシグナルを投げられるので、poll()を起こすのに使えるかな、と。</p>
            <p>それがうまく行くなら、sucrose::GamepadManagerにメンバとしてデータを持たせる必要がなくなりそう。</p>
            <p>＊</p>
            <p>ひとまず、切断検出を先にやってからにしよう。</p>
            <p>とりあえずは動いてるわけだからな。</p>
        </div>
        <hr />
        <div>
            <h2>2016/05/25 01:10</h2>
            <p>ちょっとやる気減退してきているような。</p>
            <p>＊</p>
            <p>主にudevが悪いと思う。</p>
            <p>でも、なんとか初回のゲームパッド接続検出処理はできた。</p>
            <p>過去のプロジェクトを参考にしつつ、多少処理は変えた。</p>
            <p>デバイスがゲームパッドかどうかのチェックを簡略化した感じ。</p>
            <p>しかし、evdevか。</p>
            <p>そんなのもあったな、っていう気持ち。</p>
            <p>1つのデバイスについて、/dev/input/jsXと/dev/input/eventXの2つが出てくるからなんだろうと思ったら、後者はevdevのデバイスらしい。</p>
            <p>過去のプロジェクトでは、確か見た目だけで判断して前者を使ってたんだけど、どうもこっちは古いらしい。</p>
            <p>evdevの方がフォースフィードバックにも対応してるとかなんとか。</p>
            <p>なので、今回はevdevの方を採用することにした。</p>
            <p>＊</p>
            <p>明日中には、少なくともリアルタイムのゲームパッド接続検出を仕上げてしまいたい。</p>
            <p>切断についても、同じ処理の中に含ませられると思うし、やってしまいたいところ。</p>
            <p>で、接続・切断ができたら次はゲームパッドの状態変化検知だけど、これは多少時間かかるだろうな。</p>
            <p>デバイスをオープンしてどうの、という処理が必要になってくるわけだし。</p>
        </div>
        <hr />
        <div>
            <h2>2016/05/23 23:50</h2>
            <p>sucrose::GamepadManagerの作成に入り始めた。</p>
            <p>＊</p>
            <p>ゲームパッド接続イベントについて、イベントハンドラとかイベントデータとかイベントハンドラ集合とかを作ったのでいよいよ本体。</p>
            <p>しかし、午後に野暮用で出かけたせいか、暑かったせいもあり以降やる気出んで途中まで。</p>
            <p>なんとか、ただGamepadManagerを生成する部分までは書いたので、明日はその中身。</p>
            <p>udevを利用して、ゲームパッドの接続を検出する。</p>
            <p>多分、その辺は過去のプロジェクトのソースを流用できるはず。</p>
            <p>参考にして手早く済ませたい。</p>
        </div>
        <hr />
        <div>
            <h2>2016/05/20 23:56</h2>
            <p>昨日の変更は失敗だったかもしれない。</p>
            <p>＊</p>
            <p>ゲーム固有データ初期化時に、ベースシステムデータを参照できないので、描画イベント内でベースシステムデータ→ゲーム固有データ→OpenGLコンテキストが参照できない、のが問題だったんだけど。</p>
            <p>改めて考えてみたら、イベントハンドラにはラムダ式を使えるようにしているので、描画イベント生成前に生成しているOpenGLコンテキストの参照を描画イベント生成時に渡せばそれで見られるわ。</p>
            <p>ラムダ式のような構文を使えない、あるいは使いにくい言語とかのために作った、と考えれば全く使い道がないわけでもないか？</p>
            <p>それに、ラムダ式の参照だけだと、相互に参照し合う、みたいな状態への対応が難しいか。</p>
            <p>いや、そんな構成にすること自体よくないんだが。</p>
            <p>＊</p>
            <p>あとは、ベースシステム起動時に使うデータが、実行中常に触れる状態になってるのもなんか気になる。</p>
            <p>実装済みのデータで言えば、ウィンドウのイベントハンドラ。</p>
            <p>これはベースシステム起動時に生成するウィンドウで使用するためのものなので、それ以降は必要がなくなる。</p>
            <p>しかし、実行中もsucrose::setWindowEventHandlers()を呼び出せてしまう。</p>
            <p>意味は全くないが。</p>
            <p>しかし意味がないものを呼び出せるというのはなんだか気持ちが悪い。</p>
            <p>＊</p>
            <p>そこで、ベースシステム起動時にのみ使用するデータと、実行中も使用するデータの2つに分ける、という案を思い付いた。</p>
            <p>前者はBaseArgs、後者はBaseContextとかそんな名前で。</p>
            <p>例えばゲーム固有データは実行中も使用するので、後者に格納される。</p>
            <p>ゲーム側からは、BaseArgsはゲーム初期化時には参照できるが、以降は参照できなくなる。</p>
            <p>今までベースシステムデータの参照を必要としていた部分は、BaseContextの参照に置き換わるような感じ。</p>
            <p>＊</p>
            <p>せっかくbitbucketに課題管理システムがあるのだから、活用するべきかもしれない。</p>
            <p>少なくとも今のプロジェクト作ってからは一度も使っていない。</p>
            <p>思い付いた案をここに書いておくだけでも、書かないよりましだとは思う。</p>
            <p>しかし、そのうちどこに書いたのかとか、むしろ書いたこと自体忘れてしまうだろう。</p>
            <p>そうなる前に、課題として投稿しておくべきだろうな。</p>
        </div>
        <hr />
        <div>
            <h2>2016/05/20 17:05</h2>
            <p>ゲームパッドの入力取得の構成を考えている。</p>
            <p>＊</p>
            <p>古いプロジェクトで作ったやつをそのまま使えば楽なのでは、と思いもしたのだが。</p>
            <p>前に作ったやつは、いい加減にもほどがあるような構成だった気がする、と思って検索してみた。</p>
            <p>古いプロジェクト全てに対しfindでファイルを検索したところ、どうやらdp時代に作ったものが最後だったようだ。</p>
            <p>それより後のプロジェクトでは、そこに辿り着く前に作り直してたんだな。</p>
            <p>＊</p>
            <p>ファイル構成をぱっと見て記憶を探ったが、確かこんな感じだったはずだ。</p>
            <p>・ゲームパッド接続管理（GamePadManager）で、ゲームパッドの接続、切断を検知</p>
            <p>・接続、切断時には、ゲームパッドに結び付くデータ（GamePadKey）がイベントハンドラの引数として得られる</p>
            <p>・GamePadKeyを引数に、ゲームパッド1つを表現するオブジェクト（GamePad）を生成することで、対応するゲームパッドの状態変化（ボタンを押した、離したなど）を検知できるようになる</p>
            <p>＊</p>
            <p>GamePadがおかしい。</p>
            <p>ゲームパッドは人の手で自由に接続したり切断したりできるのに、それをプログラムが任意に生成できるオブジェクトとして表現するのは違和感がある。</p>
            <p>ゲームパッドが切断されているのにGamePadが存在し続けることができるし、逆にゲームパッドが接続されているのにGamePadが存在しないことにもできる。</p>
            <p>そういう不自然な構成は、実際に利用しようとすると扱いにくく感じることが多いのだ。</p>
            <p>＊</p>
            <p>そんなわけで、少なくとも物理的なゲームパッドに直接結び付く低レイヤー部分では、任意に生成可能なゲームパッドを表現するオブジェクトなんてのは用意しない方がいいだろうな。</p>
            <p>GamePadManagerにゲームパッドの接続、切断検知以外に、ゲームパッドの状態変化についてもイベントを処理させる形がいいかもしれない。</p>
            <p>GamePadManager周りについては、古いプロジェクトの処理を参考にしてもいいかもしれないな。</p>
            <p>それと、GamePadはGamepadと記述することにしよう。</p>
        </div>
        <hr />
        <div>
            <h2>2016/05/19 21:10</h2>
            <p>描画イベントハンドラ内で、ゲーム固有データを参照できるようにした。</p>
            <p>＊</p>
            <p>具体的には、描画イベントデータの中にベースシステムデータを追加した感じ。</p>
            <p>描画イベントデータからベースシステムデータの参照を取得し、そこからゲーム固有データの参照を取得する。</p>
            <p>これで、昨日の時点で問題になっていた部分は解決した。</p>
            <p>2つ関数を呼ばないとゲーム固有データの参照を取得できないとか、なんかめんどうな気もするけど、どうにかするとしたら後でいいだろう。</p>
            <p>取得できないよりはずっとましだ。</p>
            <p>＊</p>
            <p>他に目についた問題点といえば、描画処理に関する点だ。</p>
            <p>ウィンドウのサイズを変更すると再描画要求が発生し、再描画のために描画イベントハンドラが呼び出される。</p>
            <p>イベントハンドラ内で動作確認用のログをstd::printf()で出力しているのだが、ウィンドウサイズをぐりぐりと変更した後、サイズ変更をやめても少しの間ログが出続ける。</p>
            <p>垂直同期するような処理はまだ入れてないはずなのに、描画で処理遅延が出るというのは違和感あったので、調べてみたらどうも垂直同期が行なわれていたようだ。</p>
            <p>これはなにか対処すべきか、と思ったけど普通に考えて描画イベント内で描画処理をしなければいいだけなんだよなぁ。</p>
            <p>変にイベントをまとめたりしてもおかしなことになりそうだし。</p>
            <p>＊</p>
            <p>一段落した感触がある。</p>
            <p>次はどこを進めようかな。</p>
            <p>ゲームとして最低限必要なもの、と考えた場合、操作系を作るべきか。</p>
            <p>マウスやキーボード、そしてゲームパッド。</p>
            <p>ゲームパッドをメインに据えたいところだけど、ゲームパッドは個体ごとの仕様がばらばらすぎて、うまく管理したいけどまだいい案がないんだよなぁ。</p>
            <p>まぁ、管理部分については後回しでもいいだろう。</p>
            <p>低レイヤーなものでも、ゲームパッドが扱えればゲームパッドを動かすと画面に変化が出る、ということができるようになる。</p>
            <p>今後上に何か被せるとしても、そのまま使えそうな根底部分の処理を作っていこう。</p>
            <p>＊</p>
            <p>入力ができたら、次は音かな。</p>
            <p>画面への描画、プレイヤーの入力処理、音声出力。</p>
            <p>この3つができれば、ゲームと呼んでいいものが作れるだろう。</p>
        </div>
        <hr />
        <div>
            <h2>2016/05/18 19:13</h2>
            <p>ゲーム固有のデータを扱えるようにした。</p>
            <p>＊</p>
            <p>結局、ベースシステムデータに対し設定する関数を作り、それをゲーム初期化関数内から呼び出す形を取った。</p>
            <p>設定ファイルに関数名を記述する形にしなかったのは、簡単に言えばそこまでする必要はないと思ったからだ。</p>
            <p>ベースシステムデータの場合は、ベースシステムメイン関数を呼び出す前にゲーム初期化関数が呼び出され、その時点でベースシステムデータが必要になるため、ベースシステムメイン関数とは別に用意しておかなければならないという事情があった。</p>
            <p>しかし今回の場合は、似たような形を取ったところでゲーム初期化関数に入った時点ですでにゲーム固有データが生成されている、初期化関数内では生成する処理を書かなくて済む、程度の恩恵しか得られない。</p>
            <p>たかがその程度のことのために設定ファイルの要素を増やすこともないだろう。</p>
            <p>プログラムに記述する形であれば記述ミスなんかはコンパイラがエラーにしてくれるけど、設定ファイルの場合はその辺も自分でどうにかする必要があるから面倒だし。</p>
            <p>＊</p>
            <p>さて、まだ問題は解決していない。</p>
            <p>というより、大きな修正が必要になりそうな別の問題が出てきた。</p>
            <p>今日作った機能を使い、昨日作った表示プログラムを修正した。<a href="https://bitbucket.org/tekuto/painttest/src/0564ba24f354427d8151c1fe96a573b0783497f9/src/painttest/painttest.cpp?at=master&fileviewer=file-view-default" target="_blank">これ。</a></p>
            <p>valgrindでメモリ解放漏れがないか確認したいが、OpenGLを使っているためかこけてしまう。</p>
            <p>想定では解放漏れはないんだけど。</p>
            <p>その点はともかく、描画イベント中にベースシステムデータを参照することができないという問題が新たに出てきた。</p>
            <p>OpenGLコンテキストはベースシステムデータ内のゲーム固有データの中に持たせてあるため、素直にやろうとするとOpenGLによる描画ができないのだ。</p>
            <p>なので、今はその場しのぎな処理で対応している。</p>
            <p>ゲーム初期化時にゲーム固有データのポインタをグローバルに配置し、描画イベントでグローバルに配置したゲーム固有データのポインタを参照、OpenGLコンテキストを使用する、といった具合だ。</p>
            <p>こんな見苦しいやり方は、解放漏れ並みに容認できないので早急に修正したい。</p>
            <p>ぱっと思い付く解決法としては、ウィンドウ生成関数、つまりsucrose::newWindow()に引数としてベースシステムデータの参照を追加し、それをイベントハンドラに渡す、という方法だ。</p>
            <p>あらゆる箇所でそんなことをすればベースシステムデータへの依存度がやばくなりそう、とは思うものの、そもそもベースシステムありきのシステムなのだから、むしろよく今までやらずにやってこれたもんだな、とも思う。</p>
            <p>ソースの色々な場所に、std::printf()によるデバッグログ出力を記述しているが、これも将来的にはベースシステムデータの中にログ出力用データを配置して、それを使ってログ出力したいとも考えているし。</p>
            <p>とりあえず、描画イベントの件については上に書いた通りの方法でやってみるか。</p>
            <p>他の方法も思いつかないし、あったところでどうせ余計にトリッキーになるし。</p>
        </div>
        <hr />
        <div>
            <h2>2016/05/18 00:36</h2>
            <p>とりあえず表示プログラムできた。<a href="https://bitbucket.org/tekuto/painttest" target="_blank">これ。</a></p>
            <p>＊</p>
            <p>今のところソースファイルは1つだけ。<a href="https://bitbucket.org/tekuto/painttest/src/4b54a65eb483fd26c8bc3d56899b70949027457e/src/painttest/painttest.cpp?at=master&fileviewer=file-view-default" target="_blank">これ。</a>
            <p>ゲーム初期化処理でウィンドウイベントハンドラを生成し、それをベースシステムデータに設定してるだけ。</p>
            <p>OpenGLコンテキストの生成もしてるが、ウィンドウ自体の生成はしていない。</p>
            <p>構成としては想定通りだ。</p>
            <p>しかし、現時点ではの話とはいえゲーム自体にデータを持たせられないのはやはり問題だった。</p>
            <p>おかげで、OpenGLのコンテキストとかイベントハンドラの実体とか、そういうのはグローバルに置いてしまっていて、解放処理もしていない。</p>
            <p>ゲーム固有データをベースシステムデータに設定する処理を早急に作るべきか。</p>
            <p>どのように構成するべきかな。</p>
            <p>作ってみた感触としてはゲーム固有データはほぼ必須になる気がするし、ベースシステムデータみたく設定ファイルにイニシャライザ、ファイナライザの関数名を記述する形にするか？</p>
            <p>それで、ゲーム初期化処理の関数内に来た時にはすでにデータは生成されている、みたいな。</p>
            <p>あるいは上に書いたように、ゲーム初期化関数内で、ベースシステムデータに設定する形にするか。</p>
            <p>この場合設定するのは任意となる。</p>
            <p>よく考えて構成を決めるべきポイントだろうな。</p>
            <p>よく考えてみることにしよう。</p>
        </div>
        <hr />
        <div>
            <h2>2016/05/16 23:03</h2>
            <p>XInitThreads()の呼び出しとモジュール分割、両方完了。</p>
            <p>＊</p>
            <p>それに、ベースシステムデータにデータを1つ追加した。</p>
            <p>ウィンドウイベントハンドラだ。</p>
            <p>設定関数も作った。</p>
            <p>ゲーム側からベースシステムデータにウィンドウイベントハンドラを設定すれば、ゲームのメインウィンドウ生成時にそのイベントハンドラが使われる。</p>
            <p>明日は今日作った機能を使って、ウィンドウに表示を行なうプログラムでも作ってみるか。</p>
            <p>しかし現時点ではゲーム自体にはデータを持たせられないんだよなぁ。</p>
            <p>やるべきことはたくさんある。</p>
            <p>どこから手を出したものか。</p>
        </div>
        <hr />
        <div>
            <h2>2016/05/14 01:16</h2>
            <p>モジュールの初期処理、終了処理の対応ができた。</p>
            <p>＊</p>
            <p>次は、この機能を使ってsucrose側でXInitThreads()の呼び出しを追加するとしよう。</p>
            <p>モジュールの依存関係解決機能も使って、モジュール分割もするべきだろうな。</p>
            <p>それらが済んだら、いよいよベースシステム側とゲーム側の通信についても取りかかるか。</p>
            <p>いや、その前にまだやっておくべきことがあるか。</p>
            <p>現状ではベースシステム側とゲーム側とではモジュールの管理が別々になっている。</p>
            <p>そのため、両方で使われるモジュールがある場合、初期処理と終了処理が2回呼び出される可能性がある。</p>
            <p>だから、モジュールを集中管理するための仕組みを追加するべきかもしれない。</p>
            <p>とはいえ、現時点ではあまり初期処理や終了処理に頼らないため、まだ必要ないかも。</p>
            <p>XInitThreads()も、2回くらい呼び出しても多分平気だし。</p>
            <p>将来的には、多くのモジュールで初期処理と終了処理を使うことになるかもしれないけど。</p>
        </div>
        <hr />
        <div>
            <h2>2016/05/13 00:30</h2>
            <p>やる気出てる気がする。</p>
            <p>＊</p>
            <p>というわけで、モジュールの依存関係解決をやっつけた。</p>
            <p>今回の追加では、別パッケージのモジュールに依存するようなことはできない。</p>
            <p>あくまで同パッケージ内のみ。</p>
            <p>別パッケージのモジュールの指定方法をまだ決めてないから仕方がない。</p>
            <p>でもまぁ、これでもある程度はやれるはずだ。</p>
            <p>というわけで明日からは、初期化処理と終了処理の対応に入る。</p>
        </div>
        <hr />
        <div>
            <h2>2016/05/11 01:30</h2>
            <p>ゴールデンウィーク明けからやる気増してきた感ある。</p>
            <p>＊</p>
            <p>イベントハンドラについて大体処理の追加ができて、あとは実際にイベントが発生した時にイベントハンドラを呼び出すくらいになった。</p>
            <p>しかし、現在の仕様ではそろそろ限界な感じがある。</p>
            <p>モジュールの初期化処理が存在しないため、XInitThreads()を呼び出せていないので、記述自体は合っていてもX11をマルチスレッドで扱おうとしてこけたりしている。</p>
            <p>イベントハンドラが完了したら、モジュールの初期化処理と終了処理の対応を追加するべきか。</p>
            <p>いや、それをするにはモジュールの依存関係解決をやってからか？</p>
            <p>悩ましい。</p>
        </div>
        <hr />
        <div>
            <h2>2016/04/21 17:10</h2>
            <p>ベースシステム内で、OpenGLによる描画ができる、というところまで確認できた。</p>
            <p>＊</p>
            <p>次は描画処理をゲーム側で処理させたいところだが、それには多少手間がかかるな。</p>
            <p>流れとしては、ベースシステムデータにメインウィンドウに設定するイベントハンドラを用意し、ゲームの初期処理で描画イベント発生時の処理をイベントハンドラに追加、ベースシステムメイン関数でイベントハンドラを元にメインウィンドウを生成、となるんだろうけど。</p>
            <p>まず、イベントハンドラとかを作っていない。</p>
            <p>ウィンドウに関しても、イベントを全く処理していない。</p>
            <p>なので、作ってしまうとしよう。</p>
            <p>これらを作り終えたら、次はモジュールの依存関係の解決をやるか？</p>
            <p>現状、ゲームとベースシステム、それぞれ1モジュールしか読み込めないし不便だ。</p>
            <p>ベースシステムのライブラリに、ウィンドウの処理もOpenGLの処理も全て含めてしまっている状態だし。</p>
        </div>
        <hr />
        <div>
            <h2>2016/04/14 12:45</h2>
            <p>必要な処理はきちんと書かれていて、それ以外は書かれてなかったり手抜きだったりのいい感じのソースが書けた。</p>
            <p>＊</p>
            <p>というわけで、ウィンドウを表示するベースシステムが一応はできた。</p>
            <p>一応というだけあって、本当に表示するだけでそれ以外何もできないんだけど。</p>
            <p>おまけに表示を維持するために無限ループを回しているため、起動しているとCPU1コアの使用率が100%になる。</p>
            <p>しかしこれは大きな前進だ。ようやく表示まで漕ぎ着けた。</p>
            <p>次はOpenGLに対応させたいところだ。</p>
            <p>それができれば、ウィンドウ内に何かを書いて表示することができるし。</p>
            <p>それに関しても、とりあえずはベースシステム内で完結させるか。</p>
            <p>ゲーム側で描写処理をしたいところではあるが、それにはベースシステムとゲーム間のやりとりについて固めなくてはいけないので多少めんどうだし。</p>
            <p>それがない状態で、とりあえずOpenGLが使えるようになるところまでを、先に確認するべきだろうな。</p>
            <p>まぁ、OpenGLについても、基本は古いプロジェクトのソースを参考にすればどうにかなるはずだ。</p>
            <p>ウィンドウと同じように、参考にした上で簡略化や省略をして、暫定的なものを小さくまとめて実装するとしよう。</p>
        </div>
        <hr />
        <div>
            <h2>2016/04/13 14:25</h2>
            <p>とりあえずウィンドウを作らんと始まらぬ、と古いプロジェクトのソースを見たがなんだこれは。</p>
            <p>＊</p>
            <p>本当に私が書いたのか？とコミットログを見たところ、ウィンドウ周りのソースをいじっていたのは2年くらい前のようだ。</p>
            <p>無駄に複雑になってるのはこの際無視するとしても、なんだか構成が頭悪い。</p>
            <p>std::unique_ptrの扱いにまだ慣れてなかったのだろうか？</p>
            <p>自前のデリータを作ればもっと分かりやすく書けそうな処理を見つけ、もやもやとした気分になった。</p>
            <p>自前のデリータが使えることを知らなかったわけではなさそうだ。</p>
            <p>ウィンドウの他のデータに関してはそれを使っているところもある。</p>
            <p>やはり、昔の自分のソースは他人のソースなのだな。</p>
            <p>わけがわからないよ。</p>
        </div>
        <hr />
        <div>
            <h2>2016/04/09 00:50</h2>
            <p>困ったな、どっから作り始めたものか。</p>
            <p>＊</p>
            <p>やはりベースシステムメイン関数か？</p>
            <p>データはどういう処理にするのかが決まらんことには構成しようもないし。</p>
            <p>データに対する処理はベースシステムデータ構築時と、ゲームによる初期処理の2つあるが、それは後にするべきだろうな。</p>
            <p>とりあえず表示に関する部分から始めるべきか。</p>
            <p>ウィンドウ生成処理を古いプロジェクトから持ってきて構成するか。</p>
        </div>
        <hr />
        <div>
            <h2>2016/03/31 00:40</h2>
            <p>さくっとできそうだったから、ベースシステムメイン関数についての修正は昨日のうちに終わらせた。</p>
            <p>＊</p>
            <p>で、今日はゲームの初期化処理についての修正をやった。</p>
            <p>とりあえずこれを0.8.0とする予定だけど、テストで使用するモジュールとか、その辺もうちょい整えたいな。</p>
            <p>明日それをやってから0.8.0としてpushし、先に進もう。</p>
        </div>
        <hr />
        <div>
            <h2>2016/03/29 21:25</h2>
            <p>もやもやが多少消えたからか、やる気出てきた気がする。</p>
            <p>＊</p>
            <p>既存のゲームデータ生成、破棄処理をほぼそのまま引っ張ってきて、ベースシステムデータ生成、破棄処理を追加した。</p>
            <p>次はベースシステムメイン関数の引数にベースシステムデータを参照を追加し、利用できるように修正しよう。</p>
            <p>現状ではmain()でcandymaker::Basesystem内のベースシステムメイン関数を直接呼び出しているが、ベースシステム実行関数を別に作った方がいい気がする。</p>
            <p>main()でベースシステムデータを直接参照するのはレイヤーが違うと思うし。</p>
            <p>それが終わったらゲームの初期処理についてか。</p>
            <p>こっちは、今の構成は破棄して新しい構成にするわけだから、まずは別のソースファイルに作った方がいいだろうな。</p>
        </div>
        <hr />
        <div>
            <h2>2016/03/29 00:50</h2>
            <p>さすがにモジュールの扱いを段階分けするのは完了している。</p>
            <p>＊</p>
            <p>しかしモジュールの依存情報の解釈についてはまだ。</p>
            <p>というより、色々考えてたらこれもう後回しでいい感じがしているので放置。</p>
            <p>ゲーム生成処理をベースシステム関数内でやるとかいうのもありえんのでやらない。</p>
            <p>それしたところで、大した違いもないだろう。</p>
            <p>＊</p>
            <p>最近は、ゲームとベースシステムの構成が間違っているのではないかと考えている。</p>
            <p>ゲームはベースシステムにアクセスする必要があるが、そのうまい方法を思いつかない、というのが現時点での大きな問題点だ。</p>
            <p>色々考えた結果、ベースシステムがメイン関数のみの構成なのがいけないのだ。</p>
            <p>ベースシステムは処理だけでなくデータも持つべきだ。</p>
            <p>逆に、ゲームの方は初期処理だけでいい。</p>
            <p>ゲームにデータなど必要ない。</p>
            <p>そのように変更する場合、処理の大まかな流れは以下のようになる。</p>
            <p>＊</p>
            <p>1.ベースシステムデータ生成</p>
            <p>2.ゲームの初期処理</p>
            <p>3.ベースシステム実行</p>
            <p>4.ベースシステムデータ破棄</p>
            <p>＊</p>
            <p>2は引数としてベースシステムデータの参照を受け取り、それに対して処理を行なう。</p>
            <p>3はゲームが動作している段階で、4はゲーム終了後の後処理となる。</p>
            <p>＊</p>
            <p>さて、どのように作業を進めたものか。</p>
            <p>まずはベースシステムデータの生成、破棄を進めるべきか。</p>
            <p>これ自体はただの処理追加なので、楽にできるだろう。</p>
            <p>むしろそれを先にやっておかないと、他の変更はベースシステムデータの存在が前提なので作業を進めにくくなりそう。</p>
            <p>ベースシステム関数の引数にベースシステムデータの参照を追加するのもそうだし、ゲームの初期処理についてもベースシステムデータの参照を引数として渡す。</p>
            <p>それらが完了したら、ゲームからベースシステムにアクセスできるようになるわけだし、いい加減ゲームやベースシステムの方の作成に移ろう。</p>
            <p>candymakerをいじくるのはうんざりしてきているのだ。</p>
            <p>モチベーションが一向に上がらない原因はそこだと考えている。</p>
        </div>
        <hr />
        <div>
            <h2>2016/02/06 00:10</h2>
            <p>書こうとして、またも違和感。</p>
            <p>＊</p>
            <p>設定ファイルに関係する処理が置かれているディレクトリの方にソースを配置すると言ったが、それもおかしい。</p>
            <p>設定ファイルの解析処理に関係する処理なんて書かんのだから、そんなところに配置するのは不自然だ。</p>
            <p>設定ファイルについては、解析結果を参照するだけだ。</p>
            <p>ならば設定ファイルのソースが配置されているディレクトリと同列辺りに配置するのが筋だろう。</p>
            <p>昨日は違うか、と言っていた方が正しいような気がしている。</p>
            <p>やはり頭が茹で上がるとまともな思考にならん感じある。</p>
            <p>多少時間がかかっても、深く考えを巡らせるべきだろうか。</p>
            <p>そんな考えを認めてしまうと、考えるだけで無駄に時間が過ぎる気がするから、認めたくはないのだが。</p>
            <p>＊</p>
            <p>ふと思いついて、linuxのインストールCDに含まれているメモリチェックツールを使ったところ、やはりメモリがもうだめな雰囲気だった。</p>
            <p>gccがSEGVで死ぬのはおそらくそれが原因だろう。</p>
            <p>むしろ、それ以外ではほぼ問題が起こっていない理由が分からない。</p>
            <p>並列コンパイルとか高負荷の処理を流さん限り使わないような箇所がおかしくなっているのだろうか。</p>
            <p>ともあれ、運が悪いとemergeがこけるというのがいい加減嫌になってきたし、原因がメモリであろうことも特定できたので、交換することにした。</p>
            <p>今使ってるのは、安いからという理由だけでよく知らんメーカーのメモリを使っていたので、今回はトランセンドにする。</p>
            <p>これまた比較的安い気がする、というのも決めた理由の一つだけど。</p>
        </div>
        <hr />
        <div>
            <h2>2016/02/04 23:50</h2>
            <p>どうにもうまくまとまらんと思ったら、モジュールの扱いが低レイヤーすぎるのがいけないんだろうな。</p>
            <p>＊</p>
            <p>パッケージ情報ファイルに依存情報の追加はしたのだが、それをどう扱ったものか考えていた。</p>
            <p>現在、モジュールのロードについては、モジュールのパスを引数にして行なっている。</p>
            <p>依存情報を扱うなら、例えば依存情報も引数として渡し、そっちのロードを先にやる、という形になるだろうが、現状だとそれはまず無理だ。</p>
            <p>モジュールのパスというのはつまり、設定ファイルの内容を解釈した後のものだ。</p>
            <p>モジュールのロード処理中では、設定ファイルを解釈するような処理を行なっていない。</p>
            <p>依存情報というのは設定ファイルレベルの情報なので、そんなものを渡したところで扱いようがないのだ。</p>
            <p>ならばモジュールのパスではなく、設定ファイルレベルのモジュール名やら設定ファイルの内容やらを渡せばいいかもしれないが、それはしたくない。</p>
            <p>少なくとも、最終的には現在存在するモジュールのロード処理とかは必要になるのだ。</p>
            <p>それをわざわざ壊して複雑化させるなど間違っている。</p>
            <p>＊</p>
            <p>というわけで、モジュールの扱いについて、現在作ってある処理を利用する、より設定ファイル寄りの処理を追加するべきなのだろう、という結論に達した。</p>
            <p>結論に達するのが遅い気がする。やはりやる気が足りてない気がする。</p>
            <p>間に土日を挟んだり、健康診断で血を抜かれたりしたからといって、もうちょい早くその結論を出せたはずだ。</p>
            <p>それはともかく。ソースを見直したところ、現在あるモジュールを扱う処理だが、これはモジュールと言うよりローダーと言った方が正しい気がする。</p>
            <p>この辺は将来的にモジュール化して、様々な形式のモジュールを扱えるようにしたい箇所だし。</p>
            <p>だから名前を変えて、これから作る処理を新たなモジュールを扱う処理に…と思ったが、それもちょっと違うか。</p>
            <p>これから作るのは、設定ファイルの内容を解釈したりといった処理が入るから、そこに置くべきではないな。</p>
            <p>置くなら設定ファイルに関係する処理が置かれているディレクトリの方だ。</p>
            <p>危ない危ない。全く、先が思いやられる。</p>
        </div>
        <hr />
        <div>
            <h2>2016/01/28 17:05</h2>
            <p>やはり想定が甘い。</p>
            <p>＊</p>
            <p>モジュールの扱いのライブラリ化についてやるなら、暫定的、の部分をもっと細かく考えないと進められないな。</p>
            <p>依存関係解決についても、きちんとやるならパッケージ設定ファイルとか必要になるし。</p>
            <p>こちらも機能を限定した、暫定的なものから作っていくべきだろうな。</p>
            <p>やはり依存関係解決から作っていこう。</p>
            <p>パッケージ情報ファイルに依存情報を追加し、同一パッケージ内のみ対応、といった感じか？</p>
        </div>
        <hr />
        <div>
            <h2>2016/01/27 15:43</h2>
            <p>ベースシステムのメイン取得→ゲーム生成→ベースシステム実行という流れが違う気がしてきた。</p>
            <p>＊</p>
            <p>ゲーム生成関数の引数に、ベースシステムで使用するデータを渡すということは、そのデータを生成する必要があるけど、そのデータ生成どうすんの、という話だ。</p>
            <p>そこで考えたことには、ゲームの生成はベースシステムを実行してから、その中でやるべきか、ということ。</p>
            <p>これなら、ゲーム生成関数に渡すデータはベースシステム関数内で生成できる。</p>
            <p>しかし、ゲーム生成・破棄関数の取得までは定型処理だし、ベースシステム関数内でやるべきではないだろう。</p>
            <p>でも、それで本当にいけるか？ゲーム生成関数のシンボル名はベースシステムに依存するわけだし、関数の取得もベースシステム関数内でないとできないのでは？</p>
            <p>となると、モジュールのロードをしてからモジュールの参照をベースシステム関数に渡す？</p>
            <p>ということは、モジュールの型や関係する関数はライブラリ化する必要がありそうだなぁ。</p>
            <p>ライブラリ化については後回しにしたいところだが、それでできるだろうか？</p>
            <p>そもそも現時点での実装では、モジュールの依存関係解決などやっていないのだ。</p>
            <p>ライブラリだけ作ってもどうしようもない。</p>
            <p>＊</p>
            <p>色々と問題点が浮かび上がってきたな。とりあえずまとめてみよう。</p>
            <p>a.ゲーム生成処理の呼び出しをベースシステム関数内に移動</p>
            <p>b.モジュールの扱いをライブラリ化</p>
            <p>c.モジュールの依存関係解決</p>
            <p>こんな感じ？</p>
            <p>aを実現したいが、そのためにはbとcが必須。</p>
            <p>bは実現したところでcがないと活用できない。</p>
            <p>cは前提条件なし。</p>
            <p>bかcから始めよう。</p>
            <p>bはとりあえず暫定的なものでいいだろう。想定ではかなり簡単にできるはずだ。</p>
            <p>問題はcか。前のプロジェクトで似たような処理は作ったはずだから、それを活用できれば早いか？</p>
            <p>＊</p>
            <p>とりあえず現在の状態を0.6.0としてしまおう。</p>
        </div>
        <hr />
        <div>
            <h2>2016/01/26 01:25</h2>
            <p>ゲームの生成まではできた。</p>
            <p>＊</p>
            <p>しかし、このままでは生成ができるだけで、ベースシステムとはなんの通信もできない。</p>
            <p>どうするかなぁ。通信インターフェースを作るのまで含めるか、それともこの辺で、ソースを整えて0.6.0とするか。</p>
            <p>ソースを整えるのはやるとしよう。</p>
            <p>＊</p>
            <p>ベースシステムとゲームの通信はどうしよう。</p>
            <p>ベースシステムのメイン取得→ゲーム生成→ベースシステム実行としているが、ベースシステム実行時に生成したゲームを引数として渡すか？</p>
            <p>今の構想ではそれは向かないように思える。</p>
            <p>ベースシステムからゲームに対してアクションをかけるということは、ゲーム側に決まった関数でも定義しておかなければ難しいだろう。</p>
            <p>そして、ゲームにはできれば決まった関数というのは用意したくない。</p>
            <p>ゲーム側の必須関数は生成と破棄だけにしたいのだ。</p>
            <p>ゲーム側の生成関数の引数に、ベースシステムで使用するデータを渡し、そこにイベントハンドラを設定していく、という形になるだろうか。</p>
            <p>この形なら、決まった関数はベースシステム側に作られ、それを介してベースシステム側からゲーム側を操作できるようになるはずだ。</p>
        </div>
        <hr />
        <div>
            <h2>2016/01/19 00:50</h2>
            <p>お腹きゅうきゅうする。</p>
            <p>＊</p>
            <p>raspberrypiはそろそろもういいかなという感じ。</p>
            <p>というよりやりすぎた感じ。</p>
            <p>やりすぎちゃって、軽く燃え尽きちゃってる感じある。</p>
            <p>このままではいかんと思い、candymakerのソース眺めたりなどしていた。</p>
            <p>戻らねば。</p>
            <p>＊</p>
            <p>やりすぎたかいもあり、なかなかのものができた、と思うんだけど、最新の修正を適用したものの動作確認がまだ。</p>
            <p>1人では動作確認できないのが厳しいところだ。</p>
            <p>理論的にやってできないことはないはずなのだが、なぜかうまくいかなくて困る。</p>
        </div>
        <hr />
        <div>
            <p><a href="/">戻る</a></p>
        </div>
    </body>
</html>
