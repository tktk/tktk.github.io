<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>tekuto.net</title>
        <link rel="stylesheet" href="style.css" />
        <script type="text/javascript">
            var _gaq = _gaq || [];
            _gaq.push(['_setAccount', 'UA-23511137-1']);
            _gaq.push(['_setDomainName', '.tekuto.net']);
            _gaq.push(['_trackPageview']);

            (function() {
                var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
            })();
        </script>
    </head>
    <body>
<!--過去ログ用
        <div>
            <p><a href="/">戻る</a></p>
        </div>
-->
<!-- ここから過去ログ時に削除 -->
        <h1>tekuto.net</h1>
        <div>
            <p>メール:g.tekuto@gmail.com</p>
            <p><a href="http://twitter.com/tekuto" target="_blank">twitter</a></p>
        </div>
<!--テンプレート
        <hr />
        <div>
            <h2>YYYY/MM/DD hh:mm</h2>
            内容
        </div>
-->
<!-- ここまで -->
        <hr />
        <div>
            <h2>2017/06/14 02:30</h2>
            <p>ゲームパッドについても対応完了。</p>
            <p>＊</p>
            <p>明日は、ゲーム初期化より前にウィンドウを生成するように処理を変更する。</p>
            <p>それが済めばようやく、OpenGLの描画タスクを利用できるようになるな。</p>
        </div>
        <hr />
        <div>
            <h2>2017/06/13 03:30</h2>
            <p>なんとか、関数の追加はできた。</p>
            <p>＊</p>
            <p>fg::WindowInfoへのイベント関数及びユーザーデータ設定関数を追加して、さて古い関数を消して帳尻合わせるか、と思ったら他の部分にも追加が必要なことに気付いてやる気が下がった。</p>
            <p>fg::BasesystemArgsだ。</p>
            <p>とりあえず、そちらにもfg::WindowInfoに似た関数の追加を行なって、関数の追加については完了。</p>
            <p>古い関数の削除などは明日にする。</p>
            <p>＊</p>
            <p>想定外なことが起きるとやる気がぐーんと下がるの、よくないなぁ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/06/10 01:30</h2>
            <p>頭を絞って、どうにか便利そうなインターフェースになった気がする。</p>
            <p>＊</p>
            <p>イベント関数の設定と、イベント関数から参照できるユーザーデータの設定関数はそれぞれ別々に用意した。</p>
            <p>それだけだと、イベント関数で参照できるユーザーデータの型が分からず、void *をキャストする必要があり、ちょっと気分が悪い。</p>
            <p>そこで、可変長テンプレート関数を用意して、イベント関数とユーザーデータの設定を1つの関数で一気にできるようにした。</p>
            <p>この形にしたことで、イベント関数で参照するユーザーデータの型と、設定するユーザーデータの型を統一できるようになった。</p>
            <p>＊</p>
            <p>とはいえ、各設定関数の実装とテストがまだだ。</p>
            <p>来週の頭には済ませてしまいたい。</p>
            <p>問題ないようなら、同じ形でゲームパッドについてもちゃっちゃと実装してしまおう。</p>
            <p>そうすれば、ゲーム初期化より前にウィンドウを生成するように変更する作業に移れる。</p>
            <p>と思ったが、よく考えたらベースシステムの引数にイベント関数を設定する処理もあるんだったな。</p>
            <p>なかなか手間がかかりそうだ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/06/09 03:45</h2>
            <p>タスク生成関数のテンプレート修正完了。</p>
            <p>＊</p>
            <p>これによって、わざわざvoid *で渡されるユーザーデータをキャストして、とかやる必要がなくなった。</p>
            <p>違う型にキャストしてしまう、なんてミスも起こらなくなるし、いい感じ。</p>
            <p>＊</p>
            <p>さて、ウィンドウのイベントハンドラについて、インターフェースを修正しようと試しに記述したのだが、これでいいのか不安になる。</p>
            <p>タスク周りの修正がうまく行きすぎたから、相対的に見て微妙な感じに見えるだけだと思うのだが。</p>
            <p>＊</p>
            <p>実行時にデータを引き渡すタスクのようなもの、があれば便利かもしれない。</p>
        </div>
        <hr />
        <div>
            <h2>2017/06/08 04:10</h2>
            <p>苦戦したが、なんとかできた。</p>
            <p>＊</p>
            <p>OpenGLの描画タスク完成。</p>
            <p>それに伴って、タスクの型をちょっと修正した。</p>
            <p>OpenGLの描画タスクに加えた処理では自身を再度実行する可能性があるのだが、タスク内から再度自身を実行する、という処理ができなかったのだ。</p>
            <p>それができるように、型を修正して対応した。</p>
            <p>＊</p>
            <p>明日はタスク生成関数のテンプレートの定義修正から。</p>
        </div>
        <hr />
        <div>
            <h2>2017/06/07 01:30</h2>
            <p>さて、困ったことになった。</p>
            <p>＊</p>
            <p>現状では、インターフェースの変更についての修正をへびゲームに適用したので、動くようにはなった。</p>
            <p>しかし、OpenGLの描画タスクはまだ使えていない。</p>
            <p>ゲームの初期化時点ではまだfg::Windowが生成されていない、というのが問題だ。</p>
            <p>OpenGLの描画タスクは、生成関数の引数としてfg::Windowとfg::GLContextの参照を必要とする。</p>
            <p>fg::Windowが生成されていないゲーム初期化時点において、OpenGLの描画タスクを生成することができないのだ。</p>
            <p>＊</p>
            <p>しかしながら、ぱっと見た感じfg::Windowをゲーム初期化時点までに生成してはならない、というわけではないように見える。</p>
            <p>ゲーム初期化時にfg::Windowから呼び出されるイベントハンドラの生成などを行なっているため、それらを使うfg::Windowの生成はゲーム初期化の後、というだけの話だ。</p>
            <p>ゲーム初期化より前にfg::Windowを生成しつつ、ゲーム初期化時に生成したイベントハンドラが利用される形になれば、問題ないわけだ。</p>
            <p>そのくらいなら、ちょっと工夫すれば対応可能だろう。</p>
            <p>＊</p>
            <p>さて、どこから手を付けるかな。</p>
            <p>まずは、OpenGLの描画タスクについて、少し処理を追加する。</p>
            <p>それでOpenGLの描画タスクは完成とする。</p>
            <p>次にタスク生成関数のテンプレートの定義修正。</p>
            <p>それらが済んだら、ウィンドウとかゲームパッドのイベントハンドラについてのインターフェース修正かな。</p>
            <p>で、ベースシステムの処理を変更し、ゲーム初期化より前にウィンドウを生成する、と。</p>
            <p>大体そんな感じか。</p>
            <p>そこまでできれば、へびゲームでもOpenGLの描画タスクを使用できるようになるだろう。</p>
        </div>
        <hr />
        <div>
            <h2>2017/06/06 01:25</h2>
            <p>OpenGLの描画タスクについて、とりあえず自動テストは通した。</p>
            <p>＊</p>
            <p>明日、へびゲームで実際に使ってみよう。</p>
            <p>あと、タスク生成関数のテンプレートについて少し定義を変更する、というのもやる予定。</p>
        </div>
        <hr />
        <div>
            <h2>2017/06/03 03:00</h2>
            <p>タスク周りは完了した感じ。</p>
            <p>＊</p>
            <p>細かい修正と、タスク生成関数のバリエーション追加が完了したので、そこでバージョンを区切っておいた。</p>
            <p>ラッピングタスクの方はまだ。</p>
            <p>とりあえず、OpenGLの描画タスクを追加するつもり。</p>
            <p>このタスクによって、自前でfg::GLCurrentを生成したり、バッファのスワップをしたりということをしなくても済むようになる予定。</p>
            <p>OpenGLの描画タスク、と言っても単にfg::WaitThreadTaskを生成するだけだ。</p>
            <p>想定通りなら割と簡単に済むと思うのだけど、そううまくいくだろうか。</p>
        </div>
        <hr />
        <div>
            <h2>2017/06/02 03:40</h2>
            <p>やはり手間取った。</p>
            <p>*</p>
            <p>とはいえ、ファンクタを関数ポインタに変更するのは完了した。</p>
            <p>ただ、タスクを利用していた箇所に一部、このままだと違和感を感じる箇所があるので、そこは明日修正する。</p>
            <p>それが終わったら、タスク生成関数のバリエーション追加と、それを使ったラッピングタスクの追加、って感じか？</p>
            <p>そこまでやったら、前に作ったへびゲームを修正して動くようにしてみるか。</p>
            <p>前よりは整った記述になる、と思うのだけど。</p>
        </div>
        <hr />
        <div>
            <h2>2017/06/01 03:30</h2>
            <p>タスク起動インターフェースの修正が思ったよりも手間取ってしまった。</p>
            <p>＊</p>
            <p>なので、関数の呼び出し方変更についてはまだ。</p>
            <p>明日には仕上げる予定。</p>
            <p>あと、タスク生成関数のバリエーションを1つ追加する予定。</p>
            <p>タスクの関数から参照できるデータは、別の場所に格納されているデータの参照だけだが、タスクの中にデータを格納できるようにもしたい。</p>
            <p>そうしなければ、ラッピングしたタスクが作れなさそうなのだ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/05/31 03:15</h2>
            <p>いい調子だ。</p>
            <p>＊</p>
            <p>sucroseのタスク関係のソースファイルをベースシステム関係に統合完了。</p>
            <p>fgから、スレッドプール関係の記述を削除。</p>
            <p>あとは、タスク起動のインターフェース修正と、タスクで呼び出す関数をファンクタから関数ポインタに変える、といったところか。</p>
            <p>そのくらいなら、明日中にできるかな。</p>
        </div>
        <hr />
        <div>
            <h2>2017/05/30 03:30</h2>
            <p>もっと丁寧に進めることにした。</p>
            <p>＊</p>
            <p>とりあえず、sucroseのビルドルールを修正。</p>
            <p>自動テストのビルドで、sucroseで生成するライブラリとリンクすることでコンパイル回数を減らした。</p>
            <p>今までは依存しているソースファイルを全てコンパイルしていた。</p>
            <p>なので、ちょっとソースファイル追加するだけで色々な自動テストのビルドルールにソースファイルを追加しなければならず、面倒だった。</p>
            <p>今回の修正で、割と楽になったはず。</p>
            <p>candymakerの方もどうにかできるだろうか。</p>
            <p>＊</p>
            <p>で、fgのタスク関係のソースファイルをベースシステム関係に統合した。</p>
            <p>明日はsucrose側のソースファイルを移動し、統合する。</p>
            <p>そしたらインターフェースを修正し目標達成、の流れの予定。</p>
        </div>
        <hr />
        <div>
            <h2>2017/05/27 04:30</h2>
            <p>盛大に設計ミスってた。</p>
            <p>＊</p>
            <p>タスクについては作り直し。</p>
            <p>既存処理をちょっと改変すれば完了するので、最近書いた処理は全部削除。</p>
            <p>すごい徒労感。</p>
            <p>必死こいてある程度進めたけど、完了まではいけなかった。</p>
            <p>ちゃちゃっと来週前半に終わらせる。</p>
        </div>
        <hr />
        <div>
            <h2>2017/05/26 03:30</h2>
            <p>タスク管理も完成。</p>
            <p>＊</p>
            <p>やっぱりタスク管理で管理しないタスクは最終的に消してしまおうと思う。</p>
            <p>その前に、タスク管理まで作れたので既存処理の置き換え、削除を先にやる予定。</p>
        </div>
        <hr />
        <div>
            <h2>2017/05/25 03:15</h2>
            <p>待機タスクのキャンセラは作り終わった。</p>
            <p>＊</p>
            <p>タスク管理の方はちょっと構成を変えることもあって、今日中は難しかった。</p>
            <p>明日中には作り終えてしまいたいが。</p>
        </div>
        <hr />
        <div>
            <h2>2017/05/24 03:55</h2>
            <p>待機タスクについても作り終わった。</p>
            <p>＊</p>
            <p>あとは待機タスクのキャンセラとタスク管理。</p>
            <p>しかし、タスク管理で管理しないタスクというのは、使う機会あるんだろうか。</p>
            <p>いっそのこと、タスク管理で管理されたタスクだけでもいいのではないか。</p>
        </div>
        <hr />
        <div>
            <h2>2017/05/20 00:55</h2>
            <p>とりあえず、普通のタスクの方は作り終わった。</p>
            <p>＊</p>
            <p>来週中頃には待機タスクやタスク管理を作り終えたいところ。</p>
            <p>タスク管理の部分に関しては、ちょっと構成を変更する予定。</p>
            <p>複数のタスクが存在し、あるタスクから別のタスクを起動する、というようなことをやると、その別のタスクがすでに破棄されているのに起動しようとしてしまう、ということが起きかねない。</p>
            <p>そこでタスク管理というものを置き、それが存在している間は別のタスクの起動が成功し、破棄が始まれば起動が失敗するようになるので安全に複数のタスクを破棄できるようにしている。</p>
            <p>現状、これはタスクとタスク管理の2つを引数に取るタスク起動関数を使うことで対応しているが、これではタスク管理を用いていてもタスク管理を使用しないタスクの起動もできてしまう。</p>
            <p>後者はバグの温床であり、そういうことができない構成が望ましい。</p>
            <p>なので、ただのタスクとは別に、タスク管理によって管理されているタスク、というものを用意しようと思う。</p>
            <p>＊</p>
            <p>しかし、これをどのような位置付けにするか、ちょっと悩んでいる。</p>
            <p>型から別のものにしてしまうのが、確実な方法だろう。</p>
            <p>しかし、型は同じで、タスクで実行する関数をラッピングする、という方法でもできそうな気がする。</p>
            <p>その場合、ただのタスクと管理されているタスクを全く同じように扱うことができる。</p>
            <p>…が、そうすることによって何か得することがあるのか、というところに疑問が残る。</p>
            <p>型による判別ができなくなるため、むしろバグの温床になりそうな気が。</p>
        </div>
        <hr />
        <div>
            <h2>2017/05/18 01:30</h2>
            <p>やる気はびみょうだけど、ちょっとずつ進んでる。</p>
            <p>＊</p>
            <p>やはり、同じ名前の機能の追加はやりにくいな。</p>
            <p>仮の名前を置いて作業しないとうまくいかない。</p>
            <p>作り終えて、古い機能を削除するまでの辛抱だ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/05/16 03:25</h2>
            <p>モチベーションが上がらない。</p>
            <p>＊</p>
            <p>なので、別のところを進めることにした。</p>
            <p>基本的に、イベントハンドラという名前を使うことをやめることにする。</p>
            <p>大体これのせいで、ゲーム側のコードが長くなっているのだ。</p>
            <p>全てタスクで統一する形にしようと思う。</p>
            <p>現時点では汎用的に使える2種類のタスクがあるが、用途別にタスクを用意する。</p>
            <p>タスク内で使えるデータ、つまり引数が異なる感じだ。</p>
            <p>＊</p>
            <p>これに付随して、現時点ではスレッドプールというものをゲーム側から参照できるようにしているが、これもやめる。</p>
            <p>いちいちベースシステムのコンテキストからスレッドプールの参照を取得し、タスクを生成、なんてめんどくさいのだ。</p>
            <p>ベースシステムのコンテキストの参照を渡して生成してしまえばいいじゃないか。</p>
            <p>これに伴い、fg-threadはfg-basesystemに統合する。</p>
            <p>＊</p>
            <p>タスクで実行する関数は、C++だしファンクタ、std::functionで定義したものを使っていたが、Cの関数ポインタにしようと思う。</p>
            <p>そもそもテンプレートで定義するものを使うのは、なんだか気分が悪かったのだ。</p>
            <p>言語自体に用意されてるものの方が、何かと都合がよさそうな気がする。</p>
        </div>
        <hr />
        <div>
            <h2>2017/05/11 00:45</h2>
            <p>少し困ったことになった。</p>
            <p>＊</p>
            <p>ゲーム側で、fgなどのモジュールを使用するコードを含む部分について、自動テストコードを動かすことができない。</p>
            <p>モジュールのファイルパスを直接指定してリンクしてやれば動かせると思うが、それをどうやってビルドルールに組み込むか、という話になってくるな。</p>
        </div>
        <hr />
        <div>
            <h2>2017/05/09 01:45</h2>
            <p>突貫工事にはまるで向いてないな、この構成。</p>
            <p>＊</p>
            <p>とりあえず画面になんか表示しよう、と1ファイルにどんどん追加していったらすごくごちゃごちゃしてしまった。</p>
            <p>で、冷静になって一旦元に戻した。</p>
            <p>＊</p>
            <p>コントローラの設定のためのインターフェースは、まだまとまっていない。</p>
            <p>ゲームパッドを特定する情報と、押されたボタンを特定する情報があれば、とりあえずできるだろうか。</p>
            <p>その2つを、何番のコントローラに割り当てるのか、という情報と合わせて設定する感じで。</p>
        </div>
        <hr />
        <div>
            <h2>2017/05/02 02:10</h2>
            <p>画面作り始めた。</p>
            <p>＊</p>
            <p>ゲームパッドの扱いの改訂版を作るに当たり、どこから進めるべきか迷って、まず画面から始めることにした。</p>
            <p>ゲームパッドの初期設定を、画面見ながらいわゆるウィザード形式でできるようにする予定なので、画面がないと始まらないかな、と。</p>
            <p>ウィザードの説明文を表示するための機能が足りてないが、これは後回しでいいだろう。</p>
            <p>作っている私が把握できればいいので、適当に三角形でも表示しておけばいいのだ。</p>
            <p>＊</p>
            <p>問題は構成の方だ。</p>
            <p>かなり大掛かりで、ややこしい感じになりそうな気がする。</p>
            <p>うまいこと機能を分割して、小さく小さく作っていけたらいいのだが。</p>
        </div>
        <hr />
        <div>
            <h2>2017/04/29 03:40</h2>
            <p>体調が治ってきた。</p>
            <p>＊</p>
            <p>fg::ModuleContextがモジュース初期化より後でも使えることを確認した。</p>
            <p>adhocrepeaterを搭載したraspberrypiの調整をしたりなどもした。</p>
            <p>来週からセーブデータ機能を利用する処理の作成だな。</p>
        </div>
        <hr />
        <div>
            <h2>2017/04/26 03:10</h2>
            <p>fg::ModuleContextをモジュール破棄まで保持するように変更した。</p>
            <p>＊</p>
            <p>しかし、現状では初期化が成功するところまでしかテストコード書いてないな。</p>
            <p>明日、テストコードを追加して確認しよう。</p>
            <p>＊</p>
            <p>体調が思わしくない。</p>
            <p>気温が急激に変化したからだろうか。</p>
        </div>
        <hr />
        <div>
            <h2>2017/04/24 23:40</h2>
            <p>データ要素の文字列化についての修正をした。</p>
            <p>＊</p>
            <p>文字列への変換ではなく、ファイルデータ型に変換するように変更した。</p>
            <p>文字列化をするのはファイルに書き込むためだし、文字列化してからそれをファイルデータ型につっこむ、というのは回りくどいと思っていたのだ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/04/22 00:15</h2>
            <p>セーブデータの読み書き、とりあえず完了。</p>
            <p>＊</p>
            <p>とはいえ、これは暫定的な処理だ。</p>
            <p>まず、セーブデータディレクトリというものを用意していないため、セーブファイルはパッケージディレクトリに対して書き込まれるようになっている。</p>
            <p>それに加えて、データが平文なので容易に改竄できてしまう。</p>
            <p>＊</p>
            <p>しかしながら、とりあえずは機能するし次回からはセーブデータを必要とする機能の作成を、といきたいがまだちょっと無理だな。</p>
            <p>セーブデータの読み書きにはfg::ModuleContextが必要だが、fg::ModuleArgsから名前だけ変えただけの今の作りでは、モジュール初期化処理後にfg::ModuleContextは消滅してしまう。</p>
            <p>なので、ベースシステムが終了するまではfg::ModuleContextを保持しておくように変える必要がある。</p>
            <p>それ以外に、細かい修正もしておきたい。</p>
        </div>
        <hr />
        <div>
            <h2>2017/04/21 03:30</h2>
            <p>要素の文字列化は作り切った。</p>
            <p>＊</p>
            <p>セーブデータの書き込みと読み込み、明日中にいけるかな。</p>
            <p>新たに作る処理といえばファイル書き込みくらいだし、問題ないと思うけど。</p>
        </div>
        <hr />
        <div>
            <h2>2017/04/20 03:35</h2>
            <p>セーブデータの内容生成処理完成。</p>
            <p>＊</p>
            <p>次は要素の文字列化、そしてセーブデータ書き込みだな。</p>
            <p>明日中にそれを終わらせて、あさってに読み込みを作って完了、といけばきりがいいのだが。</p>
        </div>
        <hr />
        <div>
            <h2>2017/04/19 01:10</h2>
            <p>セーブデータの内容生成処理、もう少しで完成。</p>
            <p>＊</p>
            <p>残件は、リストやマップへの要素追加。</p>
            <p>現状の案では、引数のクローンを生成し、クローンを要素として追加する、という形が一番問題が起きにくいだろう考えている。</p>
            <p>そこが出来上がったら、いよいよセーブデータ書き込み処理に入る。</p>
            <p>要素の文字列化はまだやったことがないので、多少手間取るかもしれない。</p>
            <p>とはいえ、文字列からの解析処理に比べたらずっとましだろう。</p>
        </div>
        <hr />
        <div>
            <h2>2017/04/15 03:10</h2>
            <p>普通に考えて、セーブデータは書き込みが先だな。</p>
            <p>＊</p>
            <p>セーブデータを作成しないことには、読み込み機能なんて作っても意味ないし。</p>
            <p>やる気のせいもあって、今日はインターフェースを整えただけで終わってしまった。</p>
            <p>来週中には読み書きをできるようにしたいところ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/04/14 03:20</h2>
            <p>不要になった処理の削除完了。</p>
            <p>＊</p>
            <p>fg::FileR、fg::DirPathR、fg::ModuleArgsを削除した。</p>
            <p>パッケージ内に配置したファイルの読み込みがやりやすくなって、いい感じ。</p>
            <p>明日はセーブデータの読み込みをやる予定だけど、ちょっと構成をいじる必要がある気がする。</p>
        </div>
        <hr />
        <div>
            <h2>2017/04/13 02:50</h2>
            <p>既存処理の改訂版作成は完了。</p>
            <p>＊</p>
            <p>差し替えと既存処理の削除は、なかなか規模が大きいこともあり、やはり完了できなかった。</p>
            <p>特に、モジュール初期化関数の引数変更については、変える必要がある自動テストがあるし、ちょっとめんどう。</p>
            <p>明日には完了したい。</p>
        </div>
        <hr />
        <div>
            <h2>2017/04/12 03:20</h2>
            <p>進め方を少し間違えた。</p>
            <p>＊</p>
            <p>その関係で、ちょっと進行が遅れた。</p>
            <p>明日中には、処理の改訂と不要になった部分の削除を済ませてしまいたいが。</p>
        </div>
        <hr />
        <div>
            <h2>2017/04/11 02:55</h2>
            <p>パッケージ内のファイル取得処理の改訂版をとりあえず作った。</p>
            <p>＊</p>
            <p>fg::FileRやfg::DirPathRはいらなくなるので、その辺の処理も消して簡略化する予定。</p>
            <p>セーブデータ読み込み処理は、既存部分の改訂を済ませてからだな。</p>
        </div>
        <hr />
        <div>
            <h2>2017/04/07 02:30</h2>
            <p>いまいちしっくりこない。</p>
            <p>＊</p>
            <p>でもまぁ、こんなものだろう。</p>
            <p>パッケージ内のファイル取得と、セーブデータ読み込みについてのインターフェースを追加。</p>
            <p>とりあえずこれで作ってみようと思う。</p>
            <p>この構成なら、ファイル関係のモジュールがいらなくなるが処理自体は1つのモジュールに収めておけば済む形にできるな。</p>
        </div>
        <hr />
        <div>
            <h2>2017/04/06 03:50</h2>
            <p>パッケージ内のファイル取得インターフェースも変えるべきな気がしている。</p>
            <p>＊</p>
            <p>ファイルを開いてそれを読み込む、などということをいちいちやるようなインターフェースは違和感がある。</p>
            <p>処理が低レイヤーすぎる。</p>
            <p>いちいちそんなことをしなくても、ファイル取得といえばファイルの内容を全て読み込む以外にすることなんてないのだし。</p>
            <p>もっと単純な形でいいはずだ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/04/05 02:45</h2>
            <p>ヘッダファイルの問題は解決。</p>
            <p>＊</p>
            <p>あれ、よく考えたら今日追加したのはセーブデータの内部フォーマット作成関係のインターフェースじゃないか。</p>
            <p>いかんな、作業間違えてた。</p>
            <p>セーブデータ読み込みインターフェースを作らないと。</p>
        </div>
        <hr />
        <div>
            <h2>2017/04/04 03:30</h2>
            <p>やれやれ。</p>
            <p>＊</p>
            <p>既存処理の差し替えは完了。</p>
            <p>ユニークポインタ周りで不具合があった。</p>
            <p>ひとまず問題が起こらないようにしたけど、根本的な解決はまだ。</p>
            <p>ヘッダファイルのインクルードを忘れると、ビルドは通るが実行しようとするとリンクエラーで実行できない、という現象が発生している。</p>
            <p>どうすればいいのか大体は把握できているので、明日中には直す。</p>
        </div>
        <hr />
        <div>
            <h2>2017/04/01 02:30</h2>
            <p>セーブデータの内部フォーマット解析処理作成完了。</p>
            <p>＊</p>
            <p>来週から既存処理との差し替えと、セーブデータ読み込みインターフェースの整備と。</p>
            <p>そんな具合に進めていく予定。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/31 03:15</h2>
            <p>完了の目処はついた。</p>
            <p>＊</p>
            <p>明日中には、セーブデータの内部フォーマット解析処理を作り切れるはず。</p>
            <p>文字列について、処理を改良した上で完了した。</p>
            <p>同じような感じで、リストとマップを対応すれば完了。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/30 04:15</h2>
            <p>想像以上に処理がびみょう。</p>
            <p>＊</p>
            <p>処理どころかテストもびみょう。</p>
            <p>なので、元の処理に手を加えていく形で対応しようとしている。</p>
            <p>やる気減退してるというのもあるけど、さすがに1日では無理だった。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/29 01:40</h2>
            <p>演算子オーバーロードなんて消滅してしまえばいいのに。</p>
            <p>＊</p>
            <p>それに付随するADLとかいう概念が邪魔をして、無駄に時間を使ってしまった。</p>
            <p>しかしそのかいあって、ユニークポインタの宣言と定義をfgにまとめることができた。</p>
            <p>fgとsucroseとcandymaker、それぞれ別々に記述してるのが気持ち悪かったし、いい感じ。</p>
            <p>＊</p>
            <p>セーブデータの内部フォーマット解析用インターフェースの定義はできた。</p>
            <p>といっても、既に処理まで作ってある、文字列、リスト、マップのみ。</p>
            <p>できてる部分の書き換えなら簡単にできるし、数値型なんて現時点ではいらないし。</p>
            <p>明日中にcandymakerに追加したい。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/28 00:45</h2>
            <p>やる気減退中。</p>
            <p>＊</p>
            <p>セーブデータについては、もっときちんと考えてから取り掛かるべきだと思った。</p>
            <p>インターフェースを定義することにより、ゲーム側が簡単にセーブデータを作成したり、作成したデータを読み込んだり、だけで済む話ではない。</p>
            <p>セーブデータのフォーマットを定めることにより、ゲーム外から参照した場合にもセーブデータ名などの情報を参照したり、コピーや削除などをできるようにしたい。</p>
            <p>簡単に言えば、PlayStationのメモリーカード管理画面のような、ああいった機能を実現できるようにしたいのだ。</p>
            <p>そう考えると、とりあえずファイル書き込み機能を作ってセーブデータのファイルを作れるようにしました、という対応は今後を考えるとあまり意味がないと思うのだ。</p>
            <p>もちろん、内部的にはそういった処理も必要になるので、完全に無駄になるというわけでもないと思うが。</p>
            <p>＊</p>
            <p>そういう意味では、現在のゲームパッドの対応もよくない。</p>
            <p>ゲームパッドの接続や切断、どのゲームパッドのどのボタンが押された、などといった情報を直接ゲーム側に渡してしまっている。</p>
            <p>デバイスとゲーム側との間に制御プログラムを挟み込むことにより、柔軟なことができるようにしたいのだ。</p>
            <p>しかし、そのためにはセーブデータの概念は必須だろうな。</p>
            <p>デバイスをどのように管理するか、という情報はセーブデータとして格納するのだから。</p>
            <p>＊</p>
            <p>ちなみに、セーブデータの内部フォーマットについては、設定ファイルのものを改良した上で流用しようかと考えている。</p>
            <p>現時点ではリストやマップといった構造を除くと文字列値しか扱えないので、数値も扱えるようにする。</p>
            <p>そして、ファイル形式としてテキスト形式以外にバイナリ形式にも対応する。</p>
            <p>さすがに、プレイヤーが簡単に参照したり改変したり、ができるのはどうかと思うし。</p>
            <p>暗号化したテキスト形式をバイナリ形式として扱えば手軽か？</p>
            <p>それだとゲーム外からの参照が困難になるな。</p>
            <p>暗号化要素という概念でも追加して、一部の要素のみ暗号化、ということができるようにするか。</p>
            <p>＊</p>
            <p>さて、どこから進めるか。</p>
            <p>fgに、セーブデータの内部フォーマット解析インターフェースを定義するところからかな。</p>
            <p>ひとまず暗号化については後回しで。</p>
            <p>既に作ってある設定ファイル解析処理を使い回して、処理を実装。</p>
            <p>それを作ると設定ファイル解析処理と内容が被るため、差し替え。</p>
            <p>セーブファイル読み込みインターフェースの定義、実装。</p>
            <p>セーブファイル書き込みインターフェースの定義、実装。</p>
            <p>そこまで済めば、セーブファイルが必要になる機能も手を付けられるだろう。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/25 02:50</h2>
            <p>とりあえずOpenGL関数追加完了。</p>
            <p>＊</p>
            <p>へびゲームがきちんと動作することも確認済み。</p>
            <p>これであとはセーブデータの読み書きもできるようにすれば、それらしいゲームを作れる気がする。</p>
            <p>＊</p>
            <p>しかしOpenGL対応は、現時点は仮対応だな。</p>
            <p>もっとちゃんとやるなら、使用するバージョンやら拡張機能やらをゲーム側が指定し、そのチェックなどをするべきだろう。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/24 03:15</h2>
            <p>昨日のうちに、ウィンドウに対する処理の追加は完了した。</p>
            <p>＊</p>
            <p>具体的には、タイトル設定とウィンドウサイズ固定。</p>
            <p>今日からOpenGL対応。</p>
            <p>過去のプロジェクトで作った処理を流用して追加しようとしている。</p>
            <p>＊</p>
            <p>それが終わったら次はなんだろう。</p>
            <p>セーブデータ対応だろうか。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/22 02:35</h2>
            <p>ファイル名などの修正も完了。</p>
            <p>＊</p>
            <p>今までハードコーディングしていた、ウィンドウサイズの設定を引数から設定するように変更。</p>
            <p>合わせて、ウィンドウ内全てに対する再描画要求関数も追加した。</p>
            <p>あとはウィンドウのタイトル設定くらいか。</p>
            <p>ウィンドウ情報へのウィンドウタイトル設定関数の追加も忘れていたようなので、合わせて追加する。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/18 04:10</h2>
            <p>大まかには完了。</p>
            <p>＊</p>
            <p>前に作ったへびゲームのsucrose版関数呼び出し箇所をfg版に変更し、動作するところまで確認できた。</p>
            <p>残件は、ファイル名の修正と一時的に付けた型名、関数名の修正。</p>
            <p>さすがにその程度であれば、2時間もあれば十分完了できるだろう。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/17 03:10</h2>
            <p>足りなかったりいらなかったり、を解消。</p>
            <p>＊</p>
            <p>OpenGL関係のfg版インターフェース定義もやった。</p>
            <p>実装作って、sucrose版消して、を明日中にできるだろうか。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/16 02:55</h2>
            <p>sucrose版の削除も予想以上に面倒だった。</p>
            <p>＊</p>
            <p>OpenGLに関係するものについてもfg版を作らなければいけないようだ。</p>
            <p>他にも、関数定義位置の不備や実装漏れなどがあったりするので、それらまとめて今週中に終わらせるのを目標にやろう。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/14 01:00</h2>
            <p>ゲームパッドの追加は、あとは実際にゲームパッドを扱う部分だけ。</p>
            <p>＊</p>
            <p>ちゃちゃっと追加すればベースコンテキストの方も対応できる。</p>
            <p>それが済めば、いよいよsucrose版の削除に移れる。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/11 01:00</h2>
            <p>ゲームパッドについてもfgに定義を追加しなければならなかった。</p>
            <p>＊</p>
            <p>今日中？無理無理。</p>
            <p>来週の火曜ぐらいまでには片付けたいところ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/10 02:50</h2>
            <p>いつか起きるだろうと思っていた事態の対処でかなり時間を食ってしまった。</p>
            <p>＊</p>
            <p>やはり、先に宣言していないと参照できないというのは面倒だ。</p>
            <p>しかし今日加えた修正により、この点については今後同様の問題が発生しないようにできたはずだ。</p>
            <p>明日中に残件を片付けられるだろうか。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/09 02:50</h2>
            <p>sucrose版の利用箇所をfg版に差し替えるのは後回し。</p>
            <p>＊</p>
            <p>ウィンドウ関係とベースシステム関係、fg版を追加していっている。</p>
            <p>ベースシステムの内部にウィンドウで生成をしているし、ウィンドウの内部でベースシステムの機能を利用している。</p>
            <p>循環参照のような形なので、なかなか追加が面倒だ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/08 00:50</h2>
            <p>想像以上に面倒だった。</p>
            <p>＊</p>
            <p>とりあえずスレッド関係についてはfg版作成完了。</p>
            <p>sucrose版の利用箇所を差し替えるのはまだ。</p>
            <p>今週中には、ウィンドウ関係についてもfg版の作成とsucrose版の利用箇所差し替えまで終わらせたい。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/07 02:50</h2>
            <p>ウィンドウに関する定義を、全てfgに追加した。</p>
            <p>＊</p>
            <p>sucroseの定義をfgに変えている最中。</p>
            <p>最小の修正で変更していくには順序があるので、ちょっと面倒だ。</p>
            <p>明日中には完了したい。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/04 02:45</h2>
            <p>やはりやる気がびみょう。</p>
            <p>＊</p>
            <p>ウィンドウと、ウィンドウ生成時に必要な情報をまとめた型に関する定義を追加した。</p>
            <p>sucroseではイベントハンドラ集合としていたものに、ウィンドウのタイトルとサイズの情報を追加した感じ。</p>
            <p>イベントハンドラ削除関数は使う機会があるとは思えないので追加していない。</p>
            <p>イベントハンドラ呼び出し関数は、実装するライブラリ内に用意すればいいと判断したので追加していない。</p>
            <p>最初に想定していたよりもシンプルな感じになりそう。</p>
            <p>来週の頭には、イベントハンドラの定義を全部追加してしまいたい。</p>
            <p>できれば、実装側も整えられればいいのだが。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/03 01:45</h2>
            <p>ウィンドウ周りを整えるに当たり、fgに定義を追加することにした。</p>
            <p>＊</p>
            <p>fg::newWindow()の引数にfg::BaseContextの参照があるのでその定義の追加が先。</p>
            <p>fg::BaseContextの関連関数のfg::getThreadPool()の戻り値がfg::ThreadPoolの参照なのでその定義の追加が先。</p>
            <p>といった具合で、とりあえずfg-threadを新たに作った。</p>
            <p>fg::BaseContextの定義をfg-basesystemに追加したし、明日からウィンドウに入る。</p>
            <p>現状ではウィンドウのタイトルは無し、幅や高さは固定で生成、ウィンドウのサイズ変更可能となっているので、その辺をどうにかできるように関数を定義する。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/02 01:45</h2>
            <p>ひとまず、ファイル読み込み処理統一を対応した。</p>
            <p>＊</p>
            <p>その他細かい修正もしたが、これ次何をやろう。</p>
            <p>ウィンドウ出せるし、ゲームパッドも扱えるし。</p>
            <p>ウィンドウについては、サイズ固定じゃなかったりといい加減な感じあるが。</p>
            <p>へびゲームを作ったりもできたわけだし、ようやくゲーム自体の制作に入れるのだろうか。</p>
            <p>その場合、何を作るかが問題になるなぁ。</p>
            <p>＊</p>
            <p>ウィンドウ周りをもう少しきちんとしたら、windows向けのモジュール生成をやるというのもいいかもしれない。</p>
            <p>それをできるようにするためにも、玄箱T4を使えるようにしたというのもあるし。</p>
            <p>＊</p>
            <p>ああ、現状だとOpenGL関数を直接呼び出してるんだっけ。</p>
            <p>それだとOpenGL使えない場面でも関数呼び出せちゃって気持ち悪いんだよなぁ。</p>
            <p>古いプロジェクトではその対応も入れてたし、ウィンドウ周りと合わせてそこをやってしまうか。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/01 01:00</h2>
            <p>rootfsはメモリ上で問題ない、というのが結論。</p>
            <p>＊</p>
            <p>USBメモリにrootfsを構築して玄箱T4を動かしたが、処理時間を計測したところそこまで差が出なかった。</p>
            <p>USBメモリ上のrootfsだと壊れる可能性があり、修復の手間などを考慮するとメモリ上に展開する方がいいだろう。</p>
            <p>＊</p>
            <p>メモリ上にrootfsを展開する場合、TFTPで別のマシンからダウンロードしてくるのだが、ダウンロードだけで30秒程度かかる。</p>
            <p>一度起動してしまえば関係ないとはいえ、多少長いのが気になっていた。</p>
            <p>その件に関しては、ジャンボフレームに対応するようにMTUとtftpコマンドのブロックサイズ指定で解決。</p>
            <p>ほんの数秒でダウンロードが完了するようになった。</p>
            <p>＊</p>
            <p>明日からcandymakerの開発に戻る。</p>
            <p>前に書いた内容だと、ファイル読み込み処理が2つあるからそれを片方に統一するところからやる、とか書いてある。</p>
            <p>しかしそれはやらずとも動いてるわけだし、後回しでいいような気もする。</p>
            <p>まぁ、どこから進めるかは明日状態を見てから決めよう。</p>
        </div>
        <hr />
        <div>
            <h2>2017/02/28 00:41</h2>
            <p>金曜日の時点でハードディスク搭載まではできた、のだが。</p>
            <p>＊</p>
            <p>sambaだけでは不十分な感じがある。</p>
            <p>アクセスしたユーザーでしかファイルにアクセスできないのは不便だ。</p>
            <p>ファイルサーバーとして使うなら問題ないんだけど、linuxのrootfs作る時など、ファイル権限をrootにしたい時もあるし。</p>
            <p>なので、そういった作業用にnfsも必要だと思った。</p>
            <p>＊</p>
            <p>というわけで今日、nfs、hdparm、NTPクライアントを追加したものを作った。</p>
            <p>機能としてはこれで十分なんだけど、rootfsをメモリ上に展開するのは、メモリが128MBしかない玄箱T4では厳しい感じがある。</p>
            <p>ファイル転送速度にも影響が出ているような。</p>
            <p>少なくとも金曜日の時点で、samba上にあるlinuxカーネルのビルドをしようとしてもうまくいかなかったし。</p>
            <p>TFTPでブートしてから、nfsかUSBメモリ上にあるrootfsで動作させて、メモリ上からは退避させようと思う。</p>
            <p>とりあえずはUSBメモリで対応するかな。</p>
            <p>それでファイル転送速度とかが改善されればいいのだが。</p>
            <p>スワップを使用していた時の使用量から考えると、90MBほどメモリが使えれば問題ないはずなのだ。</p>
            <p>まだ2月なわけだし、明日までは玄箱T4の件をやることにする。</p>
        </div>
        <hr />
        <div>
            <h2>2017/02/24 04:35</h2>
            <p>あとはハードディスクを搭載するだけ、になったはず。</p>
            <p>＊</p>
            <p>実際に動かしてみないことにはなんとも言えない。</p>
            <p>しかし、よく考えたらhdparm入れてなかった。</p>
            <p>まぁ、まだ起動しっぱなしにするわけでもないし。</p>
            <p>土日中にビルドしてしまうか。</p>
            <p>あとNTPクライアントも入れてなかったな。</p>
        </div>
        <hr />
        <div>
            <h2>2017/02/23 04:05</h2>
            <p>adhocrepeaterで複数のデバイスを扱えるようにした。</p>
            <p>＊</p>
            <p>しかし、実際に使ってみないことにはちゃんとできてるか分からない。</p>
            <p>週末に動作確認する予定。</p>
            <p>＊</p>
            <p>玄箱T4は、ディスクレスでの稼働と、ハードディスク4台の移植で完了としよう。</p>
            <p>ソフトウェア構成は明日中に完了させたい。</p>
        </div>
        <hr />
        <div>
            <h2>2017/02/22 04:25</h2>
            <p>玄箱T4のemerge完了。</p>
            <p>＊</p>
            <p>しかし困った。</p>
            <p>無線LANアダプタがきちんと動かない。</p>
            <p>ファームウェアがどうのとdmesgにはあるものの、きちんとsys-kernel/linux-firmwareは入れてあるし。</p>
            <p>対応していると思われるファームウェアも含まれてるしで、いまいち原因が分からない。</p>
            <p>そもそも玄箱T4に無線LANアダプタを付けるという構成がおかしいかもしれない。</p>
            <p>玄箱T4やらメインのマシンやらは、有線LANで構成すべきか。</p>
            <p>しかしそれ用にdhcpやらdnsやら、iptablesやらを用意するのは、これまた手間だなぁ。</p>
            <p>とりあえずは固定IPで、iptablesとかその辺はなしでやるか。</p>
            <p>＊</p>
            <p>その辺いじくってたりも並行してやっていたせいもあり、adhocrepeaterの進みはいまいち。</p>
            <p>ひとまず設定ファイルの追加項目について、テストを作った。</p>
            <p>明日中に完了させて、木金で玄箱T4の方も完了させたい。</p>
        </div>
        <hr />
        <div>
            <h2>2017/02/21 01:00</h2>
            <p>想定外に時間がかかっている。</p>
            <p>＊</p>
            <p>玄箱T4でemergeをしているが、想像以上に進みが遅い。</p>
            <p>昨日の夜からやっているので、せめて今日の昼頃には終わるかと思ったのに。</p>
            <p>distccでコンパイルは高速なマシンでやっているものの、それにしたって遅い。</p>
            <p>＊</p>
            <p>adhocrepeaterや玄箱T4の件は、2月中には決着させたい。</p>
            <p>adhocrepeaterの1ポート構成化も、やるべきなのかどうか。</p>
            <p>現状の2ポート構成でも、とりあえず問題はないわけだしなぁ。</p>
            <p>気になるところと言えば、扱えるデバイスの数ぐらいか。</p>
            <p>現状、1つのデバイスしか相手にできない。</p>
            <p>簡単な修正で解決できると思うし、そこぐらいはどうにかするか。</p>
            <p>＊</p>
            <p>3月からはcandymakerの方を進める予定。</p>
        </div>
        <hr />
        <div>
            <h2>2017/02/18 04:36</h2>
            <p>nfs？知らんな。</p>
            <p>＊</p>
            <p>カーネルとファイルシステムを、全て外部からTFTPでダウンロードして起動することに成功。</p>
            <p>起動後は全てメモリ上に配置されるため、有線LANの接続が必要なのは起動時のみ。</p>
            <p>起動中ずっと接続していなければならないnfsとは違う。</p>
            <p>＊</p>
            <p>ファイルシステムに関しては、gentooのstage3を展開したものをほんの少しいじったもので確認しただけ。</p>
            <p>なので、来週はそこをどうにかして、完成といきたいところだ。</p>
            <p>＊</p>
            <p>メモリ使用量は起動直後で40MB弱といったところ。</p>
            <p>まぁ、セットアッププログラムでインストールできるdebianはもうちょい多かった気がするから問題ないだろう。</p>
            <p>stage3をハードディスクに入れて起動した時には3MB弱だから多少気になるが、ファイルシステムが40MB近くあるのだから当然である。</p>
            <p>まぁ、mdraidやらsambaやら、必要なツールつっこんでも容量は大して変わらんだろう。</p>
        </div>
        <hr />
        <div>
            <h2>2017/02/17 04:30</h2>
            <p>動いた動いた。</p>
            <p>＊</p>
            <p>バージョン4.9.9のカーネルに、玄箱T4のカスタマイズパッチを適用したソースをビルドしたカーネルが玄箱T4で動作した。</p>
            <p>miconaplも一応問題なく動いていたようなので、おそらく問題なく手直しできたのだろう。</p>
            <p>しかし現状、miconaplはセットアッププログラムでインストールできるdebian上でなければ動作できていない。</p>
            <p>miconaplはバイナリだし、やはりこれもビルドツールのバージョンの差異の影響だろうか。</p>
            <p>とはいえ、公開されているマイコンの仕様書に沿って互換性のあるツールを自作すれば、この問題はクリアできるようだ。</p>
            <p>しかし、やりたかったのはファンの回転速度を落とすこと程度なので、そんなにすぐ作る必要もないだろう。</p>
            <p>＊</p>
            <p>明日中に、玄箱T4でnfs bootやnfs rootをできるようにしたいところだ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/02/16 04:30</h2>
            <p>玄箱T4の方をやってる。</p>
            <p>＊</p>
            <p>起動させるだけなら簡単にできるかと思ってたけど、そんなことはなかった。</p>
            <p>カーネルのビルドは問題なかった。</p>
            <p>FIT対応とかいうのも問題なく作れる。</p>
            <p>問題は、2.6.30.8のカーネルだとFATAL: kernel too oldとかいって起動でこける。</p>
            <p>ソースのバージョンに対して、gccとかのビルドツールが新しすぎるのかもしれないが、確証はない。</p>
            <p>新しいバージョンのソースならいけるかと思い、カスタマイズ分の差分を適用しようとしたら面倒なことになった。</p>
            <p>元のソースが古いせいか、構成が新しくなったせいでそのままでは使えない処理とか、そういうのが多くて手直しが必要になる。</p>
            <p>とりあえず、ビルドが通るようにしたいところだ。</p>
            <p>＊</p>
            <p>raspberrypiと同じく、ディスクレス環境にしたいがメモリ128MBだし。</p>
            <p>さすがにきびしい気がする。</p>
        </div>
        <hr />
        <div>
            <h2>2017/02/14 02:25</h2>
            <p>確認が取れたので0.2.0として確定。</p>
            <p>＊</p>
            <p>1ポート構成の0.3.0を作る前に、raspberrypiの方を先にやることにした。</p>
            <p>といっても、今日で完成した感じはある。</p>
            <p>他に何かなければ、adhocrepeaterの方に戻って0.3.0を、と行きたいところだけど。</p>
            <p>明日用事で出かけるし、今週中は厳しそう。</p>
            <p>構成自体、結構変える必要があるだろうし。</p>
        </div>
        <hr />
        <div>
            <h2>2017/02/11 03:40</h2>
            <p>別のポートを使用する構成が完成。</p>
            <p>＊</p>
            <p>したと思うんだけど、実際に使ってみないことにはなんとも言えないなぁ。</p>
            <p>多分大丈夫だと思うんだけど、1人ではなかなかテストしづらい。</p>
            <p>明日動作確認して、問題なければ0.2.0として確定。</p>
            <p>＊</p>
            <p>問題ないようなら、1ポート構成に修正する。</p>
            <p>それを来週中に完成させたら、とりあえず一段落にしたい。</p>
            <p>あまりadhocrepeaterばかりやっていても仕方ないし。</p>
            <p>＊</p>
            <p>adhocrepeaterの次は、raspberrypiと玄箱T4かな。</p>
            <p>しかし面倒だからなぁ。</p>
            <p>玄箱T4については、ぱぱっとできそうならやる、ぐらいだな。</p>
        </div>
        <hr />
        <div>
            <h2>2017/02/10 04:00</h2>
            <p>方針変更。</p>
            <p>＊</p>
            <p>試したこともないことを、急にやろうとするのは無茶だ。</p>
            <p>できないことはないだろうけど、奇妙な、後々手を付けにくい構成になってしまうだろう。</p>
            <p>なので、まずは簡単な作りのものを作ることにした。</p>
            <p>SSID転送用に、別のポートを使用する。</p>
            <p>これであれば、多少分かりやすい構成で作ることができる。</p>
            <p>もちろん、これは暫定的な構成の予定だ。</p>
            <p>うまくいったのを確認してから、効率のいい、よりよい構成に変更する。</p>
            <p>＊</p>
            <p>というわけで、その構成でSSID送信処理は作った。</p>
            <p>SSID受信処理ももう少しでできる。</p>
            <p>明日中にはSSID受信処理を完成させて、それを組み込む予定。</p>
        </div>
        <hr />
        <div>
            <h2>2017/02/08 19:40</h2>
            <p>SSID強制変更対応完了。</p>
            <p>＊</p>
            <p>やはり、比較的簡単に対応できた。</p>
            <p>ちょっと面倒に考えていたせいで多少手間取ったが、最終的にはシンプルにできたと思う。</p>
            <p>＊</p>
            <p>問題はSSID転送の対応だ。</p>
            <p>こちらはちょっと修正して完了、とはいかないだろう。</p>
            <p>デバイスのデータ中継に混ぜて転送する予定なので、その選別とか必要になる。</p>
            <p>それをどのように表現するかが問題だ。</p>
            <p>＊</p>
            <p>どんな変更を加えたところで、設定ファイルの項目追加はなさそうな気がする。</p>
            <p>名前変更くらいはあるかもしれないけど。</p>
            <p>ならば今日中に、今日までの変更で追加するべき項目の対応は済ませておくべきか。</p>
            <p>そうすれば、木金はSSID転送に集中できる。</p>
            <p>＊</p>
            <p>送信についてはどうとでもなるだろう。</p>
            <p>問題は受信だろうな。</p>
        </div>
        <hr />
        <div>
            <h2>2017/02/08 04:15</h2>
            <p>SSIDの履歴機能追加完了。</p>
            <p>＊</p>
            <p>pspautoconnector2に実装していた機能では無駄、というより不自然な処理があったので、それを省いた上で実装した。</p>
            <p>adhocrepeaterでは別の箇所で同様の処理をしているため、必要ないのだ。</p>
            <p>＊</p>
            <p>明日から、できれば明日中に、SSID強制変更の対応をする。</p>
            <p>方法については大体まとまっている。</p>
            <p>pspautoconnector2よりも機能を分割しているため、対応しやすそうな気がする。</p>
            <p>実際にやってみなければ、なんとも言えないが。</p>
            <p>＊</p>
            <p>しかし、自動テストはどうしよう。</p>
            <p>SsidChangerに強制変更用の関数を追加する、というのも違うし。</p>
            <p>SsidChangerのSSID変更関数の仕様変更で対応する形になりそうだな。</p>
            <p>その関数用のテストを作るか。</p>
        </div>
        <hr />
        <div>
            <h2>2017/02/07 04:15</h2>
            <p>v0.1.0として確定。</p>
            <p>＊</p>
            <p>今週中には、SSID変動に対応させたい。</p>
            <p>相手にSSIDを送信して、相手も同じSSIDに設定するところまで。</p>
            <p>とりあえず、SSIDの履歴機能を追加する。</p>
            <p>今のままでは、周囲に複数のネットワークが存在する場合に、順々にチェックしていくようなことができない。</p>
            <p>pspautoconnector2に実装済みの機能だし、明日中には完成させて次に行く予定。</p>
            <p>＊</p>
            <p>次というのは、SSIDの強制変更だ。</p>
            <p>特定のSSIDを検出したら、そのSSIDに強制的に変更する。</p>
            <p>＊</p>
            <p>その次はSSIDの転送機能だろうな。</p>
            <p>検出したSSIDの他者への送信と、他者から受信したSSIDの処理。</p>
            <p>そこまでできれば、SSID変動に完全に対応できるはず。</p>
            <p>ここまで、できれば今週中に。</p>
        </div>
        <hr />
        <div>
            <h2>2017/02/04 04:00</h2>
            <p>設定ファイルの読み込み完了。</p>
            <p>＊</p>
            <p>明日試しに動かしてみて、特に問題ないようならバージョン0.1.0のプロトタイプ完成。</p>
            <p>全体的な動作確認以外の確認事項としては、データ中継の効率に変化があるかどうか。</p>
            <p>データ中継処理を、前に作ったものから変えているためだ。</p>
            <p>効率が良くなっているといいのだが。</p>
        </div>
        <hr />
        <div>
            <h2>2017/02/03 04:10</h2>
            <p>残るは、データ送信機と受信機の設定。</p>
            <p>＊</p>
            <p>それ以外は一通り対応した。</p>
            <p>明日中には、今作ってある部分については設定ファイルをいじることで色々できるようになり、一応動かせる状態になるはず。</p>
            <p>あくまでプロトタイプであり、機能はまだまだ足りないが。</p>
            <p>＊</p>
            <p>かなり行き当たりばったりで作ってたpspautoconnector2と違って、比較的ソースが見やすい気がする。</p>
            <p>pspautoconnector2には引数10個以上の関数とかあってわけわからなかったし。</p>
            <p>その原因は設定ファイルのデータを1つ1つ引数で渡していた、というのもある。</p>
            <p>今回はその辺、設定の型ごと一気に渡す形に変えたので、引数が多くなりすぎず見やすい感じ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/02/02 04:00</h2>
            <p>設定ファイルの対応開始。</p>
            <p>＊</p>
            <p>テスト用データのビルドルールとか、その辺の動作がおかしかったり、記述が気に入らないので直したりしていたら多少手間はかかったが、とりあえず軌道に乗った。</p>
            <p>後は、設定データを追加し、それを読み込む処理の追加、読み込んだデータの使用。</p>
            <p>それを追加していけば完成する。</p>
        </div>
        <hr />
        <div>
            <h2>2017/02/01 04:00</h2>
            <p>というわけで、他者から受信したデータをPSPに送信する処理完成。</p>
            <p>＊</p>
            <p>明日から設定ファイルの読み込みと、読み込んだデータの使用。</p>
            <p>できれば全て作ってしまいたいけど、それなりに量あるしできるか分からない。</p>
            <p>設定ファイルの解析処理自体はpspautoconnector2のものを使うから、そこで詰まったりはしないが。</p>
        </div>
        <hr />
        <div>
            <h2>2017/01/31 00:30</h2>
            <p>ネットワークへの接続の確立処理ができたようだ。</p>
            <p>＊</p>
            <p>対象のSSIDが見つかるまでスキャンを繰り返すことで対応。</p>
            <p>変更するSSIDの選択処理については、とりあえずはなくてもどうにかなるし、後々追加する。</p>
            <p>PSPから受信したデータの送信処理はできたので、明日からは他者から受信したデータをPSPに送信する処理を作る。</p>
            <p>明日から、というか明日中に作ってしまいたい。</p>
        </div>
        <hr />
        <div>
            <h2>2017/01/28 04:30</h2>
            <p>蓄積されているデータからのSSID変更処理は一応完成。</p>
            <p>＊</p>
            <p>変更するSSIDの選択処理は作っていないため、そこは追加する必要があるけど。</p>
            <p>＊</p>
            <p>既存のネットワークに接続するにはSSIDの検索を行なえば、と昨日書いたが、やはりというかそこまで単純なものではないようだ。</p>
            <p>SSID設定後、あまりに速くSSIDの検索をかけてもうまく行かなかった。</p>
            <p>だから、何回か繰り返して検索処理をかける必要があるだろう。</p>
            <p>具体的には、設定したSSIDが見つかるまで。</p>
        </div>
        <hr />
        <div>
            <h2>2017/01/27 04:15</h2>
            <p>やはりアドホック接続についてはきちんと理解できていなかったようだ。</p>
            <p>＊</p>
            <p>アクセスポイントをanyに設定すれば既存のネットワークに接続するようになる、と思ったのだがそんなことはなかった。</p>
            <p>SSIDの検索を行なうべきだろうな。</p>
            <p>複数回行なう必要はない。</p>
            <p>1回行なえば、見つかり次第アクセスポイントのアドレスに変更されるようだ。</p>
            <p>iwlistならうまくいったが、iwlibを利用したプログラムでも同じ動くになるかどうかは分からない。</p>
            <p>明日試しに処理を追加してみよう。</p>
            <p>＊</p>
            <p>SSID変更要求の呼び出しは追加したが、蓄積されているデータからSSIDを変更する処理はまだ。</p>
            <p>この部分も明日作ってしまえればいいのだが。</p>
            <p>そうすれば、PSPから受信したデータの送信処理は完了になる。</p>
        </div>
        <hr />
        <div>
            <h2>2017/01/26 04:20</h2>
            <p>受信したデータが処理対象かどうかのチェック、完了。</p>
            <p>＊</p>
            <p>データを受信できなかった場合のSSID変更要求、関数作成完了。</p>
            <p>あとはそれの呼び出し処理追加と、すでに蓄積されているデータからSSIDを変更する処理の追加。</p>
            <p>これでPSPから受信したデータの送信処理は完了。</p>
            <p>次は、他者から受信したデータをPSPへ送信する処理。</p>
            <p>こっちは多少単純にできるはずだ。</p>
            <p>それが出来上がったら、設定ファイルの読み込みに取り掛かる。</p>
            <p>これをやらないと、とりあえずプロトタイプで使ってみる、ということができない。</p>
            <p>データの中継が完了すれば、とりあえず使える状態にはなるわけだし。</p>
        </div>
        <hr />
        <div>
            <h2>2017/01/25 04:00</h2>
            <p>やる気はびみょうだが、大枠はできたっぽい。</p>
            <p>＊</p>
            <p>残りは、受信したデータが処理対象かどうかのチェックと、データを受信できなかった場合のSSID変更要求。</p>
            <p>後者に関しては、とりあえず関数を追加する必要があるなぁ。</p>
            <p>前者はどうやって処理しよう。</p>
            <p>MACアドレスのチェックなんだけど、まぁmemcmp()しておけばいいか？</p>
        </div>
        <hr />
        <div>
            <h2>2017/01/24 04:00</h2>
            <p>型は全て作った。</p>
            <p>＊</p>
            <p>後は組み合わせて機能にするだけ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/01/21 03:00</h2>
            <p>UDPによる送受信と、生パケットの送受信ができるソケットをそれぞれ作った。</p>
            <p>＊</p>
            <p>あとは、パケットの配列の定義とパケットの配列を管理する型の作成。</p>
            <p>それができれば、PSPから受信したデータの送信処理が作れる。</p>
        </div>
        <hr />
        <div>
            <h2>2017/01/20 03:55</h2>
            <p>思うようにやる気が出なくてよくない。</p>
            <p>＊</p>
            <p>UDPによるデータ送出処理がまだ途中。</p>
            <p>パケットを管理する型は作った。</p>
            <p>ソケット通信をする型は明日中に全て作ってしまいたい。</p>
        </div>
        <hr />
        <div>
            <h2>2017/01/19 03:25</h2>
            <p>盛大に勘違いしていたようだ。</p>
            <p>＊</p>
            <p>SSID設定処理でSSIDの検出なんかいらない。</p>
            <p>アクセスポイントをanyに設定すれば、既存のネットワークに接続するようになるらしい。</p>
            <p>無理解から勝手なことやろうとしてた。</p>
            <p>簡単に言えば、昨日やったSSID検出処理の共通化は完全に無駄になった。</p>
            <p>モチベーションの低下がやばい。</p>
            <p>＊</p>
            <p>アクセスポイントをanyに、という情報も、実際に試して確認しただけなので、それが正しい仕様なのかどうかは分からない。</p>
            <p>anyじゃなくても、とりあえずアクセスポイントを何かしら設定すれば接続できたし。</p>
            <p>アドホック接続に関する詳しい仕様がどっかにまとまって書かれていればいいのだけど。</p>
            <p>その辺はRFCとかIEEEとかなんとかなんだろうか。</p>
            <p>＊</p>
            <p>そんなわけで、モチベーション下がりつつもPSPからデータを受信し、それを他者に送信する処理を作り始めている。</p>
            <p>必要な追加機能は、PSPからデータを受信するための生パケット取得用ソケットと、他者に送信するためのUDPソケット。</p>
            <p>あとは、一時的にパケットを溜め込むバッファもあった方がいいだろう。</p>
            <p>PSPからデータを受信する処理と、そのデータを他者に送信する処理はそれぞれ別のスレッドにする。</p>
            <p>バッファはその橋渡しだ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/01/18 03:15</h2>
            <p>想定以上にめんどくさい。</p>
            <p>＊</p>
            <p>SSID設定処理でもSSIDの検出を行なうため、SSID検出処理を共通化した。</p>
            <p>SSID検出スレッドの処理を、共通化したSSID検出処理で行なうようにするところまで完了。</p>
            <p>これで明日にはSSID設定処理にSSID検出を追加できる。</p>
            <p>＊</p>
            <p>多少やる気が落ちてきてるのも、やはり効率に影響している。</p>
            <p>次にやることまでちゃんと考えておかないと、モチベーションの維持ができんな。</p>
            <p>この次はいよいよ中継処理に入る。</p>
            <p>PSPから受信したデータを他者に送信する。</p>
            <p>pspautoconnector2にはなかった処理だ。</p>
            <p>PSPからデータが受信できなかったら、SSID設定処理に対してSSID変更しろ、と要求を投げる感じ。</p>
            <p>SSID設定処理には、まだそれに対応するための処理を作っていないので、合わせて機能追加をしていく。</p>
            <p>＊</p>
            <p>その次は他者から受信したデータをPSPに送信する処理か？</p>
            <p>で、検出したSSIDについて他者に送信する処理と、他者から受信したSSIDの処理。</p>
            <p>それでメインの処理は多分全部。</p>
            <p>後は設定ファイルの読み込みと、その適用。</p>
            <p>そんなところだろう。</p>
        </div>
        <hr />
        <div>
            <h2>2017/01/17 04:00</h2>
            <p>SSID設定処理作成中。</p>
            <p>＊</p>
            <p>とりあえず設定するだけならできたが、これ多分接続前にネットワークを検出している必要があるな。</p>
            <p>pspautoconnector2がうまく動いていない時があったのも、そのせいかもしれない。</p>
            <p>明日中には設定処理を作り終えたい。</p>
        </div>
        <hr />
        <div>
            <h2>2017/01/14 02:20</h2>
            <p>SSID検出に反応してSSIDを設定する処理を作っている。</p>
            <p>＊</p>
            <p>SSID検出に反応して、というイベント処理がもうちょいで出来上がる。</p>
            <p>イベント処理については、大体sucroseと同じような感じで処理している。</p>
            <p>来週の頭には、SSID設定処理まで仕上げたいなぁ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/01/13 01:40</h2>
            <p>周囲のSSIDを検出する処理を作った。</p>
            <p>＊</p>
            <p>pspautoconnector2ではチャンネルを考慮していなかったが、今回は一致するもの以外扱わないことにした。</p>
            <p>この方が、混線を防げていいだろう。</p>
            <p>＊</p>
            <p>次に作るべきは、SSIDの設定処理だな。</p>
            <p>しかし、目的のSSIDかどうか確認するにはデータを受信してみないと分からないしどうしよう。</p>
            <p>などと考えたが、今回はデータの転送もするんだし、その辺はそっちに任せるか。</p>
            <p>＊</p>
            <p>SSIDの設定については、大きく分けて2種類のルートで行なおうと思う。</p>
            <p>1つは、SSIDの検出に反応して行なう設定。</p>
            <p>もう1つは、ネットワークの切断に反応して行なう設定。</p>
            <p>まず前者から作り始める。</p>
            <p>後者はデータの読み取りができるようになってから。</p>
        </div>
        <hr />
        <div>
            <h2>2017/01/12 01:20</h2>
            <p>SSIDをまとめる型を作った。</p>
            <p>＊</p>
            <p>まだ完全ではないが。</p>
            <p>例えば、イベントハンドラを登録できるようにして、新しいSSIDがつっこまれた時に呼び出すようにしたい。</p>
            <p>が、それを作るのはもうちょい先でいい。</p>
            <p>明日には、周囲のSSIDを見つけ次第つっこんでいく処理を作る。</p>
        </div>
        <hr />
        <div>
            <h2>2017/01/10 23:30</h2>
            <p>pspautoconnector2の改良版、adhocrepeaterの開発に取り掛かっている。</p>
            <p>＊</p>
            <p>pspautoconnector2のソースを見てたら、テストコード全く書いてないしひどかった。</p>
            <p>adhocrepeaterはテストファーストでがんがんテスト作っていくことにする。</p>
        </div>
        <hr />
        <div>
            <h2>2017/01/07 00:35</h2>
            <p>パッケージ内のファイルを読み込めることを確認。</p>
            <p>＊</p>
            <p>具体的にどのディレクトリである、という情報に触れることがなく、いい感じ。</p>
            <p>最初はsucroseに作ってたけど、candymaker内に移動した。</p>
            <p>candymakerでパッケージパスを生成する必要があるためだ。</p>
            <p>＊</p>
            <p>candymakerに実装されているインターフェースについても、なんらかの処理が必要になりそうだな。</p>
            <p>現状何もしてないから、ロードするとcandymakerと競合してしまうモジュールもロード可能な状態になっていてよくない。</p>
            <p>あと、パッケージ情報ファイルなどを読み込むために書いたファイル読み込み処理はそのままになっている。</p>
            <p>今回追加したfgの仕様のファイル読み込み処理に置き換えて、古い処理は削除したいところだ。</p>
            <p>とはいえ、処理が被っていて気分悪い程度であり、なんらかの問題を起こしているわけでもない。</p>
            <p>他の作業を終えて、candymakerの作成に戻ってきた時に、最初にやるとしよう。</p>
        </div>
        <hr />
        <div>
            <h2>2017/01/05 17:52</h2>
            <p>年が明けてしまった。</p>
            <p>＊</p>
            <p>ファイル読み込み関係の処理作った。</p>
            <p>これを使ってパッケージ内のファイルにアクセスする。</p>
            <p>そこまでやったら一区切り付くし、別の作業をやりたい。</p>
            <p>pspautoconnector2の改修とか、放置してある玄箱T4を使えるようにしたりとか。</p>
            <p>今週中には終わらせて…って、あと1日しかないではないか。</p>
        </div>
        <hr />
        <div>
            <h2>2016/11/15 02:15</h2>
            <p>日数かけすぎたけど、設定ファイルに関数のシンボル情報を書かないようにする対応できた。</p>
            <p>＊</p>
            <p>その変更に対応するように、sucroseとかへびゲームとかを修正すれば完了。</p>
            <p>次はパッケージパスを利用してパッケージ内のファイルにアクセス、という本来やるべきだった作業に戻ろう。</p>
        </div>
        <hr />
        <div>
            <h2>2016/10/25 01:35</h2>
            <p>モジュール初期化時に情報を引数で渡すのはできた。</p>
            <p>＊</p>
            <p>ちょっと考えていたが、ゲームとベースシステムの情報を独立させているのはそのままでよかった。</p>
            <p>モジュール内に記述してしまうと、ショートカットファイルに記述する際にもモジュール名が必要になり、よくない。</p>
            <p>もう一方の関数のシンボル情報に関しては、予定通り進めよう。</p>
        </div>
        <hr />
        <div>
            <h2>2016/10/19 23:45</h2>
            <p>ひとまずテストの作成から。</p>
            <p>＊</p>
            <p>何を焦っていたのか知らないが、テストも作らずに始めようとしていた。</p>
            <p>なので、ひとまずテストを作った。</p>
            <p>明日にはそのテストを通す処理を実装するとしよう。</p>
        </div>
        <hr />
        <div>
            <h2>2016/10/19 00:45</h2>
            <p>久しぶり。</p>
            <p>＊</p>
            <p>まだ体調は不完全だが、今日無理しなければ明日には万全になるだろう。</p>
            <p>＊</p>
            <p>今更ながら、パッケージ情報ファイルの構成がおかしい気がする。</p>
            <p>おかしい点は2つ。</p>
            <p>1つは、パッケージ内のゲームとベースシステムの情報を独立させていること。</p>
            <p>まとめてあることで、見た目は分かりやすいが処理はしにくかった。</p>
            <p>それがどのモジュールに入っているのかという情報があるが、そもそもモジュール情報内に書いておけば済むことだ。</p>
            <p>もう1つは、ゲームやベースシステムの情報に関数のシンボル情報を含めていること。</p>
            <p>設定ファイルに記述する情報としては、ちょっと低レイヤーすぎる。</p>
            <p>設定ファイルには関数のシンボル情報を含めない形にした方がいいかもしれない。</p>
            <p>＊</p>
            <p>ちなみに、モジュール初期化時に渡すパッケージ情報に関するどうのこうの、もまだ終わっていない。</p>
            <p>正直、渡す内容についても再度検討するべきではと考えている。</p>
            <p>いっそ、パッケージ情報ファイルの中身も渡してしまった方が分かりやすいような。</p>
        </div>
        <hr />
        <div>
            <h2>2016/10/05 00:40</h2>
            <p>ひどくやる気が出ない。</p>
            <p>＊</p>
            <p>しかし、このままではまずいので直近でやるべきことをリストアップし、とりあえずfgに関数の宣言を追加した。</p>
            <p>明日はcandymakerにその関数の実装を追加するのをやろう。</p>
        </div>
        <hr />
        <div>
            <h2>2016/09/28 00:50</h2>
            <p>軽く熱が出ている。</p>
            <p>＊</p>
            <p>最近気温の変化が激しいので、それにやられたのかもしれない。</p>
            <p>作業しようにも頭が痛くてうまく思考がまとまらない。</p>
            <p>とりあえずいくつかファイルを追加したが。</p>
            <p>＊</p>
            <p>モジュール初期化時に渡すパッケージ情報に関する型を追加して、関数も追加しようと思ったけど、手順違うかも。</p>
            <p>パッケージ情報に含む情報として、パッケージディレクトリのパスがあるが、これもただの文字列とかでなく型を作る予定。</p>
            <p>なので、そっちの方を先にやるべきだろうな。</p>
        </div>
        <hr />
        <div>
            <h2>2016/09/24 01:25</h2>
            <p>やる気が出ない。</p>
            <p>＊</p>
            <p>とりあえず、関数の仕様だけまとめるプロジェクトとしてfgを作った。</p>
            <p>過去に作ったプロジェクトと同じ名前。</p>
            <p>ここに最初に追加するものは、やはりcandymaker内で使用する関数や構造体の宣言だろうな。</p>
            <p>sucroseのものについても宣言を追加するけど、量が多いし今やったら絶対だれる。</p>
            <p>そういうのは後回し。</p>
        </div>
        <hr />
        <div>
            <h2>2016/09/22 00:40</h2>
            <p>cmmainの記述を整えて、candymakerも試しにライブラリ化して動作するところまで確認。</p>
            <p>＊</p>
            <p>関数の仕様だけまとめたプロジェクトも必要な気がしてきている。</p>
            <p>今のままでは、モジュール初期化時にファイル読み込みをするためだけに、candymakerのヘッダファイルを読み込む必要があるし。</p>
        </div>
        <hr />
        <div>
            <h2>2016/09/21 03:25</h2>
            <p>コアライブラリのダミーを作って、それをロードし、関数が呼び出されるところまで確認。</p>
            <p>＊</p>
            <p>cmmainはとりあえずこんなところだろうな。</p>
            <p>明日からcandymakerの方を修正していく。</p>
        </div>
        <hr />
        <div>
            <h2>2016/09/15 01:45</h2>
            <p>やる気絶不調。</p>
            <p>＊</p>
            <p>とりあえず、cmmainとかいうプロジェクトを作った。</p>
            <p>あともう少しでコアライブラリのロードまでできる。</p>
        </div>
        <hr />
        <div>
            <h2>2016/09/08 23:30</h2>
            <p>昨日の時点で実験は済んでいる。</p>
            <p>＊</p>
            <p>今日から作業に入ろうとしたのだけど、どのように構成するのが最適なのか、色々考えていた。</p>
            <p>まず、candymakerのほぼ全てをライブラリ化したものとそれを読み込むメインプログラムは、別のプロジェクトにするべきなのか？</p>
            <p>前者はモジュール側から参照されることはあるが、後者にはそれがないため、分けるべきかもしれない。</p>
            <p>しかし、その場合双方の名前はどうしよう。</p>
            <p>そもそもcandymakerとかいう名前、あんまかっこよくないし別のに変えたい気もする。</p>
            <p>名前空間がcandymakerだとなかなか長いので、もうちょい短めので。</p>
            <p>＊</p>
            <p>少し考えたが、プロジェクトの分割はやろう。</p>
            <p>メインプログラムの方は、一度作ったら多分ほぼ修正しない感じになりそう。</p>
            <p>コアライブラリのロードと、メイン関数の呼び出しくらいしかやることないし。</p>
        </div>
        <hr />
        <div>
            <h2>2016/09/07 00:10</h2>
            <p>確実にやる気落ちてる。</p>
            <p>＊</p>
            <p>方針変更。昨日のはなし。</p>
            <p>candymakerのほぼ全てを共有ライブラリ化する。</p>
            <p>これにより、モジュールからcandymakerの関数を参照可能にする。</p>
            <p>＊</p>
            <p>こっちの方が、昨日の案よりずっと現実的だと思う。</p>
            <p>そういった構成が可能なのか、簡単なコードで実験しなければと思うのだが、まだやってない。</p>
            <p>明日にはやってしまう予定。</p>
        </div>
        <hr />
        <div>
            <h2>2016/09/05 17:00</h2>
            <p>思ったよりも大規模な変更が必要になりそう。</p>
            <p>＊</p>
            <p>モジュールロード時の初期化関数に渡すデータは、仮にパッケージコンテキストと呼称することにした。</p>
            <p>このパッケージコンテキストは、ゲームの初期化関数にも引数として渡す。</p>
            <p>そうしないと、ゲーム内からパッケージのファイルにアクセスする場合に、必ずモジュール初期化関数を用意しなければならず、面倒だ。</p>
            <p>＊</p>
            <p>と、そこまではいい。</p>
            <p>問題は、モジュールのロードを行うcandymakerで生成したデータの内部に、モジュール側からどうやってアクセスするのか、ということだ。</p>
            <p>パッケージコンテキストの仕様は後々変更することはもちろんあると思うので、メンバを直接アクセスするなんてのは現実的ではない。</p>
            <p>ではパッケージコンテキストに関するモジュールを作って、ってやるとそのモジュール初期化時にパッケージコンテキストを渡せないではないか。</p>
            <p>＊</p>
            <p>現在の構成として、candymakerは完全に独立している。</p>
            <p>ゲームやベースシステムは、candymakerが一方的にモジュールをロードし、関数を呼び出すだけであって、その呼び出された関数の中からcandymaker内のデータにアクセスするような仕組みを作っていない。</p>
            <p>なので、その仕組みを作る必要が出てきたな、という感じ。</p>
            <p>具体的には、candymaker内のデータにアクセスするための、ラッパーのようなモジュールを作ろうと思う。</p>
            <p>モジュールロード後に、ラッパーモジュール内に用意した初期化関数を呼び出し、candymaker内の関数にアクセスできるようにする。</p>
            <p>パッケージコンテキスト内のデータを参照するには、ラッパーモジュールの関数を呼び出し、その関数を経由してcandymaker内の関数にアクセス、データを参照する、といった流れ。</p>
            <p>＊</p>
            <p>さて、そんなに都合よくできるかどうか。</p>
        </div>
        <hr />
        <div>
            <h2>2016/09/03 00:45</h2>
            <p>パッケージ内のファイル読み込み方法考え中。</p>
            <p>＊</p>
            <p>ゲーム内で使うテクスチャであれば、BaseContextにパッケージのパスを追加しておけばいいかー、と思ったけど違う気がする。</p>
            <p>BaseContextは、読み込んだモジュールすべての関数が参照する可能性のあるものだ。</p>
            <p>パッケージが違っていても関係ない。</p>
            <p>そういう性質のものに対して、1パッケージのみに関係する情報を乗っける、というのは違和感がある。</p>
            <p>＊</p>
            <p>モジュールロード時のデータを追加するべきかもしれない。</p>
            <p>現状のモジュールロードは、初期化関数が指定されていれば、引数のないその関数を呼び出すだけ。</p>
            <p>これに対し、引数を付け加えるべきかも。</p>
            <p>その引数のデータとして、そのモジュールが属するパッケージのパスなどを乗っける。</p>
            <p>＊</p>
            <p>しかしその場合、そのデータはどうやって管理しよう。</p>
            <p>実体はモジュールをロードしたところに置いておいて、初期化関数でポインタをモジュールのグローバルに配置する、というのがセオリーだろうか。</p>
            <p>できるだけグローバルとか使いたくないんだけど、さすがにこれは仕方ない気がするなぁ。</p>
        </div>
        <hr />
        <div>
            <h2>2016/09/01 17:00</h2>
            <p>まずファイル入出力に対応することに決めた。</p>
            <p>＊</p>
            <p>セーブをできるようにするにも、テクスチャや音声を扱うにも、まずはファイルに対する入出力ができないことには始まらない。</p>
            <p>差し当たっては、どれを実現する目的で作ろうかな。</p>
            <p>音声はまだ無理だし、テクスチャかセーブデータか。</p>
            <p>現状、この前作ったへびゲームは、スコア表示が存在しない。</p>
            <p>描画が面倒だったので。</p>
            <p>比較的簡単にスコア表示を行なうために、テクスチャ読み込みに対応してもいいかもしれない。</p>
            <p>そしてハイスコアを保存するために、セーブデータに対応する、という形はどうだろう。</p>
            <p>＊</p>
            <p>まだセーブデータという概念自体作ってないわけだから、先にテクスチャに対応するのは道理かも。</p>
            <p>テクスチャはパッケージのディレクトリに置けばいいだけだし。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/31 00:35</h2>
            <p>ウィンドウクローズイベントハンドラ追加。</p>
            <p>＊</p>
            <p>ベースシステムに、メインウィンドウのクローズイベントの対応を追加し、メインウィンドウが閉じたら正常終了するようにした。</p>
            <p>付随して、起動中はwhile(1)によってCPU1コアの使用率が100%になってしまっていた状態も解消。</p>
            <p>きりがいいと思ったので、sucroseをv0.9.0とした。</p>
            <p>＊</p>
            <p>次はどこを進めようか。</p>
            <p>一度よく考えるべきだろうな。</p>
            <p>過去の記事を見直せば、ある程度計画のようなものも出てくるかもしれない。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/29 20:10</h2>
            <p>メインウィンドウやゲームパッドマネージャに対するイベントハンドラの設定方法を変更。</p>
            <p>＊</p>
            <p>これにより、とりあえずゲーム側のソースコードが50行少なくなった。</p>
            <p>まぁそれはおまけ程度であり、割とどうでもいい。</p>
            <p>＊</p>
            <p>メインウィンドウやゲームパッドマネージャに対し、特定のイベントハンドラの設定を阻止できるようにインターフェースを変更した。</p>
            <p>メインウィンドウのウィンドウを閉じる時のイベントハンドラなんかは、ゲーム側から触らせたくなかったので、想定通りに変更できて満足。</p>
            <p>＊</p>
            <p>とりあえず、ウィンドウを閉じるイベントに対応しようと思う。</p>
            <p>今のベースシステムは、ウィンドウを閉じた時の不正終了で落ちているので気に食わない。</p>
            <p>＊</p>
            <p>ちなみに、体の描画に付け足したい要素が、とかいうのは土曜に片付けておいた。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/27 03:10</h2>
            <p>体の描画と、衝突による進行停止、つまりゲームオーバーも作った。</p>
            <p>＊</p>
            <p>これで、とりあえずゲームとしての体裁は整ったはず。</p>
            <p>もうちょい、体の描画に付け足したい要素があるので、来週の頭にそれをやって、0.1.0としよう。</p>
            <p>＊</p>
            <p>実際にゲームを作ってみて、ベースシステム側の改善点も少し見えた。</p>
            <p>来週はその辺から手を付けていくか。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/26 02:00</h2>
            <p>へびが動くようになった。</p>
            <p>＊</p>
            <p>餌の配置と、餌を食って体が伸びるようになった。</p>
            <p>しかし、体の描画処理を行なっていないため、見た目にはほぼ反映されていない。</p>
            <p>そのせいもあって、食った後の挙動がこれで合ってるのか、ちょっと判断がつかない。</p>
            <p>＊</p>
            <p>でも体を描画するためのデータはできているわけだし、明日体の描画処理を作る。</p>
            <p>そして衝突判定も作り、明日中の完成を目指す。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/25 00:10</h2>
            <p>本格的に描画を開始した。</p>
            <p>＊</p>
            <p>とりあえず、へびと外壁を描画。<a href="images/201608250010_00.png" target="_blank">こんな感じ。</a></p>
            <p>テクスチャとかまだまともに使えるようにしてないし、というよりも面倒なので見た目がしょぼいのは仕方がない。</p>
            <p>緑色のがへび。</p>
            <p>左側の、ぱかっとなってる方が口。</p>
            <p>コントローラによる向き変更にも対応している。<a href="images/201608250010_01.png" target="_blank">こんな感じ。</a></p>
            <p>体の描画はまだなので、頭としっぽが千切れそうになってるのは仕方がない。</p>
            <p>＊</p>
            <p>それに、向き変更が可能なだけであってまだ動くこともできない。</p>
            <p>その処理はなんとか今日作ったので、明日動かしてみる予定。</p>
            <p>それがうまくいけば餌を食べて体を伸ばす処理と、餌の配置処理。</p>
            <p>最終的に外壁や体との衝突判定処理も追加する。</p>
            <p>そして、衝突でゲーム停止、つまりゲームオーバーになるようにすれば一段落といったところかな。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/24 00:40</h2>
            <p>ソースを機能ごとに分割した。</p>
            <p>＊</p>
            <p>へびの描画を先にやってから、それに対してコントローラ動かした時の挙動を付けていく形にしようとしたが、うまく行かず。</p>
            <p>どうも作る順を間違えたらしい。</p>
            <p>コントローラでどのようにデータを変動させるか決めないと、そもそもどのようなデータを用意するべきか、がはっきりしない。</p>
            <p>なのでコントローラの挙動の方が先だな。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/23 01:00</h2>
            <p>背景黒く塗ることはできた。</p>
            <p>＊</p>
            <p>別にそれ自体、全然難しくないんだけど。</p>
            <p>すぐにソースが肥大化しそうで、どうやって機能分割したものかと考えていた。</p>
            <p>しかしそれも大体見えてきたので、明日にはもっと機能分割し、手を付けやすくする予定。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/20 01:30</h2>
            <p>ゲームパッドイベントハンドラの設定処理も完了。</p>
            <p>＊</p>
            <p>次からイベントハンドラの中身を詰めていくわけだけど。</p>
            <p>基本的には、ゲームパッドの操作→描画処理、という流れになると思うけど、なにもしてなくてもへびを動かす処理も必要になる。</p>
            <p>なので、ゲームパッドとは別に待機処理を動かしておいて、一定時間ごとにへびを動かす→描画、という流れも必要になるだろう。</p>
            <p>ウィンドウ描画イベントについては、単に描画処理流すだけで問題ないはず。</p>
            <p>＊</p>
            <p>ゲーム自体の処理はそんな感じだけど、ゲームオーバーになったら処理の流れを変える必要があるだろうな。</p>
            <p>ゲーム開始前の画面は、とりあえずは省いてしまってもいいだろう。</p>
            <p>起動と同時に開始、ゲームオーバーでもう動かなくなる、みたいな感じ。</p>
            <p>あとから、タイトル画面とゲームオーバー時になんか押すとタイトルに戻る、といった処理を追加するか。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/19 00:35</h2>
            <p>やる気びみょうだけど、感覚はだいぶ戻ってきた。</p>
            <p>＊</p>
            <p>とりあえずウィンドウイベントハンドラ設定処理は書いた。</p>
            <p>描画イベントの処理は空っぽだが。</p>
            <p>ちゃっちゃとゲームパッドイベントの方も設定処理書いて、中身を詰めていきたい。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/17 15:50</h2>
            <p>そろそろcandymakerの開発に戻る。</p>
            <p>＊</p>
            <p>簡単なゲームを作ってみようと思う。</p>
            <p>現状、フォントファイルを読んで文字を出すとかできないし、かといって自分で線引いて文字書くのもめんどくさい。</p>
            <p>というわけで、そういった表示が必要なさそうなゲームを作る。</p>
            <p>＊</p>
            <p>思いついたのは、なんていうの？</p>
            <p>へびが餌食ってどんどん伸びていくあれ。</p>
            <p>あれなら得点などの表示がなくても問題ないし。</p>
            <p>あれ作る。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/16 00:45</h2>
            <p>というわけで中継ツールを作った。</p>
            <p>＊</p>
            <p>xlinkkaiだとゲームスピードが落ちてしまうゲームも、ローカル内での中継ではさすがにスピードが落ちなかった。</p>
            <p>ネット越しの中継をした場合どうなるかは、まだ確認していない。</p>
            <p>＊</p>
            <p>xlinkkaiでどうしようもないくらい遅延していたゲームは、ローカルでの中継の時点で既にどうしようもないくらい遅延してた。</p>
            <p>もしやデータ到着順が入れ替わったりとかいう、UDPで起きるらしい現象が頻発してこんなことになっているのでは、と思いTCP版を作ってみたが変わらず。</p>
            <p>他のゲームの場合、ローカル内で中継する限りではUDP版とTCP版、どちらでもこれといった違いは見られなかった。</p>
            <p>なんなんだろう。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/15 13:00</h2>
            <p>pspautoconnector2は想定通りに動いているようだ。</p>
            <p>＊</p>
            <p>しかし、一部のゲームでゲーム性が変わってしまう程度にゲームスピードが遅くなってしまうのが気に食わない。</p>
            <p>これはpspautoconnector2ではなくxlinkkaiの問題だと思うけど。</p>
            <p>というわけで、xlinkkaiの代わりのツールを簡単に作ってみようかと。</p>
            <p>＊</p>
            <p>昨日試した限りでは、パソコンに無線LANアダプタを2つ差して、2台のPSPとそれぞれ通信し、単純にデータを中継すれば、チャンネルが違っていても通信が可能ということが確認できた。</p>
            <p>その中継を行なうために作ったプログラムに多少手を加えれば、遠隔地とP2P通信するためのツールにできるはずだ。</p>
            <p>＊</p>
            <p>とはいえ、xlinkkaiもおそらくP2P通信なんだよなぁ。</p>
            <p>ポート開放が必要なのも、きっとそのためだし。</p>
            <p>しかし、その通信部分の処理が甘くて処理遅延の原因になっているとすれば、改善の余地があるかもしれない。</p>
            <p>まぁ、やるだけやってみよう。</p>
            <p>今日1日で完成させられると思うし。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/10 03:00</h2>
            <p>無理なダイエットはよくないと思った。</p>
            <p>＊</p>
            <p>pspautoconnector2がきちんと動作していない原因が判明。</p>
            <p>無理に環境全体のサイズを小さくしようとした環境を使っていたことが原因のようだった。</p>
            <p>ようだった、というのはそうでない環境を使ったらきちんと動作するようになった、というだけなので、他の原因ということも考えられる。</p>
            <p>しかし、その2つの環境の相違点は、より多くのプログラムをbusyboxへのシンボリックリンクに差し替えていることが大きいので、やはりその辺が原因かな、と。</p>
            <p>他にも、xlinkkaiのエンジンの停止でこけるなどしていたので、無理に小さくしようとした環境は今後使わないようにする。</p>
            <p>必要がなくなったらすぐ消そう。</p>
            <p>＊</p>
            <p>起きたら、新たに作ったmicroSDの動作確認をする予定。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/09 03:45</h2>
            <p>過去にやったことをすっかり忘れていた。</p>
            <p>＊</p>
            <p>カーネルモジュールのソースに修正を加えていた件について忘れていたこともあり、あまり進まなかった。</p>
            <p>とりあえずカーネルモジュールは使えるようになった、はず。</p>
            <p>＊</p>
            <p>しかし、pspautoconnector2がきちんと動作していない。</p>
            <p>いや、期待通りの動作はしていると思うのだが。</p>
            <p>SSIDとチャンネルはきちんと設定されているので、そこに至るまでにPSPのネットワークも検索しているはずなのだが、既存のネットワークに繋がず新しいネットワークを作っていて接続できていない。</p>
            <p>アドレスを指定する処理も必要なんだろうか。</p>
            <p>とりあえず明日追加してみるけど、それでうまくいくのかどうか。</p>
        <hr />
        <div>
            <h2>2016/08/08 00:15</h2>
            <p>今日設定ファイルいじくったので1.0.0にした。</p>
            <p>＊</p>
            <p>pspautoconnector2はとりあえず一区切り。</p>
            <p>次は自動生成したgentooの小型化するスクリプトを作るつもり。</p>
            <p>だけど、とりあえず前に作ったやつを差し替えて試してみようかな。</p>
            <p>正直、そんなに簡単にできるような作業でもないと思うのだ。</p>
            <p>なかなかに期限も迫っているし。</p>
            <p>＊</p>
            <p>pspautoconnectorについては、また新たな問題が浮上した。</p>
            <p>SSIDが変動する一部のゲームで、接続がうまくいかない。</p>
            <p>PSPのSSIDを変動させる前に、対象のSSIDを検索する処理を行なっているらしく、PSPが変動後のSSIDに変わらないのだ。</p>
            <p>簡単に言えばpspautoconnectorと同じ動きをしている。</p>
            <p>双方、変動後のSSIDを探そうとするけれど見つからないので、接続がうまくいかない。</p>
            <p>解決するには、パソコンの無線LANアダプタのSSIDを変更する必要がある。</p>
            <p>＊</p>
            <p>一番簡単な手段としては、手動変更だろう。</p>
            <p>しかし、それを自動化したくてpspautoconnectorを作ったわけで、それをしては意味がない気もする。</p>
            <p>とはいえ、それすらも自動化したい、となると、pspautoconnector同士で通信を行なう必要が出てくる。</p>
            <p>親のPSPについては、子のPSPが接続するために自動でSSIDが変動する。</p>
            <p>それを検知したpspautoconnectorは、他のpspautoconnectorに通知し、SSIDを変更させる、といった具合だ。</p>
            <p>でもそれをするとなると、中継するサーバーを何かで作るとかか、P2P通信するとかが必要になって、かなり大掛かりになる。</p>
            <p>難しいところだ。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/06 03:45</h2>
            <p>大きな勘違いをやらかしていたため修正。</p>
            <p>＊</p>
            <p>疲れた。</p>
            <p>設定ファイルの要素をいじくったら1.0.0にする予定。</p>
            <p>休日はできるだけ作業しないようにしているが、明日にやってしまおうかな。</p>
            <p>＊</p>
            <p>しかし、めちゃくちゃな作り方したのでソースがとても汚ない。</p>
            <p>次からは絶対こんなことしないよ。</p>
        <hr />
        <div>
            <h2>2016/08/05 03:40</h2>
            <p>設定ファイル読み込み処理を作って、0.1.0とした。</p>
            <p>＊</p>
            <p>明日は特定のゲーム向けの、より迅速なSSID変更処理を追加する予定。</p>
            <p>明日中に完成までできればいいのだが。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/04 00:10</h2>
            <p>昨日の時点で、初回の接続がうまくいかない問題については解決済み。</p>
            <p>＊</p>
            <p>接続前に、接続用アダプタで対象のネットワークが見つかるまでネットワーク検索をかけ、見つかり次第接続する形で対応。</p>
            <p>前バージョンよりも短い時間で接続できるようになった気がする。</p>
            <p>比較するために前バージョンでも試そうとしたんだけど、うまく動いてなかった。</p>
            <p>設定値がおかしいのかもしれないが。</p>
            <p>＊</p>
            <p>今日から、設定ファイル読み込み処理を作っている。</p>
            <p>前バージョンでは、設定値をコマンドライン引数で直接設定していた。</p>
            <p>しかし今回はコマンドライン引数で設定ファイルのパスを指定し、それを読み込む形にする。</p>
            <p>後々、多少複雑な設定値を扱えるようにするためにはその方がいいと判断した。</p>
            <p>で、設定ファイルの記述形式はcandymakerのものと同じ物、つまり簡易的なJSONにする。</p>
            <p>これであればマップやリストを利用できるし。</p>
            <p>何より、すでに作ってあるので手間が省ける。</p>
            <p>というわけで、candymakerから必要なソースを持ってくるところまではやった。</p>
            <p>明日中に、設定値をハードコーディングしている部分を全て差し替えたいところ。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/02 18:40</h2>
            <p>前回接続時から一定時間経過しないと再接続できない仕組みは追加した。</p>
            <p>＊</p>
            <p>で、今は初回の接続がうまくいかない原因を探っていて、大体把握できた。</p>
            <p>大まかに言えば、アダプタを2つにしたのが原因だった。</p>
            <p>接続用のアダプタが、接続先のネットワークの存在を把握できていないのがいけない。</p>
            <p>把握するための方法は、ネットワークの検索。</p>
            <p>検索用と接続用に分け、接続用のアダプタではネットワークの検索をしていなかったからいけなかったのだ。</p>
            <p>接続前にネットワーク検索をかけて、ネットワークの存在を把握してから接続、という形にすれば多分いける。</p>
            <p>となると、処理の流れ自体に手を加えるべきかもしれない。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/02 00:50</h2>
            <p>やる気がびみょう。</p>
            <p>＊</p>
            <p>ネットワーク検索時の重複を消す処理は追加した。</p>
            <p>他にも、PSPの検索を開始した後にSSIDを変更した場合、接続失敗にせず再度PSPの検索をする処理も追加した。</p>
            <p>現在のSSIDと同じSSIDに再度接続しようとする問題については、ちょっと考え中。</p>
            <p>前回接続時の時間を記録しておいて、一定時間経たないと再接続できない仕組みを追加しようかと考えている。</p>
            <p>その仕組みを追加したとしても、ネットワークが変わらない場合再接続を禁止する処理は必要だと思うけど。</p>
            <p>＊</p>
            <p>もしくは、接続できなかった場合はSSIDを空にしておくことで対応するべきだろうか。</p>
            <p>前バージョンはアダプタが1つだから問題なかったけど、今回は2つなので、SSIDをそのままにしておくと検索に引っかかってしまう。</p>
            <p>ネットワークが消滅してから10秒程度経たないと検索から消えてくれないので、今すぐ追加したところで効果は確認できないが。</p>
        </div>
        <hr />
        <div>
            <h2>2016/08/01 12:00</h2>
            <p>金曜の時点で、とりあえず動作する状態にはなった。</p>
            <p>＊</p>
            <p>まだまだ完成ではないが。</p>
            <p>コマンドライン引数か設定ファイルから設定するデータがハードコーディング状態だったりとか。</p>
            <p>現在のSSIDと同じSSIDに再度接続しようとしてしまうのもよくない。</p>
            <p>前バージョンならそれほど問題でもなかったかもしれないが、今回は違う。</p>
            <p>ネットワーク検索用アダプタで検索をかけた時に出てくるSSIDが増えてしまうのだ。</p>
            <p>全く同じSSID、チャンネルのネットワークが複数検出される。</p>
            <p>検出時に被りがある場合は無視する処理も追加する予定だが、ネットワークが変わらないのに接続しようとすることに意味はないので、こちらも処理を追加して抑制する。</p>
            <p>＊</p>
            <p>色々試していて気がついたのだが、同じメーカーのチップセットで同じカーネルモジュールを使っていても、チップセットが違うと細かい動きが違う気がする。</p>
            <p>xlinkkaiを使うためralinkのアダプタを使っているが、古いアダプタと新しいアダプタで違いが出ている。</p>
            <p>アドホック接続をするためにSSIDとチャンネルを設定すると、新しいアダプタの場合は既に存在するネットワークに接続しようとするので問題ない。</p>
            <p>古いアダプタの場合、既にネットワークが存在しても、とりあえず新しいネットワークを作る。</p>
            <p>それからちょっと経つと、既に存在するネットワークに接続する。</p>
            <p>いや、もしかしたら既に存在するネットワーク側がアダプタのネットワークに擦り合わせているのかもしれない。</p>
            <p>そこまでは確認していない。</p>
            <p>とにかく、そのような動作をしているため、古いアダプタだと素早いネットワーク接続に向いていないのでは、と思っている。</p>
            <p>SSID変動型のゲームでうまくいかない場合があるのもそのせいなのでは、と思っている。</p>
        </div>
        <hr />
        <div>
            <h2>2016/07/29 03:15</h2>
            <p>ネットワーク接続処理を作った。</p>
            <p>＊</p>
            <p>PSP検知処理はまだまだ。</p>
            <p>最終的な作りは見えた感じ。</p>
            <p>ネットワークへの接続とPSP検知処理を別々のスレッドでやるので、次に接続するネットワークの決定をどうするか、が問題だった。</p>
            <p>古いバージョンの処理は列挙、接続、検知を順々にやっていたので、列挙したネットワークに順番に接続するだけで済んでいた。</p>
            <p>しかし今回は別々のスレッドなので、ループで順々にネットワークに接続しては検知、という手段は使えない。</p>
            <p>そこで、接続したネットワークの履歴を残す、という方法を考えた。</p>
            <p>一度ネットワークに接続したら、そのネットワークの情報を履歴リストにつっこんでいく。</p>
            <p>次にネットワークに接続する時には履歴リストを参照し、今まで接続したことがないネットワークに優先的に接続する。</p>
            <p>全て接続済みの場合は一番古いものを優先。</p>
            <p>一度接続したことがあるネットワークに接続した際には、そのネットワークの情報を一番上に持ってくる。</p>
            <p>この方法であれば、同じネットワークばかり接続しようとしてしまう、というようなことにはならない。</p>
            <p>＊</p>
            <p>実際には、今接続しているネットワークと同じゲームのネットワークが出現したら、すぐさまそのネットワークに切り替える、という機能も作る予定。</p>
            <p>SSIDが切り替わるタイプのゲームで、タイムアウトがかなり短いゲームへの対策だ。</p>
            <p>それでうまくいくのかどうかは分からないが。</p>
        </div>
        <hr />
        <div>
            <h2>2016/07/28 03:40</h2>
            <p>古い処理から引っ張ってきて、周囲のネットワークの列挙処理を作った。</p>
            <p>＊</p>
            <p>ネットワークの列挙とネットワークへの接続はそれぞれ別のアダプタでやることもあり、スレッドで処理している。</p>
            <p>色々試して気付いたことには、あまり短すぎる間隔で処理を呼び出しまくるとおかしくなる、という点だ。</p>
            <p>大雑把に試してみた感じだと、100ミリ秒間隔が限界点。</p>
            <p>それよりも短い、10ミリ秒間隔以下で呼び出すと、新たに出現したネットワークを検知できなかったり、消滅したはずのネットワークがいつまでも検知されたり。</p>
            <p>そもそも、前に作った時は検知開始してからデータが取れるまでに1秒程度かかってた気がするのだが。</p>
            <p>まぁいいか。</p>
            <p>＊</p>
            <p>次は検知したネットワークに接続する処理を作ろう。</p>
            <p>今回作った処理と同じく、スレッドで処理する。</p>
            <p>それが出来たら、その次はネットワーク内のPSP検知処理だな。</p>
        </div>
        <hr />
        <div>
            <h2>2016/07/27 00:40</h2>
            <p>windows10インストール完了。</p>
            <p>＊</p>
            <p>使う機会はずっと後になると思うが。</p>
            <p>＊</p>
            <p>pspautoconnector2の開発開始。</p>
            <p>基本的には既存のソースから引っ張ってくるので、そんなに時間かからないと思うのだけど。</p>
            <p>設定項目が多少増えるから、コマンドライン引数で与えるのではなく設定ファイルを作った方がいいかもしれない。</p>
            <p>でもそうなると面倒が増えるから、とりあえずはコマンドライン引数からにするか。</p>
            <p>設定ファイルにするかどうかは、メインの処理が出来上がってからでも遅くはない。</p>
        </div>
        <hr />
        <div>
            <h2>2016/07/26 00:40</h2>
            <p>アップグレードの期限が迫っているので、そろそろwindowsを10にしようかと思っている。</p>
            <p>＊</p>
            <p>で、今日ちゃっちゃとアップグレードしようとしたのだが、結果から言えばまだできていない。</p>
            <p>1つのパソコンに2環境作ってあるため、とりあえずインストールディスクを作ろうとしたのだが、まずそこがうまくいかない。</p>
            <p>ツールを使って落とそうとしたが、Cドライブに8GBの空きが必要などと言われた。</p>
            <p>Cドライブは基本的に、必要最低限の領域しか確保しないため、そんなに空きがないのだ。</p>
            <p>Dドライブなら余裕があるのに。</p>
            <p>クリーンインストールするのだし、と色々消してみたが7.8GB程度までしか空きができない。</p>
            <p>windowsアップデート関連のファイルをクリーンアップすれば空きが10GB程度になりそうだが、再起動しないと消せないようだった。</p>
            <p>で、再起動してみたらログイン画面から画面真っ黒。</p>
            <p>マウスポインタだけは見える状態。</p>
            <p>セーフモード起動もできない状態になってしまった。</p>
            <p>＊</p>
            <p>仕方ないのでgentooを起動して調べてみたら、公式サイトからディスクイメージをダウンロードできるとか。</p>
            <p>もっと早く言ってほしかった。</p>
            <p>＊</p>
            <p>そんな感じでまごまごしていたので、本日は全然進んでいない。</p>
            <p>実は昨日、騙し騙しカーネルインストールスクリプトを書いていたので、とりあえずそれを追加しておいた。</p>
            <p>この後rootfsインストールスクリプトも書いてしまうか。</p>
            <p>それができたら軽量化などと言っていたが、正直めんどくさいので、先にpspautoconnectorの新バージョンの方をやろうと思う。</p>
            <p>最悪、軽量化などできなくてもいいのだ。</p>
        </div>
        <hr />
        <div>
            <h2>2016/07/23 03:50</h2>
            <p>とりあえずrootfs生成まで完了。</p>
            <p>＊</p>
            <p>次はカーネルインストールだが、これも過去のスクリプトから持ってくればすぐできるはずだ。</p>
            <p>そこまでできたら、実際にrootfsとカーネルをSDカードにインストールし、動かしてみる。</p>
            <p>特に問題ないようなら、その次は軽量化か？</p>
            <p>必要ないパッケージのファイルの除去などを、スクリプトでまとめてできるようにする。</p>
        </div>
        <hr />
        <div>
            <h2>2016/07/21 17:10</h2>
            <p>昨日の時点で、必要なファイルのダウンロードとカーネルビルド処理まではできた。</p>
            <p>＊</p>
            <p>あとはrootfs生成について。</p>
            <p>そこまでは、過去に組んだスクリプトを参考にして進められる。</p>
            <p>＊</p>
            <p>過去のスクリプトでは、rootfs生成時にカーネルのインストールもやっていたけど、今回のは別にしようと思っている。</p>
            <p>カーネルは複数インストールすることもあるんだし、それをシェルスクリプトで対応させるのはなかなかめんどうだ。</p>
            <p>特に今回の場合はraspberrypiなので、1用と2用で別のカーネルを積む予定だ。</p>
            <p>場合によって1のみ、あるいは両方、あるいは1用のを複数、などというのを1つのスクリプトで全パターン網羅する、というのは困難を極める。</p>
            <p>それなら、1つのカーネルをインストールするスクリプトを作っておいて、それを自分で複数回動かした方が分かりやすそうだ。</p>
        </div>
        <hr />
        <div>
            <h2>2016/07/20 00:30</h2>
            <p>8月中旬頃までは別の作業することにした。</p>
            <p>＊</p>
            <p>raspberrypiで動作するgentooの自動生成関係をやる。</p>
            <p>それが済んだら、pspautoconnectorの新バージョンを作る。</p>
            <p>それをraspberrypiに乗っけて出来上がり。</p>
        </div>
        <hr />
        <div>
            <h2>2016/07/16 00:20</h2>
            <p>candymaker-0.12.0完成。</p>
            <p>＊</p>
            <p>前に作ったpainttestとかgamepadtestで試したが、いい感じ。</p>
            <p>sucroseを別パッケージに分離したが、ちゃんと動作している。</p>
            <p>結構それっぽくなってきた感じがある。</p>
            <p>＊</p>
            <p>気になった点としては、設定ファイルの記述ミスの場所が分かりにくいというところか。</p>
            <p>エラーログの内容を変えることで対応できると思うけど。</p>
        </div>
        <hr />
        <div>
            <h2>2016/07/15 02:15</h2>
            <p>同パッケージ内の依存解決完成。</p>
            <p>＊</p>
            <p>古い処理も片付けた。</p>
            <p>これで他に何もなければ、明日バージョンを確定させよう。</p>
            <p>＊</p>
            <p>次はどうしよう。</p>
            <p>とりあえず、今回の追加で複数のパッケージを扱えるようになったわけだな。</p>
            <p>candymakerに何か追加するとしたら、設定ファイルマネージャやモジュールマネージャとかその辺だろうな。</p>
            <p>しかし、それらは現状必須ってわけでもないし。</p>
            <p>いよいよ簡単なゲームでも作ってみるか？</p>
        </div>
        <hr />
        <div>
            <h2>2016/07/14 02:30</h2>
            <p>同パッケージ内の依存解決の目処は付いた。</p>
            <p>＊</p>
            <p>明日完成させる。</p>
            <p>そこまでできたら、古い方の構成は削除するとしよう。</p>
            <p>それでとりあえずバージョンを確定させるか。</p>
        </div>
        <hr />
        <div>
            <h2>2016/07/13 03:00</h2>
            <p>基礎はできたかも。</p>
            <p>＊</p>
            <p>細部はまだできていないが、インターフェース情報と依存情報、そして有効モジュールリストを使い、適切なモジュールを検索する処理を作った。</p>
            <p>山場は越えたのでは、と思うけど、ちょっと処理がぐちゃぐちゃな気がするんだよなぁ。</p>
            <p>強引に解決した箇所もあるし。</p>
            <p>しかし、その箇所は小手先の修正では解決できない気がする。</p>
            <p>きちんと書くには、新たな仕組みを追加するべきだろう。</p>
            <p>＊</p>
            <p>まぁ、その辺りはやはり後回しで。</p>
        </div>
        <hr />
        <div>
            <h2>2016/07/12 03:00</h2>
            <p>やる気はいまいちだが順調だと思いたい。</p>
            <p>＊</p>
            <p>先週の時点では、またしてもうっかり忘れていた部分の機能追加のみだった。</p>
            <p>やはり先週末で完成は無理だった。</p>
            <p>現時点で、完成までの目処は立った感じがある。</p>
            <p>うまくいけば明日には完成するのでは、と思っている。</p>
            <p>＊</p>
            <p>しかし、インターフェース情報と依存情報、どちらもパッケージ情報に固定データとして書かれてるのはどうなんだろう。</p>
            <p>ちょっと融通が効きにくそう。</p>
            <p>すぐに追加する必要はないと思うけど、パッケージ設定によって調整できるようにするべきか。</p>
            <p>インターフェース情報を追加、あるいは変更をできるようにしたりとか。</p>
        </div>
        <hr />
        <div>
            <h2>2016/07/08 00:15</h2>
            <p>うっかり忘れていた。</p>
            <p>＊</p>
            <p>パッケージ情報ファイルの依存モジュール情報の記述方法を、他パッケージへの依存に対応したものに変更するのを忘れていた。</p>
            <p>なので、今日はとりあえずそこを作った。</p>
            <p>ちなみに、現時点では古いものもまだ消していない。</p>
            <p>現状ではそれで動いているわけだし、消したら消したでめんどうなので。</p>
            <p>＊</p>
            <p>やる気が残念なことになっていたので、そこまでしかできなかった。</p>
            <p>明日は金曜日だし、明日で完成させたいところではある。</p>
            <p>しかし、大きく違う処理を新規に作ることになるわけだし、そう簡単にいくかどうか。</p>
        </div>
        <hr />
        <div>
            <h2>2016/07/07 00:20</h2>
            <p>パッケージ情報ファイル読み込み処理に、インターフェース情報についての処理を追加した。</p>
            <p>＊</p>
            <p>これでとりあえず下準備はできた感じか。</p>
            <p>これらの情報を元に、他パッケージへのモジュール依存の解決を可能にする。</p>
        </div>
        <hr />
        <div>
            <h2>2016/07/06 00:20</h2>
            <p>パッケージ設定ファイル解析処理を作った。</p>
            <p>＊</p>
            <p>インポート機能は未対応。</p>
            <p>そのうちやる。</p>
            <p>忘れないように、課題管理に追加しておいた。</p>
            <p>＊</p>
            <p>次はパッケージ情報ファイルへの記述追加対応。</p>
            <p>インターフェース情報の読み込みに対応する。</p>
        </div>
        <hr />
        <div>
            <h2>2016/07/05 15:35</h2>
            <p>昨日は既存処理を整えていた。</p>
            <p>＊</p>
            <p>で、今日からパッケージ設定ファイルに入ろうとしたのだが、昨日書いたのは多分間違ってる。</p>
            <p>時間が経ちすぎたため、当初の構成を忘れてしまっていたようだ。</p>
            <p>＊</p>
            <p>パッケージ設定ファイルで依存モジュールのマッピングはしない。</p>
            <p>依存モジュールの解決は、パッケージ情報ファイルのモジュール情報に記載する実装済みインターフェース情報と、パッケージ設定ファイルのモジュール使用許可リストで行なう。</p>
            <p>他パッケージへの依存モジュールの指定はインターフェース名で行なう。</p>
            <p>モジュール使用許可リストから、そのインターフェースが実装されているモジュールを探し出す形。</p>
            <p>＊</p>
            <p>そんなわけで、パッケージ情報ファイルにも手を加える必要がある。</p>
            <p>どこから手を付けたものだろうか。</p>
            <p>パッケージ情報ファイルの依存モジュール情報かな、と思ったがこれは最後か？</p>
            <p>少なくともインターフェース情報がなければ動作しないし。</p>
            <p>インターフェース情報より先に、パッケージ設定ファイルを作るべきか？</p>
            <p>その2つは直接的な関わりはないから、どっちから手を付けても大丈夫かな。</p>
            <p>＊</p>
            <p>インターフェース情報とパッケージ設定ファイルを作って、それを元に依存モジュール情報の内容を変更、最終的にモジュールロード処理らへんを変更する感じか。</p>
            <p>しかし、同パッケージについても依存モジュールの指定をインターフェース名でやるべきかと思ったが、正直二度手間な気がする。</p>
            <p>インターフェース名でやることによるメリットもあるため可能にはしたいが、モジュール名の直接指定でもできるようにしたい。</p>
        </div>
        <hr />
        <div>
            <h2>2016/07/04 21:15</h2>
            <p>パッケージ設定ファイルを先に作るべきでは、という気がしてきた。</p>
            <p>＊</p>
            <p>今のところの問題は、他のパッケージのモジュールへの依存モジュール指定ができないという点だ。</p>
            <p>これを、依存パッケージを直接指定して解決する、というのは分かりやすいが、最終的な構成とは割と異なる。</p>
            <p>そこから最終的な形に持っていこうとすると、設定ファイルの記述から変えていかなければならない気がする。</p>
            <p>それなら、そこはまだ現状のままにしておいて、パッケージ設定ファイルを追加した後に対応した方が楽なのでは、という気がしている。</p>
            <p>＊</p>
            <p>パッケージ設定ファイルには何を書くんだったか。</p>
            <p>とりあえずはモジュールの使用許可リストと、依存モジュールのマッピングか？</p>
            <p>他のパッケージ設定ファイルを参照したりするから、それも書くか。</p>
            <p>後々、パッケージとセーブデータディレクトリの関連付けも書く。</p>
            <p>＊</p>
            <p>この中の、最低限必要なものはどれだろうか。</p>
            <p>モジュール使用許可リストは後回しでいいだろう。</p>
            <p>他の設定ファイルの参照、つまりインポートも後でいい。</p>
            <p>そうなると、依存モジュールマッピングだけか。</p>
            <p>依存モジュールマッピングの後に、インポートも対応しよう。</p>
            <p>＊</p>
            <p>依存モジュールマッピングの記述方法はどうしよう。</p>
            <p>細かい指定方法と、大まかな指定方法、少なくともその2種類は用意したい。</p>
            <p>具体的には、細かい指定方法というのはモジュールレベルのマッピング。</p>
            <p>多まかな指定方法というのはパッケージレベルのマッピングだ。</p>
            <p>その中間もあれば、より便利だろうな。</p>
        </div>
        <hr />
        <div>
            <h2>2016/07/01 00:00</h2>
            <p>やる気減退がかなりやばい。</p>
            <p>＊</p>
            <p>しかし、とりあえず0.11.0確定まではやった。</p>
            <p>次は他のパッケージにあるモジュールに対し、依存モジュール指定をできるようにする。</p>
            <p>そこまでできれば、とりあえずcandymakerは一段落だろう。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/28 20:30</h2>
            <p>昨日はうっかり書き忘れた。</p>
            <p>＊</p>
            <p>wafのタスク生成がよく分からんので、昨日1日では完了できなかった。</p>
            <p>なんとなく分かってきた上で、多分明日までかかりそうだな、といった感じ。</p>
            <p>現在のビルドルールが、C++のソースファイルをコンパイルする、という作業を前提に書かれているため、融通が効かない。</p>
            <p>そこから修正していく必要がある。</p>
            <p>＊</p>
            <p>しかしモチベーションが上がらない。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/25 00:30</h2>
            <p>モジュール参照を作った。</p>
            <p>＊</p>
            <p>それをパッケージ情報ファイルで使うようにした。</p>
            <p>結果、パッケージ情報ファイル内のモジュールのパス指定が、パッケージ内の相対パスになった。</p>
            <p>これで、ベースシステムとゲームに必要なパッケージに加え、ショートカットファイルを1つのディレクトリにまとめることで、candymakerにショートカットファイルを読み込ませればゲームが動作するようになった。</p>
            <p>＊</p>
            <p>どうしよう、きりがいいしここで0.11.0としてしまうべきか。</p>
            <p>しかしながら、開発上の問題点が新たに浮上している。</p>
            <p>自動テストで使用するパッケージ情報ファイルの位置と、モジュールの位置が噛み合わないため、自動テストが失敗してしまうのだ。</p>
            <p>一応、ビルド後に自分でモジュールをコピーして、テストが通ることは確認したものの、こんなこと毎回やりたくない。</p>
            <p>毎回やってたら、いずれコピーし忘れとかで問題が出てくるだろうし。</p>
            <p>何よりめんどくさい。</p>
            <p>＊</p>
            <p>wscriptに手を加えて、その辺を対応してから0.11.0とすることにしよう。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/23 22:40</h2>
            <p>パッケージ参照を作った。</p>
            <p>＊</p>
            <p>それをショートカットファイルで使うようにした。</p>
            <p>結果、ショートカットファイルからのベースシステム、ゲームのパッケージ指定が、ショートカットファイルからの相対パスになった。</p>
            <p>今まではcandymakerからの相対パスで、実用度は皆無だったため、これは大きな進歩だ。</p>
            <p>現状の構成からすると、ショートカットファイルの内容は完成したと言っていいはずだ。</p>
            <p>＊</p>
            <p>しかしながら、パッケージの参照についてのみ対応したのであって、それ以外は未対応だ。</p>
            <p>例えば、パッケージ情報ファイルのモジュール指定なんかは、まだcandymakerからの相対パスで指定しなければならない。</p>
            <p>できるだけ早く対応してしまいたいが、パッケージ参照ができたということはモジュールの依存関係にそれを使用できるということだ。</p>
            <p>どちらを先にやるべきか、悩ましい。</p>
            <p>＊</p>
            <p>前者は型の変更であって、処理の流れ自体は変わらない。</p>
            <p>後者は型の追加に加え、それを利用した処理の追加、となるだろう。</p>
            <p>であれば、負荷の軽いモジュール指定の記述、つまりモジュール参照型の作成を先にやってしまうか。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/22 22:40</h2>
            <p>早まらなくてよかったかもしれない。</p>
            <p>＊</p>
            <p>煮詰まってはいるんだが、よく考えたら始まりから間違っていたのかも。</p>
            <p>ショートカットファイルのベースシステム参照について、パッケージパスの記述を色々考えていたんだが、想定では、</p>
            <p>{ "base" : "基点ディレクトリ名", "path" : [ "ディレクトリ名", "ディレクトリ名", "パッケージディレクトリ名" ] }</p>
            <p>といった感じの記述で、基点ディレクトリからの相対パスを表現しようとしていたんだけど。</p>
            <p>しかし、基点ディレクトリから見ても深い階層に配置することなんてないよなぁ、と考え、</p>
            <p>{ "base" : "基点ディレクトリ名", "path" : "パッケージディレクトリ名" }</p>
            <p>こうでいいよな、と思った。</p>
            <p>更に、これならいっそのこと、</p>
            <p>{ "at" : "基点ディレクトリ名", "name" : "パッケージディレクトリ名" }</p>
            <p>という感じにキーの名前を変えた方が分かりやすそうだな、と。</p>
            <p>で更に、この構成は既存のベースシステム参照やゲーム参照の構成と酷似している。</p>
            <p>ならば、これはパスというより参照情報という括りで扱った方がよさそうだな、と思った。</p>
            <p>＊</p>
            <p>ゲーム中で使用する素材なんかは、ある程度区分けされてるディレクトリ構成を扱えた方がいいだろうから、パスの概念が必要になると思う。</p>
            <p>しかしながら、現状ではそこまで自由度の高い要素は必要ないのでは、という話。</p>
            <p>少し希望が見えてきたかもしれない。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/21 22:00</h2>
            <p>確実にやる気減退している。</p>
            <p>＊</p>
            <p>今日も全然進んでない。</p>
            <p>このままではよくないので、candymakerのソースを眺めていたが、ちょっと整理した方がいい気がしてきた。</p>
            <p>なんとなくでファイルを置いてしまっている感じがある。</p>
            <p>特に設定ファイル周り。</p>
            <p>ショートカットファイルの要素、ベースシステム参照とゲーム参照の定義が、ベースシステム側やゲーム側に置かれてるのが違和感ある。</p>
            <p>設定ファイル側、あるいはどちらにも属しない独立したディレクトリに置くべきでは。</p>
            <p>生成時の引数として、設定ファイルの要素を渡すことになると思うから、設定ファイル側でいいとは思うけど。</p>
            <p>＊</p>
            <p>その辺から、ソースファイルの配置を整えるところから始めようかな。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/20 22:00</h2>
            <p>どこを進めるべきか考えていた。</p>
            <p>＊</p>
            <p>ひとまずsucroseはここで中断しておく。</p>
            <p>設定ファイルのパスの扱いをどうにかしようと思う。</p>
            <p>現状では、ベースシステムとゲーム、どちらも1つのパッケージで完結してなければならないという制限がある。</p>
            <p>パッケージをまたぐ依存関係を解決できないためだ。</p>
            <p>しかし、ゲームやベースシステムが汎用的なパッケージを利用する、などというのはよくあることだと思うので、できないと非常に困る。</p>
            <p>というわけで、依存モジュールの指定にパスを含めるようにする。</p>
            <p>付随して、今まで環境依存の文字列として扱ってきたパスを、共通的に扱うべく書式を定めようと思う。</p>
            <p>＊</p>
            <p>しかし、一気に全部をやろうとしてもうまくいかないと思うので、段階的に作っていく。</p>
            <p>まずやるべきは、型の関係だろうな。</p>
            <p>後に回せば回すほど、影響箇所が増えて面倒になるし。</p>
            <p>なので、まずはパスの型を作る。</p>
            <p>次に、設定ファイルのパスの箇所について対応し、これで一段落。</p>
            <p>その次はどうするか。</p>
            <p>最終的には、パッケージ設定ファイルを追加することになるけど、さすがにそこまで一気にはやりたくないなぁ。</p>
            <p>パッケージからパッケージに、直接依存する形を取るか？</p>
            <p>現状の依存モジュールの記述は、</p>
            <p>{ "deps" : [ "依存モジュール名" ] }</p>
            <p>といった具合だが、ひとまず</p>
            <p>{ "deps" : [ { "path" : パス型(依存モジュールのパス), "name" : "依存モジュール名" } ] }</p>
            <p>という形にするか。</p>
            <p>で、最終的には</p>
            <p>{ "deps" : [ { "package" : "依存パッケージ名", "name" : "依存モジュール名" } ] }</p>
            <p>という形にするかな。</p>
            <p>実際のモジュールとのマッチングは、パッケージ設定ファイルでやる感じ。</p>
            <p>＊</p>
            <p>今回の作業の最終的な落としどころも考えておこう。</p>
            <p>ショートカットファイルと必要なパッケージ群を1つのディレクトリにまとめた上で、</p>
            <p>candymaker ショートカットファイルパス</p>
            <p>と実行すれば、ディレクトリがどこに配置してあってもゲームが動かせる、といったところか。</p>
            <p>それを実現するには、前述した作業以外にも工程が必要になるが、やりたいことはつまりそういうことだろう。</p>
            <p>ショートカットファイルを基点とするファイル配置への対応。</p>
            <p>現時点では、candymakerを実行したティレクトリを基点とした配置にしか対応できてないし。</p>
            <p>むしろそんなものはなんの役にも立たないし。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/19 00:55</h2>
            <p>休みだし、久々にraspberrypi関係をやっている。</p>
            <p>＊</p>
            <p>raspberrypiで動作するgentooの自動生成をスクリプトにまとめようとしている。</p>
            <p>とりあえず、最新のstage3をダウンロードするスクリプトを書いた。</p>
            <p>昔書いたスクリプトでは、落とすstage3のパスを直書きしていたので、stage3が新しくなったら修正が必要だった。</p>
            <p>今回はサーバーにあるlatest-stage3なんちゃらファイルを参照して、現在の最新版をダウンロードするようにした。</p>
            <p>おまけで、stage3の最新版がダウンロード済みで、最新版が更新されていない場合にダウンロードをスキップする処理も追加した。</p>
            <p>＊</p>
            <p>休日に地道に進めて、起動後ディスクレス化する環境の自動生成までやりたいところ。</p>
            <p>スクリプトを使って試行錯誤し、最終的に生成できた、というのは昔やったんだけど。</p>
            <p>手動で手を加えたことも色々あって、今ではどうやったら確実に生成できるか覚えてないので。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/17 20:40</h2>
            <p>0.8.0確定。</p>
            <p>＊</p>
            <p>sucroseの.hと.cppの総行数が1万を越えた。</p>
            <p>試しに、バージョン毎のファイル数と行数を簡単なシェルスクリプトで出力したところ、</p>
            <table>
                <tr><th>バージョン</th><th>ファイル数</th><th>行数</th></tr>
                <tr><td>v0.1.0</td><td>16</td><td>495</td></tr>
                <tr><td>v0.2.0</td><td>39</td><td>2676</td></tr>
                <tr><td>v0.3.0</td><td>40</td><td>2810</td></tr>
                <tr><td>v0.3.1</td><td>40</td><td>2810</td></tr>
                <tr><td>v0.4.0</td><td>40</td><td>3032</td></tr>
                <tr><td>v0.5.0</td><td>40</td><td>3253</td></tr>
                <tr><td>v0.6.0</td><td>88</td><td>8790</td></tr>
                <tr><td>v0.6.1</td><td>91</td><td>8685</td></tr>
                <tr><td>v0.7.0</td><td>105</td><td>9449</td></tr>
                <tr><td>v0.8.0</td><td>129</td><td>13001</td></tr>
            </table>
            <p>こんな具合だった。</p>
            <p>0.3.0から0.5.0にかけてファイル数が一向に増えてないのは、ウィンドウ周りの機能追加をするたびにバージョンを上げてたんだろう、多分。</p>
            <p>過去の記述を見返したら、0.6.0でゲームパッドがどうたら言ってて、行数も一気に倍以上増えてるので多分そう。</p>
            <p>＊</p>
            <p>0.8.0で追加したスレッドプールとタスクにより、非同期処理が多少書きやすくなった、はず。</p>
            <p>しかし、タスクマネージャ書いてる時にデッドロック見つけちゃってやばかった。</p>
            <p>スレッド内でロックしてるmutexをロックしながらjoinしようとしてた。</p>
            <p>やはり非同期処理で厄介なのは、バグが再現しないことがある、という点か。</p>
            <p>今回の件も、たまたまjoinの方が早くロックを取得すると発生するのであって、毎回起きるわけじゃないし。</p>
            <p>また、停止してしまうだけで不正終了はしないから、どこで止まってるのかも特定が面倒だし。</p>
            <p>久々にgdbとか使って停止箇所特定などしようとしたが、久々すぎてうまく使えず。</p>
            <p>結局printfデバッグで発生箇所を特定し、解決した。</p>
            <p>まだどこかにバグが潜んでいそうで怖い。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/17 00:30</h2>
            <p>ゲームパッドの対応も完了。</p>
            <p>＊</p>
            <p>しかし、0.8.0はまだ確定しない予定。</p>
            <p>タスク管理の共通化のアイデアがひらめいたので。</p>
            <p>明日それを作ってから確定する予定。</p>
            <p>＊</p>
            <p>問題となっていたのは、タスクを括る必要がある、という点だった。</p>
            <p>どういうことかと言えば、</p>
            <p>{</p>
            <p>bool ended;</p>
            <p>タスク</p>
            <p>タスク</p>
            <p>タスク</p>
            <p>Ender ender;</p>
            <p>}</p>
            <p>これで伝わるかどうかは謎だが。</p>
            <p>排他制御関係やEnderの定義を省いて簡略化しているが、タスクを管理する構造体の定義だ。</p>
            <p>endedは終了フラグで、trueの場合タスクの実行できなくなる。</p>
            <p>それにより、各タスクが他のタスクに遷移することなく終了する。</p>
            <p>enderは、破棄のタイミングでendedをtrueに設定する。</p>
            <p>この構成によって、構造体を破棄すれば安全にタスク群を破棄できるのだ。</p>
            <p>不用意にタスクを破棄しようとすると、まだ動いているタスクから破棄済みのタスクに遷移しようとして死ぬ、などということが起きる可能性がある。</p>
            <p>＊</p>
            <p>これをどう共通化したものか、いい案が浮かばなかった。</p>
            <p>仮に、TaskManagerというものを用意して、そこにタスクを登録していく形、とすると各タスクのメンバ名が消えるようなものなので、タスクの遷移がやりにくくなりそうだ。</p>
            <p>自分で生成したものの破棄を他でやる、という構成も気に食わない。</p>
            <p>＊</p>
            <p>早い話が、endedに2回破棄処理をかける必要があるのが問題なのだ。</p>
            <p>1回目の破棄でendedをtrueに設定、2回目で物理的に破棄、つまりメモリ領域の解放。</p>
            <p>そこで思い付いたのが、</p>
            <p>{</p>
            <p>TaskManagerBegin taskManager;</p>
            <p>タスク</p>
            <p>タスク</p>
            <p>タスク</p>
            <p>TaskManagerEnd taskManagerEnd;</p>
            <p>}</p>
            <p>このような構成だ。</p>
            <p>実際にはBeginとEndをユニークポインタで管理するだろうが、それ以外に違いはない。</p>
            <p>TaskManagerBeginに、終了フラグや排他制御関係のものを持たせる。</p>
            <p>TaskManagerEndは、生成時にTaskManagerBeginの参照を要求する。</p>
            <p>TaskManagerEndの破棄時に、TaskManagerBeginの終了フラグを設定する。</p>
            <p>といった具合だ。</p>
            <p>他にも、WaitTaskCancellerみたいなものをBeginとEndの間に配置することで、待機タスクをキャンセルによって終了させる、ということもできるようにする予定。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/16 02:20</h2>
            <p>待機スレッドプール完成。</p>
            <p>＊</p>
            <p>出来たそれを使って、早速ウィンドウの処理に待機タスクを追加した。</p>
            <p>ゲームパッドマネージャの処理も、タスクで処理するように書き換えた。</p>
            <p>あとはゲームパッドだけ。</p>
            <p>それが完了したら0.8.0として確定するか。</p>
            <p>＊</p>
            <p>現時点で、スレッドプールで稼働しているスレッドが1つでも、ウィンドウとゲームパッドマネージャがきちんと動作することを確認している。</p>
            <p>待機スレッドプールを作る前は、どちらかのタスクが待機を行なっている間、もう片方のタスクを処理できなかった。</p>
            <p>…はず。</p>
            <p>残念ながら確認したわけではない。</p>
            <p>絶対やばいよなぁ、ということで対応したので。</p>
            <p>＊</p>
            <p>ウィンドウとゲームパッドマネージャのタスクの管理部分は、ほぼ同じ構成になった。</p>
            <p>共通化できそうな気がするが、そううまくいくだろうか、とも思う。</p>
            <p>うまく共通化できれば、かなり有用なものになりそうなのだが。</p>
            <p>ゲーム側のタスク管理にも使えるし。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/15 12:20</h2>
            <p>普通のスレッドプールのタスクについても破棄処理が間違っている気がする。</p>
            <p>＊</p>
            <p>現状、タスクの破棄処理は未稼働タスクの削除と稼働中タスクの待機をした後に行なっている。</p>
            <p>しかし、未稼働タスクの削除はいらないのではないか？</p>
            <p>確かにタスクの破棄までの時間が短縮されるが、そもそも稼働させたいから未稼働タスクに蓄積されているのだ。</p>
            <p>それを稼働させずに消してしまう、というのはおかしい気がする。</p>
            <p>それに、普通のスレッドプールは待機が発生することがないのだから、ちょっと待てばすぐ終了するはずだ。</p>
            <p>なので、未稼働タスクと稼働中タスク、どちらからも破棄対象のタスクがなくなるまで待機するのが正しいかな、と。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/15 00:00</h2>
            <p>待機スレッドプール、まだ出来てないが構成ははっきりした感じ。</p>
            <p>＊</p>
            <p>pthread_cancel()で待機を強制的に切って終了させる、というのは多分やらない方向になる。</p>
            <p>pthread_cancel()による強制終了処理自体は用意するが、それはあくまで例外的な処理であり、通常は待機が終わるまで待って終了させる。</p>
            <p>そもそも、pthread_cancel()を使わざるを得ない状況というのがあまりないのだ。</p>
            <p>read()やpoll()などの、条件を満たさなければ処理が進まない、というような関数を使う場合にのみ使うべきだ。</p>
            <p>例えばミューテックスと条件変数によるwait()であれば、notify()で起こしてやればいい。</p>
            <p>破棄したい場合には、例えば終了フラグなどをセットしてから起こしてやれば上出来だろう。</p>
            <p>そんなわけで、昨日書いた想定は間違い。</p>
            <p>＊</p>
            <p>待機スレッドプールは、私が考えていた以上に便利な面もありそう。</p>
            <p>pthread_cancel()を使う場合、今までのやり方では想定しているポイント以外でキャンセルが発生しないか不安に思っていた。</p>
            <p>それが、待機スレッドプールを使うことにより、pthread_cancel()の影響する範囲を待機タスクの部分のみに絞ることができる。</p>
            <p>普通のスレッドプールで処理する範囲に関しては、pthread_cancel()でキャンセルがかかることは絶対になくなったわけだ。</p>
            <p>この安心感は大きい。</p>
            <p>＊</p>
            <p>しかし、今作ってるこれ、動作的にはファイバのようなものだな。</p>
            <p>固定数のスレッドと、それを利用する無数の処理の断片、という構図になるので、効率的に処理を回せそうな雰囲気はある。</p>
            <p>でも、処理と処理を繋ぎ合わせてるのは実質的にgotoのようなものなんだよな。</p>
            <p>あまり複雑な繋ぎ方はしない予定だけど、やろうとすれば簡単にスパゲティ化するだろうし、ちょっと怖い。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/14 02:45</h2>
            <p>ゲームパッドのスレッドについては後回しにした。</p>
            <p>＊</p>
            <p>だって現状が中途半端すぎるもんで。</p>
            <p>ウィンドウのイベント読み込み待機中、スレッドプールの1スレッドを占有してしまうのが痛い。</p>
            <p>処理の詰まりを分かりやすくするために、スレッドプールは1スレッドのみで動かしていて、その1スレッドがメインウィンドウのイベント処理だけに使われちゃってもうだめ。</p>
            <p>スレッドプールでは待機無しの処理だけを流すので、待機処理は待機スレッドプールというのを別に用意し、そこでやろうと考えている。</p>
            <p>＊</p>
            <p>待機スレッドプールは、プールっていうよりキャッシュなんだけど。</p>
            <p>待機処理が必要になった時にスレッドを起動し、そのスレッドで待機処理をする。</p>
            <p>待機処理を終えたスレッドはそのまま保持しておき、別の待機処理に使い回す。</p>
            <p>＊</p>
            <p>とまぁ、そんな具合。</p>
            <p>スレッドプールのタスクは待機が発生しない処理だけを流すので、破棄は処理が終わるのを待ってからにしている。</p>
            <p>一方、待機スレッドプールのタスクはpthread_cancel()で待機を強制的に切って終了させる予定。</p>
            <p>pthread_cancel()で終了したスレッドは使い回せないので、joinしてから破棄、という流れになるだろうな。</p>
            <p>＊</p>
            <p>待機スレッドプールについてはまだちょっともやもやしてるんだよなぁ。</p>
            <p>きちんと作れるのか不安だ。</p>
            <p>普通のスレッドプールと比べて、違うのは内部、つまり実装だけで、インターフェース自体はほぼ同じになる予定ではあるのだが。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/13 20:30</h2>
            <p>ひとまず、ウィンドウから使うところまではできた。</p>
            <p>＊</p>
            <p>ゲームパッドの方についても、ちゃっちゃとやってしまう予定。</p>
            <p>とりあえず、スレッドプール以外にstd::threadを使用している箇所が無くなるようにする。</p>
            <p>＊</p>
            <p>タスクの引数に、そのタスクの参照を追加したのはいいのか悪いのか。</p>
            <p>タスクの処理の最後でそのタスクを再度開始させることで、ループ処理をするために追加した。</p>
            <p>これが無い場合、タスクをなんらかの構造体のメンバとして追加したりしないと、自身の参照を得るのが困難だったからだ。</p>
            <p>しかしながら、実際の運用を考えた場合、自身を再度開始させることなんてないのでは？という気もしている。</p>
            <p>処理の待機が存在しないタスクを回し続けたらCPUの稼働率が無駄に高くなってしまうし。</p>
            <p>処理の待機は別の種類のタスクで処理する予定なので、それを利用すると処理タスク→待機タスク→処理タスク→…となるので、自身は参照しない。</p>
            <p>それにその場合、循環参照になるため全タスクをなんらかの構造体にメンバとして追加することになると思うし。</p>
            <p>とはいえ、今はウィンドウの処理で使ってるから、そこで使わなくなったらさっさと消してしまうかな。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/11 00:00</h2>
            <p>構成失敗したかも。</p>
            <p>＊</p>
            <p>スレッドプールの件。</p>
            <p>とりあえずできたので、実際に使おうとしたのだがうまくいかない。</p>
            <p>スレッドタスクというものを作り、それをプールに投げて実行する、という形を取っているのだが、処理が終了したかどうか確認できないという問題が浮上した。</p>
            <p>タスクを破棄したくても、まだ処理中かもしれないし、破棄しても大丈夫なのかどうかが判断できないのだ。</p>
            <p>プールが1つならまだどうにかできるかもしれないが、現在の仕様上だとタスクはプールに投げる時に対象のプールを指定する形を取っており、やろうとすれば複数のプールに投げることもできる。</p>
            <p>その場合、こっちのプールではどうだ、あっちのプールでは、といった感じの処理が必要になり、収拾つかなくなる感じがある。</p>
            <p>実際には、複数のプールを生成することに意味は全く無いので、そのようなことはやらないが、そうなる可能性があるという時点で構成が間違ってる気がするのだ。</p>
            <p>＊</p>
            <p>私が想定している運用からすると、タスクを生成するタイミングで、そのタスクを処理するプールを指定しておく形がいいのかもしれない。</p>
            <p>そうすれば、タスクを処理するプールが1つに固定されるので、処理の終了チェックなどがやりやすくなるはずだ。</p>
            <p>＊</p>
            <p>他の問題としては、あるタスクの処理内で、他のタスクをプールに投げる、とかについてか。</p>
            <p>通常時は問題ないと思うが、これまたタスクを破棄するタイミングで、タスクをプールに投げようとしたらそのタスクはすでに破棄済みでメモリ例外、なんてのは起きそうなものだ。</p>
            <p>どちらかといえばプールやタスクの問題というより、そもそもマルチスレッド処理だから起きる問題という感じなので、その辺考慮した記述をすれば問題ないのだろうけど。</p>
            <p>＊</p>
            <p>本当なら、今の構成を作るのは昨日中に終わってた気もするんだけど、やる気減退してたのか終わらなかった。</p>
            <p>終わってたところで、今日同じ問題にぶち当たって頭抱えてたか。</p>
            <p>さて、どのように修正加えていくかくらいは目星を付けておくか。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/09 00:40</h2>
            <p>とりあえず0.7.0は完了。</p>
            <p>＊</p>
            <p>スレッドプールについては、waitをどう処理するかまだ考えてないのだった。</p>
            <p>そこを考えるのは後回しにしてもいいような気がするけど。</p>
            <p>＊</p>
            <p>スレッドプールで動かす処理についても、イベントハンドラと同じ形にしようかと思っている。</p>
            <p>ファンクタを引数にスレッドプールハンドラとでも言うべきものを生成する。</p>
            <p>スレッドプールにそれを登録することで、プールしてあるスレッドで処理する。</p>
            <p>そう考えると、同じハンドラを複数回登録するのもありかな、と考えている。</p>
            <p>＊</p>
            <p>というのも、現状ではウィンドウやゲームパッドのイベントハンドラは、同じものを複数回登録できない仕様にしているのだ。</p>
            <p>この制限も、正直あまり意味がないので撤廃するべきかもしれない。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/08 00:10</h2>
            <p>ベースシステムデータの変更については完了したと言える。</p>
            <p>＊</p>
            <p>ゲームパッドのイベントからウィンドウの再描画要求出せるようになった。</p>
            <p>ゲームパッドいじくるとウィンドウに描画している三角形の色が変わっていい感じ。</p>
            <p>しかしながら、ウィンドウやゲームパッドマネージャのスレッド開始についても変更しておかないとまずい。</p>
            <p>その変更が完了したら、0.7.0としようと思う。</p>
            <p>＊</p>
            <p>0.8.0はどうしよう。</p>
            <p>スレッドプールの追加が妥当だろうか。</p>
            <p>しかし、それがないと困る、というレベルでも…なくはないか？</p>
            <p>イベント処理をスレッドプールでやるようになれば、描画イベントの処理遅延も改善できるはずだし。</p>
            <p>＊</p>
            <p>他の候補としては、sucroseではなくcandymakerの方か。</p>
            <p>ファイルパスの扱いをはっきりさせる。</p>
            <p>その辺ができれば、設定ファイルがより実用的になる。</p>
            <p>現状では、絶対パスもしくは作業ディレクトリからの相対パスしか指定できないからなぁ。</p>
            <p>ファイル入出力なども作り始めることができるようになるはずだ。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/07 00:10</h2>
            <p>ゲームパッドのイベント内でウィンドウの参照を取得できるように対応中。</p>
            <p>＊</p>
            <p>ベースシステムデータの中身を2つに分けることで対応することにした。</p>
            <p>片方は従来のものからデータ参照機能を取り除いたもの。</p>
            <p>もう片方は従来のもののデータ参照機能と、ウィンドウなどの実行中のデータ参照機能を合わせたもの。</p>
            <p>スレッド処理に関しては、とりあえず自前で実行する形にしようと思う。</p>
            <p>スレッドプールについてはまた今度。</p>
            <p>多分今やってるのが完了したらやる。</p>
            <p>＊</p>
            <p>今日中に2つに分割する作業は完了したいところだったが、ちょっと厳しそう。</p>
            <p>明日中には。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/06 12:40</h2>
            <p>色々考えた結果、やはり音は後回しにすることにした。</p>
            <p>＊</p>
            <p>位置付けとしては、テクスチャ、というより画像ファイルに近い感じがするのだ。</p>
            <p>あれば便利だろうけど、今すぐに必要というわけでもない。</p>
            <p>それに、音に関してはどのように構成するべきなのか、まだよく分かっていないのだ。</p>
            <p>その試行錯誤に時間を使ってしまうよりも、別のところを進めるべきかな、と。</p>
            <p>＊</p>
            <p>差し当たっては、ゲームパッドのイベントからウィンドウの再描画要求をするのが困難、という点をどうにかしよう。</p>
            <p>ゲームパッドの入力が即座に画面に反映されないので、これではゲームにならない。</p>
            <p>しかし現状、ウィンドウ生成時にイベント処理スレッドを開始しているのが問題になるか？</p>
            <p>ゲームパッドマネージャでも、生成時にイベント処理スレッドを開始している。</p>
            <p>全てのイベント処理が始まる前に下準備をしておく、ということができなさそうだ。</p>
            <p>今回の件では、ゲームパッドのイベントからウィンドウを参照できるようにしておく、というのがそれに当たる。</p>
            <p>対処方法としては、単純に考えて生成とスレッド開始を別々にしておき、準備が完了した後にスレッドを開始する、となるんだろうけど。</p>
            <p>しかしそれはあまりスマートじゃないなぁ。</p>
            <p>今はまだウィンドウとゲームパッドマネージャだけ、2つだからいいけど、今後スレッドを起動する要素が増えていったら大変そうだ。</p>
            <p>＊</p>
            <p>そこで、スレッドはスレッドプールで管理する、という方法を考えている。</p>
            <p>スレッドプールの生成と開始を別々にしておく。</p>
            <p>スレッド処理が必要な要素は、生成時にスレッド処理をスレッドプールに登録する。</p>
            <p>スレッドプールのスレッド開始命令で、登録されている処理を一斉に開始する。</p>
            <p>しかしながら、私はスレッドプールというものについて、言葉と大体のイメージしか知らんので、そんなにうまくいくものだろうか、という不安がある。</p>
            <p>できれば、イベント処理1つ1つについても、スレッドプールに投げてスレッドで処理したいのだけど。</p>
            <p>それによって、描画処理の垂直同期による、ウィンドウイベントの処理遅延も解決できる気もするし。</p>
            <p>＊</p>
            <p>さて、どこから手を付けるか。</p>
            <p>ひとまず、スレッドプールは置いといて、ゲームパッドのイベントからウィンドウの再描画要求ができるように、構成を変更するか。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/03 22:50</h2>
            <p>0.6.1できた。</p>
            <p>＊</p>
            <p>ウィンドウ生成とかに追加した、いらんデータの削除と、課題管理に上げてた2件を対応。</p>
            <p>＊</p>
            <p>次からは音と思っていたけど、うーん。</p>
            <p>音を扱うということは、まずファイル読み込みを使うことになりそうな気がする。</p>
            <p>ウィンドウやゲームパッドはそんなことないけど。</p>
            <p>＊</p>
            <p>別のところを進めるべきか。</p>
            <p>土日にじっくり考えてみよう。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/03 18:15</h2>
            <p>ぐーたらやってたら遅くなってしまったが、0.6.0できた。</p>
            <p>＊</p>
            <p>ゲームパッドを扱う簡単なプログラム、gamepadtestを作って思ったことには、ウィンドウを参照しにくいという点だ。</p>
            <p>ちょっと前に作った描画を行なう簡単なプログラム、painttestの時は、ウィンドウを参照するのが描画イベント内であり、イベントデータからウィンドウの参照が得られるため問題なかった。</p>
            <p>しかし今回は、ゲームパッドのイベント内からウィンドウの再描画リクエストをしようとしたけど、現状ではできていない。</p>
            <p>ウィンドウの参照を得られないからだ。</p>
            <p>そんなわけで、ゲームパッドの抜き差しやボタン押下などに反応して、描画色を変えるようにしているのだけど、ウィンドウを一旦隠すとかして、手動で再描画させないと色が変わらない感じ。</p>
            <p>実行中のベースシステムデータ、みたいなものを用意して、今動いてるベースシステムのデータ、つまりウィンドウの参照などを取得できるようにするべきか。</p>
            <p>＊</p>
            <p>とりあえず、細かい修正をやってしまおう。</p>
            <p>ウィンドウの生成時やら描画イベントやらに足してしまった、ベースシステムデータの参照削除と、あとは課題管理に追加してある件を何件か、といったところか。</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/02 20:40</h2>
            <p>想像以上に疲れた。</p>
            <p>＊</p>
            <p>ゲームパッドIDの対応は完了した。</p>
            <p>やはり仕様変更は疲れる。</p>
            <p>テスト駆動でやってるからか、きちんとできてそうな実感があるのはいいのだけど。</p>
            <p>今回のは、さすがに最初に横着しすぎただろうか。</p>
            <p>最初からゲームパッドIDを文字列でなく独立した型にしていれば、こんなことには。</p>
            <p>処理内容だったらともかく、型についてはできるだけ後から変更をかけないようにしないといけないな。</p>
            <p>＊</p>
            <p>とりあえず、ベースシステムデータにゲームパッドのイベントハンドラを設定できるようにして、メインでゲームパッドマネージャを起動するところまでは書けた。</p>
            <p>なので、ゲームパッドを使用する簡単なプログラムを作りたいところだけど、いかんせん疲れた。</p>
            <p>明日でいいかなーという気がしている。</p>
            <p>プログラムが問題なく動くなら0.6.0として確定させるから、できれば今日やりたい気もするんだが。</p>
            <p>＊</p>
            <p>明日は金曜日か。</p>
            <p>明日中に0.6.1を作れればきりがいいな。</p>
            <p>簡単なプログラムの作成と細かい修正、これらをまとめて明日中に…やれるか？</p>
        </div>
        <hr />
        <div>
            <h2>2016/06/01 23:35</h2>
            <p>ゲームパッドの扱い、ほぼ完成。</p>
            <p>＊</p>
            <p>ゲームパッドIDに関してはまだ生の文字列のままなので、明日直そう。</p>
            <p>それができたら0.6.0とする。</p>
            <p>＊</p>
            <p>次はゲームパッドに関するものをベースシステムに追加するとしよう。</p>
            <p>で、簡単なゲームを作る。</p>
            <p>あー、ウィンドウのイベントにベースシステム関係の参照追加しちゃったのも直すか。</p>
            <p>他にも細かい修正したらそれを0.6.1とするか。</p>
            <p>＊</p>
            <p>以前の記述を見直したら、ゲームパッドの次は音って書いてるな。</p>
            <p>それもそうか。</p>
            <p>音までやって、ゲームパッドで動かせて音も出るゲームを作れたら、中途半端にしてる部分もどうにかしていくべきだろうな。</p>
        <hr />
        <div>
            <h2>2016/05/31 21:00</h2>
            <p>さすがに昨日の今日で本調子とは行かないか。</p>
            <p>＊</p>
            <p>とりあえず、ゲームパッド接続・切断に関しては出来上がった。</p>
            <p>ゲームパッドIDはただの文字列ではなく型を作るべきとは思うが、使えないこともないし今はこれでいいだろう。</p>
            <p>次はゲームパッドの入力だ。</p>
            <p>接続イベントを済ませた後にゲームパッドの入力を扱うオブジェクトを作り、切断イベントの前に破棄、という形になるだろうな。</p>
        </div>
        <hr />
        <div>
            <h2>2016/05/31 00:10</h2>
            <p>先週中にゲームパッド対応は終わらせたかった。</p>
            <p>＊</p>
            <p>でもそれはさすがに無茶だったようだ。</p>
            <p>金曜開始時点で、ゲームパッドの入力の扱いに関してはノータッチだったし。</p>
            <p>＊</p>
            <p>で、今日。</p>
            <p>体調が優れないのと、キーボードの調子が悪いのダブルパンチで作業はかどらず。</p>
            <p>キーボードのEnterキーが、1回押しただけなのに2回入力される現象が稀に発生していた。</p>
            <p>しかし、前に壊してしまった同じ型のキーボードからパーツを拝借したところ、どうやら改善できたようだ。</p>
            <p>＊</p>
            <p>明日こそ本気出す。</p>
        </div>
        <hr />
        <div>
            <h2>2016/05/26 17:00</h2>
            <p>evdevは地雷だったかもしれない。</p>
            <p>＊</p>
            <p>とりあえずわけがわからない。</p>
            <p>ゲームパッドのボタン数取得方法からしてもうだめ。</p>
            <p>かろうじて分かったことは、どうもそんなのなさそう、という空気だけ。</p>
            <p>evdevでのゲームパッドの扱いは多分、windowsのxinputに近いんじゃないかなと思う。</p>
            <p>決まった仕様にゲームパッドを当てはめていく感じ。</p>
            <p>xinputの方はまだいい。</p>
            <p>ゲームパッドのボタン数とかも仕様のうちに入っているため、ボタン数や軸数が固定だから。</p>
            <p>evdevの場合、とりあえずいくつか用意しておいたボタンのうち、接続したゲームパッドだとこのボタンとこのボタンと…が使えるよ！！みたいな情報を得てどうのこうのとか、なにやらすごいめんどくさい。</p>
            <p>多分evdevだと、ボタンが100個とか付いてるゲームパッドに対応できないんじゃないかな。</p>
            <p>そんなもの扱う予定などないが、古い仕様やDirectInputにはできた。</p>
            <p>evdevとxinputにはそれができなさそう。</p>
            <p>もうフォースフィードバックとかどうでもいいんで、古い仕様の方を使うとしよう。</p>
            <p>ゲームパッドが振動するみたいな機能、私基本的に嫌いだし。</p>
            <p>＊</p>
            <p>結構な時間とやる気を無駄にしてしまった。疲れた。</p>
        </div>
        <hr />
        <div>
            <h2>2016/05/26 11:50</h2>
            <p>ゲームパッド切断については、昨日すぐ作った。</p>
            <p>＊</p>
            <p>で、pthread_kill()もちょっと扱いめんどうそうだな、というのも大体理解した。</p>
            <p>というわけで、今日はゲームパッドの入力の扱いに入ろうとしている。</p>
            <p>のだが、いまひとつまとまらないような。</p>
            <p>＊</p>
            <p>過去のプロジェクトの構成とは、これまた少し変える予定。</p>
            <p>過去のプロジェクトでは、ゲームパッドの初期状態に関してもボタンや軸の状態変化イベントを呼び出していたが、これはやめる。</p>
            <p>ボタンの初期状態の通知と、ボタンの状態変化の通知というのは別物にするべきだと思うからだ。</p>
            <p>具体的には、初期状態についてはゲームパッド接続イベントのイベントデータから取得できるようにする。</p>
            <p>状態変化については変えなくてもいいと思う。</p>
            <p>過去のプロジェクトと同じく、変化があったものについてどう変化したかのみ通知する。</p>
            <p>ボタン数、軸数の取得については、過去のプロジェクトのやり方はさすがに頭が悪すぎる。</p>
            <p>要求があった時にゲームパッドから取得して返す、とかちょっと。</p>
            <p>ゲームパッドを扱うならまず使用するデータなんだし、接続時にゲームパッドから取得する。</p>
            <p>＊</p>
            <p>あと、今回は状態変化イベント、ということでボタンと軸の区別をなくそうと思っていたけど、やっぱりだめかも。</p>
            <p>変化したものだけ通知する場合、やはりこれは別々の方がいい。</p>
            <p>1つにするとなると、例えば変化したのがボタンなのか軸なのか、といったフラグのようなデータが必要になるし。</p>
            <p>あるいは、ゲームパッドのボタンや軸の状態を全て記録しておく形か。</p>
            <p>しかしそれは扱いにくそう。</p>
            <p>どのボタンもしくは軸に変化があったのか知りたい場合、直前のイベントデータと比較しなければならないわけだし。</p>
            <p>なにより、そのようなことがしたければイベントハンドラでやればいいと思う。</p>
            <p>提供する機能は、必要最低限にしたいのだ。</p>
            <p>＊</p>
            <p>まとめると、イベントで扱えるデータは、まず共通的なものが</p>
            <p>・ゲームパッドID</p>
            <p>接続時に扱えるデータが</p>
            <p>・ボタン数</p>
            <p>・軸数</p>
            <p>・ボタンの初期状態</p>
            <p>・軸の初期状態</p>
            <p>状態変化時に扱えるデータが</p>
            <p>・変化のあったボタンもしくは軸</p>
            <p>・値</p>
            <p>こんな具合だと思っている。</p>
            <p>ちなみにゲームパッドIDというのは、一意であればなんでもいい。</p>
            <p>デバイスのパスのようなデータになると思うが。</p>
            <p>あー、ゲームパッド名も接続時、もしくは共通データとして保持するべきか？</p>
            <p>ボタンと軸の数についても、接続時以外でも見られた方が便利だろうか。</p>
            <p>それなら、接続イベント時にどっかに退避しておく、というのをイベントハンドラでやればいいとも思っているのだけれど。</p>
            <p>＊</p>
            <p>さて、どこから手を付けるか。</p>
            <p>やはり接続時に参照できるデータから追加していくべきか。</p>
        </div>
        <hr />
        <div>
            <h2>2016/05/25 14:20</h2>
            <p>ゲームパッド接続検出処理ができた。</p>
            <p>＊</p>
            <p>過去のプロジェクトよりはましになった気がする。</p>
            <p>過去のプロジェクトでは、pthread_cancel()でスレッドをキャンセルして終了させるために、そのスレッド内では動的なメモリ確保を行なわないようにしていた。</p>
            <p>pthread_cancel()で終了するスレッドと、そのスレッドからデータを受け取って処理するスレッド、2つのスレッドを走らせていたのだ。</p>
            <p>＊</p>
            <p>今回は、とりあえず起動するスレッドは1つにした。</p>
            <p>スレッド内で使用するデータに関しては、スレッド起動前に生成し、sucrose::GamepadManagerに持たせるようにした。</p>
            <p>＊</p>
            <p>しかし、pthread_kill()を使えばもっとスマートにできるのではないか？</p>
            <p>使ったことないから確証はないが、スレッドに対してシグナルを投げられるので、poll()を起こすのに使えるかな、と。</p>
            <p>それがうまく行くなら、sucrose::GamepadManagerにメンバとしてデータを持たせる必要がなくなりそう。</p>
            <p>＊</p>
            <p>ひとまず、切断検出を先にやってからにしよう。</p>
            <p>とりあえずは動いてるわけだからな。</p>
        <hr />
        <div>
            <h2>2016/05/25 01:10</h2>
            <p>ちょっとやる気減退してきているような。</p>
            <p>＊</p>
            <p>主にudevが悪いと思う。</p>
            <p>でも、なんとか初回のゲームパッド接続検出処理はできた。</p>
            <p>過去のプロジェクトを参考にしつつ、多少処理は変えた。</p>
            <p>デバイスがゲームパッドかどうかのチェックを簡略化した感じ。</p>
            <p>しかし、evdevか。</p>
            <p>そんなのもあったな、っていう気持ち。</p>
            <p>1つのデバイスについて、/dev/input/jsXと/dev/input/eventXの2つが出てくるからなんだろうと思ったら、後者はevdevのデバイスらしい。</p>
            <p>過去のプロジェクトでは、確か見た目だけで判断して前者を使ってたんだけど、どうもこっちは古いらしい。</p>
            <p>evdevの方がフォースフィードバックにも対応してるとかなんとか。</p>
            <p>なので、今回はevdevの方を採用することにした。</p>
            <p>＊</p>
            <p>明日中には、少なくともリアルタイムのゲームパッド接続検出を仕上げてしまいたい。</p>
            <p>切断についても、同じ処理の中に含ませられると思うし、やってしまいたいところ。</p>
            <p>で、接続・切断ができたら次はゲームパッドの状態変化検知だけど、これは多少時間かかるだろうな。</p>
            <p>デバイスをオープンしてどうの、という処理が必要になってくるわけだし。</p>
        </div>
        <hr />
        <div>
            <h2>2016/05/23 23:50</h2>
            <p>sucrose::GamepadManagerの作成に入り始めた。</p>
            <p>＊</p>
            <p>ゲームパッド接続イベントについて、イベントハンドラとかイベントデータとかイベントハンドラ集合とかを作ったのでいよいよ本体。</p>
            <p>しかし、午後に野暮用で出かけたせいか、暑かったせいもあり以降やる気出んで途中まで。</p>
            <p>なんとか、ただGamepadManagerを生成する部分までは書いたので、明日はその中身。</p>
            <p>udevを利用して、ゲームパッドの接続を検出する。</p>
            <p>多分、その辺は過去のプロジェクトのソースを流用できるはず。</p>
            <p>参考にして手早く済ませたい。</p>
        </div>
        <hr />
        <div>
            <h2>2016/05/20 23:56</h2>
            <p>昨日の変更は失敗だったかもしれない。</p>
            <p>＊</p>
            <p>ゲーム固有データ初期化時に、ベースシステムデータを参照できないので、描画イベント内でベースシステムデータ→ゲーム固有データ→OpenGLコンテキストが参照できない、のが問題だったんだけど。</p>
            <p>改めて考えてみたら、イベントハンドラにはラムダ式を使えるようにしているので、描画イベント生成前に生成しているOpenGLコンテキストの参照を描画イベント生成時に渡せばそれで見られるわ。</p>
            <p>ラムダ式のような構文を使えない、あるいは使いにくい言語とかのために作った、と考えれば全く使い道がないわけでもないか？</p>
            <p>それに、ラムダ式の参照だけだと、相互に参照し合う、みたいな状態への対応が難しいか。</p>
            <p>いや、そんな構成にすること自体よくないんだが。</p>
            <p>＊</p>
            <p>あとは、ベースシステム起動時に使うデータが、実行中常に触れる状態になってるのもなんか気になる。</p>
            <p>実装済みのデータで言えば、ウィンドウのイベントハンドラ。</p>
            <p>これはベースシステム起動時に生成するウィンドウで使用するためのものなので、それ以降は必要がなくなる。</p>
            <p>しかし、実行中もsucrose::setWindowEventHandlers()を呼び出せてしまう。</p>
            <p>意味は全くないが。</p>
            <p>しかし意味がないものを呼び出せるというのはなんだか気持ちが悪い。</p>
            <p>＊</p>
            <p>そこで、ベースシステム起動時にのみ使用するデータと、実行中も使用するデータの2つに分ける、という案を思い付いた。</p>
            <p>前者はBaseArgs、後者はBaseContextとかそんな名前で。</p>
            <p>例えばゲーム固有データは実行中も使用するので、後者に格納される。</p>
            <p>ゲーム側からは、BaseArgsはゲーム初期化時には参照できるが、以降は参照できなくなる。</p>
            <p>今までベースシステムデータの参照を必要としていた部分は、BaseContextの参照に置き換わるような感じ。</p>
            <p>＊</p>
            <p>せっかくbitbucketに課題管理システムがあるのだから、活用するべきかもしれない。</p>
            <p>少なくとも今のプロジェクト作ってからは一度も使っていない。</p>
            <p>思い付いた案をここに書いておくだけでも、書かないよりましだとは思う。</p>
            <p>しかし、そのうちどこに書いたのかとか、むしろ書いたこと自体忘れてしまうだろう。</p>
            <p>そうなる前に、課題として投稿しておくべきだろうな。</p>
        </div>
        <hr />
        <div>
            <h2>2016/05/20 17:05</h2>
            <p>ゲームパッドの入力取得の構成を考えている。</p>
            <p>＊</p>
            <p>古いプロジェクトで作ったやつをそのまま使えば楽なのでは、と思いもしたのだが。</p>
            <p>前に作ったやつは、いい加減にもほどがあるような構成だった気がする、と思って検索してみた。</p>
            <p>古いプロジェクト全てに対しfindでファイルを検索したところ、どうやらdp時代に作ったものが最後だったようだ。</p>
            <p>それより後のプロジェクトでは、そこに辿り着く前に作り直してたんだな。</p>
            <p>＊</p>
            <p>ファイル構成をぱっと見て記憶を探ったが、確かこんな感じだったはずだ。</p>
            <p>・ゲームパッド接続管理（GamePadManager）で、ゲームパッドの接続、切断を検知</p>
            <p>・接続、切断時には、ゲームパッドに結び付くデータ（GamePadKey）がイベントハンドラの引数として得られる</p>
            <p>・GamePadKeyを引数に、ゲームパッド1つを表現するオブジェクト（GamePad）を生成することで、対応するゲームパッドの状態変化（ボタンを押した、離したなど）を検知できるようになる</p>
            <p>＊</p>
            <p>GamePadがおかしい。</p>
            <p>ゲームパッドは人の手で自由に接続したり切断したりできるのに、それをプログラムが任意に生成できるオブジェクトとして表現するのは違和感がある。</p>
            <p>ゲームパッドが切断されているのにGamePadが存在し続けることができるし、逆にゲームパッドが接続されているのにGamePadが存在しないことにもできる。</p>
            <p>そういう不自然な構成は、実際に利用しようとすると扱いにくく感じることが多いのだ。</p>
            <p>＊</p>
            <p>そんなわけで、少なくとも物理的なゲームパッドに直接結び付く低レイヤー部分では、任意に生成可能なゲームパッドを表現するオブジェクトなんてのは用意しない方がいいだろうな。</p>
            <p>GamePadManagerにゲームパッドの接続、切断検知以外に、ゲームパッドの状態変化についてもイベントを処理させる形がいいかもしれない。</p>
            <p>GamePadManager周りについては、古いプロジェクトの処理を参考にしてもいいかもしれないな。</p>
            <p>それと、GamePadはGamepadと記述することにしよう。</p>
        </div>
        <hr />
        <div>
            <h2>2016/05/19 21:10</h2>
            <p>描画イベントハンドラ内で、ゲーム固有データを参照できるようにした。</p>
            <p>＊</p>
            <p>具体的には、描画イベントデータの中にベースシステムデータを追加した感じ。</p>
            <p>描画イベントデータからベースシステムデータの参照を取得し、そこからゲーム固有データの参照を取得する。</p>
            <p>これで、昨日の時点で問題になっていた部分は解決した。</p>
            <p>2つ関数を呼ばないとゲーム固有データの参照を取得できないとか、なんかめんどうな気もするけど、どうにかするとしたら後でいいだろう。</p>
            <p>取得できないよりはずっとましだ。</p>
            <p>＊</p>
            <p>他に目についた問題点といえば、描画処理に関する点だ。</p>
            <p>ウィンドウのサイズを変更すると再描画要求が発生し、再描画のために描画イベントハンドラが呼び出される。</p>
            <p>イベントハンドラ内で動作確認用のログをstd::printf()で出力しているのだが、ウィンドウサイズをぐりぐりと変更した後、サイズ変更をやめても少しの間ログが出続ける。</p>
            <p>垂直同期するような処理はまだ入れてないはずなのに、描画で処理遅延が出るというのは違和感あったので、調べてみたらどうも垂直同期が行なわれていたようだ。</p>
            <p>これはなにか対処すべきか、と思ったけど普通に考えて描画イベント内で描画処理をしなければいいだけなんだよなぁ。</p>
            <p>変にイベントをまとめたりしてもおかしなことになりそうだし。</p>
            <p>＊</p>
            <p>一段落した感触がある。</p>
            <p>次はどこを進めようかな。</p>
            <p>ゲームとして最低限必要なもの、と考えた場合、操作系を作るべきか。</p>
            <p>マウスやキーボード、そしてゲームパッド。</p>
            <p>ゲームパッドをメインに据えたいところだけど、ゲームパッドは個体ごとの仕様がばらばらすぎて、うまく管理したいけどまだいい案がないんだよなぁ。</p>
            <p>まぁ、管理部分については後回しでもいいだろう。</p>
            <p>低レイヤーなものでも、ゲームパッドが扱えればゲームパッドを動かすと画面に変化が出る、ということができるようになる。</p>
            <p>今後上に何か被せるとしても、そのまま使えそうな根底部分の処理を作っていこう。</p>
            <p>＊</p>
            <p>入力ができたら、次は音かな。</p>
            <p>画面への描画、プレイヤーの入力処理、音声出力。</p>
            <p>この3つができれば、ゲームと呼んでいいものが作れるだろう。</p>
        </div>
        <hr />
        <div>
            <h2>2016/05/18 19:13</h2>
            <p>ゲーム固有のデータを扱えるようにした。</p>
            <p>＊</p>
            <p>結局、ベースシステムデータに対し設定する関数を作り、それをゲーム初期化関数内から呼び出す形を取った。</p>
            <p>設定ファイルに関数名を記述する形にしなかったのは、簡単に言えばそこまでする必要はないと思ったからだ。</p>
            <p>ベースシステムデータの場合は、ベースシステムメイン関数を呼び出す前にゲーム初期化関数が呼び出され、その時点でベースシステムデータが必要になるため、ベースシステムメイン関数とは別に用意しておかなければならないという事情があった。</p>
            <p>しかし今回の場合は、似たような形を取ったところでゲーム初期化関数に入った時点ですでにゲーム固有データが生成されている、初期化関数内では生成する処理を書かなくて済む、程度の恩恵しか得られない。</p>
            <p>たかがその程度のことのために設定ファイルの要素を増やすこともないだろう。</p>
            <p>プログラムに記述する形であれば記述ミスなんかはコンパイラがエラーにしてくれるけど、設定ファイルの場合はその辺も自分でどうにかする必要があるから面倒だし。</p>
            <p>＊</p>
            <p>さて、まだ問題は解決していない。</p>
            <p>というより、大きな修正が必要になりそうな別の問題が出てきた。</p>
            <p>今日作った機能を使い、昨日作った表示プログラムを修正した。<a href="https://bitbucket.org/tekuto/painttest/src/0564ba24f354427d8151c1fe96a573b0783497f9/src/painttest/painttest.cpp?at=master&fileviewer=file-view-default" target="_blank">これ。</a></p>
            <p>valgrindでメモリ解放漏れがないか確認したいが、OpenGLを使っているためかこけてしまう。</p>
            <p>想定では解放漏れはないんだけど。</p>
            <p>その点はともかく、描画イベント中にベースシステムデータを参照することができないという問題が新たに出てきた。</p>
            <p>OpenGLコンテキストはベースシステムデータ内のゲーム固有データの中に持たせてあるため、素直にやろうとするとOpenGLによる描画ができないのだ。</p>
            <p>なので、今はその場しのぎな処理で対応している。</p>
            <p>ゲーム初期化時にゲーム固有データのポインタをグローバルに配置し、描画イベントでグローバルに配置したゲーム固有データのポインタを参照、OpenGLコンテキストを使用する、といった具合だ。</p>
            <p>こんな見苦しいやり方は、解放漏れ並みに容認できないので早急に修正したい。</p>
            <p>ぱっと思い付く解決法としては、ウィンドウ生成関数、つまりsucrose::newWindow()に引数としてベースシステムデータの参照を追加し、それをイベントハンドラに渡す、という方法だ。</p>
            <p>あらゆる箇所でそんなことをすればベースシステムデータへの依存度がやばくなりそう、とは思うものの、そもそもベースシステムありきのシステムなのだから、むしろよく今までやらずにやってこれたもんだな、とも思う。</p>
            <p>ソースの色々な場所に、std::printf()によるデバッグログ出力を記述しているが、これも将来的にはベースシステムデータの中にログ出力用データを配置して、それを使ってログ出力したいとも考えているし。</p>
            <p>とりあえず、描画イベントの件については上に書いた通りの方法でやってみるか。</p>
            <p>他の方法も思いつかないし、あったところでどうせ余計にトリッキーになるし。</p>
        </div>
        <hr />
        <div>
            <h2>2016/05/18 00:36</h2>
            <p>とりあえず表示プログラムできた。<a href="https://bitbucket.org/tekuto/painttest" target="_blank">これ。</a></p>
            <p>＊</p>
            <p>今のところソースファイルは1つだけ。<a href="https://bitbucket.org/tekuto/painttest/src/4b54a65eb483fd26c8bc3d56899b70949027457e/src/painttest/painttest.cpp?at=master&fileviewer=file-view-default" target="_blank">これ。</a>
            <p>ゲーム初期化処理でウィンドウイベントハンドラを生成し、それをベースシステムデータに設定してるだけ。</p>
            <p>OpenGLコンテキストの生成もしてるが、ウィンドウ自体の生成はしていない。</p>
            <p>構成としては想定通りだ。</p>
            <p>しかし、現時点ではの話とはいえゲーム自体にデータを持たせられないのはやはり問題だった。</p>
            <p>おかげで、OpenGLのコンテキストとかイベントハンドラの実体とか、そういうのはグローバルに置いてしまっていて、解放処理もしていない。</p>
            <p>ゲーム固有データをベースシステムデータに設定する処理を早急に作るべきか。</p>
            <p>どのように構成するべきかな。</p>
            <p>作ってみた感触としてはゲーム固有データはほぼ必須になる気がするし、ベースシステムデータみたく設定ファイルにイニシャライザ、ファイナライザの関数名を記述する形にするか？</p>
            <p>それで、ゲーム初期化処理の関数内に来た時にはすでにデータは生成されている、みたいな。</p>
            <p>あるいは上に書いたように、ゲーム初期化関数内で、ベースシステムデータに設定する形にするか。</p>
            <p>この場合設定するのは任意となる。</p>
            <p>よく考えて構成を決めるべきポイントだろうな。</p>
            <p>よく考えてみることにしよう。</p>
        </div>
        <hr />
        <div>
            <h2>2016/05/16 23:03</h2>
            <p>XInitThreads()の呼び出しとモジュール分割、両方完了。</p>
            <p>＊</p>
            <p>それに、ベースシステムデータにデータを1つ追加した。</p>
            <p>ウィンドウイベントハンドラだ。</p>
            <p>設定関数も作った。</p>
            <p>ゲーム側からベースシステムデータにウィンドウイベントハンドラを設定すれば、ゲームのメインウィンドウ生成時にそのイベントハンドラが使われる。</p>
            <p>明日は今日作った機能を使って、ウィンドウに表示を行なうプログラムでも作ってみるか。</p>
            <p>しかし現時点ではゲーム自体にはデータを持たせられないんだよなぁ。</p>
            <p>やるべきことはたくさんある。</p>
            <p>どこから手を出したものか。</p>
        </div>
        <hr />
        <div>
            <h2>2016/05/14 01:16</h2>
            <p>モジュールの初期処理、終了処理の対応ができた。</p>
            <p>＊</p>
            <p>次は、この機能を使ってsucrose側でXInitThreads()の呼び出しを追加するとしよう。</p>
            <p>モジュールの依存関係解決機能も使って、モジュール分割もするべきだろうな。</p>
            <p>それらが済んだら、いよいよベースシステム側とゲーム側の通信についても取りかかるか。</p>
            <p>いや、その前にまだやっておくべきことがあるか。</p>
            <p>現状ではベースシステム側とゲーム側とではモジュールの管理が別々になっている。</p>
            <p>そのため、両方で使われるモジュールがある場合、初期処理と終了処理が2回呼び出される可能性がある。</p>
            <p>だから、モジュールを集中管理するための仕組みを追加するべきかもしれない。</p>
            <p>とはいえ、現時点ではあまり初期処理や終了処理に頼らないため、まだ必要ないかも。</p>
            <p>XInitThreads()も、2回くらい呼び出しても多分平気だし。</p>
            <p>将来的には、多くのモジュールで初期処理と終了処理を使うことになるかもしれないけど。</p>
        </div>
        <hr />
        <div>
            <h2>2016/05/13 00:30</h2>
            <p>やる気出てる気がする。</p>
            <p>＊</p>
            <p>というわけで、モジュールの依存関係解決をやっつけた。</p>
            <p>今回の追加では、別パッケージのモジュールに依存するようなことはできない。</p>
            <p>あくまで同パッケージ内のみ。</p>
            <p>別パッケージのモジュールの指定方法をまだ決めてないから仕方がない。</p>
            <p>でもまぁ、これでもある程度はやれるはずだ。</p>
            <p>というわけで明日からは、初期化処理と終了処理の対応に入る。</p>
        </div>
        <hr />
        <div>
            <h2>2016/05/11 01:30</h2>
            <p>ゴールデンウィーク明けからやる気増してきた感ある。</p>
            <p>＊</p>
            <p>イベントハンドラについて大体処理の追加ができて、あとは実際にイベントが発生した時にイベントハンドラを呼び出すくらいになった。</p>
            <p>しかし、現在の仕様ではそろそろ限界な感じがある。</p>
            <p>モジュールの初期化処理が存在しないため、XInitThreads()を呼び出せていないので、記述自体は合っていてもX11をマルチスレッドで扱おうとしてこけたりしている。</p>
            <p>イベントハンドラが完了したら、モジュールの初期化処理と終了処理の対応を追加するべきか。</p>
            <p>いや、それをするにはモジュールの依存関係解決をやってからか？</p>
            <p>悩ましい。</p>
        </div>
        <hr />
        <div>
            <h2>2016/04/21 17:10</h2>
            <p>ベースシステム内で、OpenGLによる描画ができる、というところまで確認できた。</p>
            <p>＊</p>
            <p>次は描画処理をゲーム側で処理させたいところだが、それには多少手間がかかるな。</p>
            <p>流れとしては、ベースシステムデータにメインウィンドウに設定するイベントハンドラを用意し、ゲームの初期処理で描画イベント発生時の処理をイベントハンドラに追加、ベースシステムメイン関数でイベントハンドラを元にメインウィンドウを生成、となるんだろうけど。</p>
            <p>まず、イベントハンドラとかを作っていない。</p>
            <p>ウィンドウに関しても、イベントを全く処理していない。</p>
            <p>なので、作ってしまうとしよう。</p>
            <p>これらを作り終えたら、次はモジュールの依存関係の解決をやるか？</p>
            <p>現状、ゲームとベースシステム、それぞれ1モジュールしか読み込めないし不便だ。</p>
            <p>ベースシステムのライブラリに、ウィンドウの処理もOpenGLの処理も全て含めてしまっている状態だし。</p>
        </div>
        <hr />
        <div>
            <h2>2016/04/14 12:45</h2>
            <p>必要な処理はきちんと書かれていて、それ以外は書かれてなかったり手抜きだったりのいい感じのソースが書けた。</p>
            <p>＊</p>
            <p>というわけで、ウィンドウを表示するベースシステムが一応はできた。</p>
            <p>一応というだけあって、本当に表示するだけでそれ以外何もできないんだけど。</p>
            <p>おまけに表示を維持するために無限ループを回しているため、起動しているとCPU1コアの使用率が100%になる。</p>
            <p>しかしこれは大きな前進だ。ようやく表示まで漕ぎ着けた。</p>
            <p>次はOpenGLに対応させたいところだ。</p>
            <p>それができれば、ウィンドウ内に何かを書いて表示することができるし。</p>
            <p>それに関しても、とりあえずはベースシステム内で完結させるか。</p>
            <p>ゲーム側で描写処理をしたいところではあるが、それにはベースシステムとゲーム間のやりとりについて固めなくてはいけないので多少めんどうだし。</p>
            <p>それがない状態で、とりあえずOpenGLが使えるようになるところまでを、先に確認するべきだろうな。</p>
            <p>まぁ、OpenGLについても、基本は古いプロジェクトのソースを参考にすればどうにかなるはずだ。</p>
            <p>ウィンドウと同じように、参考にした上で簡略化や省略をして、暫定的なものを小さくまとめて実装するとしよう。</p>
        </div>
        <hr />
        <div>
            <h2>2016/04/13 14:25</h2>
            <p>とりあえずウィンドウを作らんと始まらぬ、と古いプロジェクトのソースを見たがなんだこれは。</p>
            <p>＊</p>
            <p>本当に私が書いたのか？とコミットログを見たところ、ウィンドウ周りのソースをいじっていたのは2年くらい前のようだ。</p>
            <p>無駄に複雑になってるのはこの際無視するとしても、なんだか構成が頭悪い。</p>
            <p>std::unique_ptrの扱いにまだ慣れてなかったのだろうか？</p>
            <p>自前のデリータを作ればもっと分かりやすく書けそうな処理を見つけ、もやもやとした気分になった。</p>
            <p>自前のデリータが使えることを知らなかったわけではなさそうだ。</p>
            <p>ウィンドウの他のデータに関してはそれを使っているところもある。</p>
            <p>やはり、昔の自分のソースは他人のソースなのだな。</p>
            <p>わけがわからないよ。</p>
        </div>
        <hr />
        <div>
            <h2>2016/04/09 00:50</h2>
            <p>困ったな、どっから作り始めたものか。</p>
            <p>＊</p>
            <p>やはりベースシステムメイン関数か？</p>
            <p>データはどういう処理にするのかが決まらんことには構成しようもないし。</p>
            <p>データに対する処理はベースシステムデータ構築時と、ゲームによる初期処理の2つあるが、それは後にするべきだろうな。</p>
            <p>とりあえず表示に関する部分から始めるべきか。</p>
            <p>ウィンドウ生成処理を古いプロジェクトから持ってきて構成するか。</p>
        </div>
        <hr />
        <div>
            <h2>2016/03/31 00:40</h2>
            <p>さくっとできそうだったから、ベースシステムメイン関数についての修正は昨日のうちに終わらせた。</p>
            <p>＊</p>
            <p>で、今日はゲームの初期化処理についての修正をやった。</p>
            <p>とりあえずこれを0.8.0とする予定だけど、テストで使用するモジュールとか、その辺もうちょい整えたいな。</p>
            <p>明日それをやってから0.8.0としてpushし、先に進もう。</p>
        </div>
        <hr />
        <div>
            <h2>2016/03/29 21:25</h2>
            <p>もやもやが多少消えたからか、やる気出てきた気がする。</p>
            <p>＊</p>
            <p>既存のゲームデータ生成、破棄処理をほぼそのまま引っ張ってきて、ベースシステムデータ生成、破棄処理を追加した。</p>
            <p>次はベースシステムメイン関数の引数にベースシステムデータを参照を追加し、利用できるように修正しよう。</p>
            <p>現状ではmain()でcandymaker::Basesystem内のベースシステムメイン関数を直接呼び出しているが、ベースシステム実行関数を別に作った方がいい気がする。</p>
            <p>main()でベースシステムデータを直接参照するのはレイヤーが違うと思うし。</p>
            <p>それが終わったらゲームの初期処理についてか。</p>
            <p>こっちは、今の構成は破棄して新しい構成にするわけだから、まずは別のソースファイルに作った方がいいだろうな。</p>
        </div>
        <hr />
        <div>
            <h2>2016/03/29 00:50</h2>
            <p>さすがにモジュールの扱いを段階分けするのは完了している。</p>
            <p>＊</p>
            <p>しかしモジュールの依存情報の解釈についてはまだ。</p>
            <p>というより、色々考えてたらこれもう後回しでいい感じがしているので放置。</p>
            <p>ゲーム生成処理をベースシステム関数内でやるとかいうのもありえんのでやらない。</p>
            <p>それしたところで、大した違いもないだろう。</p>
            <p>＊</p>
            <p>最近は、ゲームとベースシステムの構成が間違っているのではないかと考えている。</p>
            <p>ゲームはベースシステムにアクセスする必要があるが、そのうまい方法を思いつかない、というのが現時点での大きな問題点だ。</p>
            <p>色々考えた結果、ベースシステムがメイン関数のみの構成なのがいけないのだ。</p>
            <p>ベースシステムは処理だけでなくデータも持つべきだ。</p>
            <p>逆に、ゲームの方は初期処理だけでいい。</p>
            <p>ゲームにデータなど必要ない。</p>
            <p>そのように変更する場合、処理の大まかな流れは以下のようになる。</p>
            <p>＊</p>
            <p>1.ベースシステムデータ生成</p>
            <p>2.ゲームの初期処理</p>
            <p>3.ベースシステム実行</p>
            <p>4.ベースシステムデータ破棄</p>
            <p>＊</p>
            <p>2は引数としてベースシステムデータの参照を受け取り、それに対して処理を行なう。</p>
            <p>3はゲームが動作している段階で、4はゲーム終了後の後処理となる。</p>
            <p>＊</p>
            <p>さて、どのように作業を進めたものか。</p>
            <p>まずはベースシステムデータの生成、破棄を進めるべきか。</p>
            <p>これ自体はただの処理追加なので、楽にできるだろう。</p>
            <p>むしろそれを先にやっておかないと、他の変更はベースシステムデータの存在が前提なので作業を進めにくくなりそう。</p>
            <p>ベースシステム関数の引数にベースシステムデータの参照を追加するのもそうだし、ゲームの初期処理についてもベースシステムデータの参照を引数として渡す。</p>
            <p>それらが完了したら、ゲームからベースシステムにアクセスできるようになるわけだし、いい加減ゲームやベースシステムの方の作成に移ろう。</p>
            <p>candymakerをいじくるのはうんざりしてきているのだ。</p>
            <p>モチベーションが一向に上がらない原因はそこだと考えている。</p>
        </div>
        <hr />
        <div>
            <h2>2016/02/06 00:10</h2>
            <p>書こうとして、またも違和感。</p>
            <p>＊</p>
            <p>設定ファイルに関係する処理が置かれているディレクトリの方にソースを配置すると言ったが、それもおかしい。</p>
            <p>設定ファイルの解析処理に関係する処理なんて書かんのだから、そんなところに配置するのは不自然だ。</p>
            <p>設定ファイルについては、解析結果を参照するだけだ。</p>
            <p>ならば設定ファイルのソースが配置されているディレクトリと同列辺りに配置するのが筋だろう。</p>
            <p>昨日は違うか、と言っていた方が正しいような気がしている。</p>
            <p>やはり頭が茹で上がるとまともな思考にならん感じある。</p>
            <p>多少時間がかかっても、深く考えを巡らせるべきだろうか。</p>
            <p>そんな考えを認めてしまうと、考えるだけで無駄に時間が過ぎる気がするから、認めたくはないのだが。</p>
            <p>＊</p>
            <p>ふと思いついて、linuxのインストールCDに含まれているメモリチェックツールを使ったところ、やはりメモリがもうだめな雰囲気だった。</p>
            <p>gccがSEGVで死ぬのはおそらくそれが原因だろう。</p>
            <p>むしろ、それ以外ではほぼ問題が起こっていない理由が分からない。</p>
            <p>並列コンパイルとか高負荷の処理を流さん限り使わないような箇所がおかしくなっているのだろうか。</p>
            <p>ともあれ、運が悪いとemergeがこけるというのがいい加減嫌になってきたし、原因がメモリであろうことも特定できたので、交換することにした。</p>
            <p>今使ってるのは、安いからという理由だけでよく知らんメーカーのメモリを使っていたので、今回はトランセンドにする。</p>
            <p>これまた比較的安い気がする、というのも決めた理由の一つだけど。</p>
        </div>
        <hr />
        <div>
            <h2>2016/02/04 23:50</h2>
            <p>どうにもうまくまとまらんと思ったら、モジュールの扱いが低レイヤーすぎるのがいけないんだろうな。</p>
            <p>＊</p>
            <p>パッケージ情報ファイルに依存情報の追加はしたのだが、それをどう扱ったものか考えていた。</p>
            <p>現在、モジュールのロードについては、モジュールのパスを引数にして行なっている。</p>
            <p>依存情報を扱うなら、例えば依存情報も引数として渡し、そっちのロードを先にやる、という形になるだろうが、現状だとそれはまず無理だ。</p>
            <p>モジュールのパスというのはつまり、設定ファイルの内容を解釈した後のものだ。</p>
            <p>モジュールのロード処理中では、設定ファイルを解釈するような処理を行なっていない。</p>
            <p>依存情報というのは設定ファイルレベルの情報なので、そんなものを渡したところで扱いようがないのだ。</p>
            <p>ならばモジュールのパスではなく、設定ファイルレベルのモジュール名やら設定ファイルの内容やらを渡せばいいかもしれないが、それはしたくない。</p>
            <p>少なくとも、最終的には現在存在するモジュールのロード処理とかは必要になるのだ。</p>
            <p>それをわざわざ壊して複雑化させるなど間違っている。</p>
            <p>＊</p>
            <p>というわけで、モジュールの扱いについて、現在作ってある処理を利用する、より設定ファイル寄りの処理を追加するべきなのだろう、という結論に達した。</p>
            <p>結論に達するのが遅い気がする。やはりやる気が足りてない気がする。</p>
            <p>間に土日を挟んだり、健康診断で血を抜かれたりしたからといって、もうちょい早くその結論を出せたはずだ。</p>
            <p>それはともかく。ソースを見直したところ、現在あるモジュールを扱う処理だが、これはモジュールと言うよりローダーと言った方が正しい気がする。</p>
            <p>この辺は将来的にモジュール化して、様々な形式のモジュールを扱えるようにしたい箇所だし。</p>
            <p>だから名前を変えて、これから作る処理を新たなモジュールを扱う処理に…と思ったが、それもちょっと違うか。</p>
            <p>これから作るのは、設定ファイルの内容を解釈したりといった処理が入るから、そこに置くべきではないな。</p>
            <p>置くなら設定ファイルに関係する処理が置かれているディレクトリの方だ。</p>
            <p>危ない危ない。全く、先が思いやられる。</p>
        </div>
        <hr />
        <div>
            <h2>2016/01/28 17:05</h2>
            <p>やはり想定が甘い。</p>
            <p>＊</p>
            <p>モジュールの扱いのライブラリ化についてやるなら、暫定的、の部分をもっと細かく考えないと進められないな。</p>
            <p>依存関係解決についても、きちんとやるならパッケージ設定ファイルとか必要になるし。</p>
            <p>こちらも機能を限定した、暫定的なものから作っていくべきだろうな。</p>
            <p>やはり依存関係解決から作っていこう。</p>
            <p>パッケージ情報ファイルに依存情報を追加し、同一パッケージ内のみ対応、といった感じか？</p>
        </div>
        <hr />
        <div>
            <h2>2016/01/27 15:43</h2>
            <p>ベースシステムのメイン取得→ゲーム生成→ベースシステム実行という流れが違う気がしてきた。</p>
            <p>＊</p>
            <p>ゲーム生成関数の引数に、ベースシステムで使用するデータを渡すということは、そのデータを生成する必要があるけど、そのデータ生成どうすんの、という話だ。</p>
            <p>そこで考えたことには、ゲームの生成はベースシステムを実行してから、その中でやるべきか、ということ。</p>
            <p>これなら、ゲーム生成関数に渡すデータはベースシステム関数内で生成できる。</p>
            <p>しかし、ゲーム生成・破棄関数の取得までは定型処理だし、ベースシステム関数内でやるべきではないだろう。</p>
            <p>でも、それで本当にいけるか？ゲーム生成関数のシンボル名はベースシステムに依存するわけだし、関数の取得もベースシステム関数内でないとできないのでは？</p>
            <p>となると、モジュールのロードをしてからモジュールの参照をベースシステム関数に渡す？</p>
            <p>ということは、モジュールの型や関係する関数はライブラリ化する必要がありそうだなぁ。</p>
            <p>ライブラリ化については後回しにしたいところだが、それでできるだろうか？</p>
            <p>そもそも現時点での実装では、モジュールの依存関係解決などやっていないのだ。</p>
            <p>ライブラリだけ作ってもどうしようもない。</p>
            <p>＊</p>
            <p>色々と問題点が浮かび上がってきたな。とりあえずまとめてみよう。</p>
            <p>a.ゲーム生成処理の呼び出しをベースシステム関数内に移動</p>
            <p>b.モジュールの扱いをライブラリ化</p>
            <p>c.モジュールの依存関係解決</p>
            <p>こんな感じ？</p>
            <p>aを実現したいが、そのためにはbとcが必須。</p>
            <p>bは実現したところでcがないと活用できない。</p>
            <p>cは前提条件なし。</p>
            <p>bかcから始めよう。</p>
            <p>bはとりあえず暫定的なものでいいだろう。想定ではかなり簡単にできるはずだ。</p>
            <p>問題はcか。前のプロジェクトで似たような処理は作ったはずだから、それを活用できれば早いか？</p>
            <p>＊</p>
            <p>とりあえず現在の状態を0.6.0としてしまおう。</p>
        </div>
        <hr />
        <div>
            <h2>2016/01/26 01:25</h2>
            <p>ゲームの生成まではできた。</p>
            <p>＊</p>
            <p>しかし、このままでは生成ができるだけで、ベースシステムとはなんの通信もできない。</p>
            <p>どうするかなぁ。通信インターフェースを作るのまで含めるか、それともこの辺で、ソースを整えて0.6.0とするか。</p>
            <p>ソースを整えるのはやるとしよう。</p>
            <p>＊</p>
            <p>ベースシステムとゲームの通信はどうしよう。</p>
            <p>ベースシステムのメイン取得→ゲーム生成→ベースシステム実行としているが、ベースシステム実行時に生成したゲームを引数として渡すか？</p>
            <p>今の構想ではそれは向かないように思える。</p>
            <p>ベースシステムからゲームに対してアクションをかけるということは、ゲーム側に決まった関数でも定義しておかなければ難しいだろう。</p>
            <p>そして、ゲームにはできれば決まった関数というのは用意したくない。</p>
            <p>ゲーム側の必須関数は生成と破棄だけにしたいのだ。</p>
            <p>ゲーム側の生成関数の引数に、ベースシステムで使用するデータを渡し、そこにイベントハンドラを設定していく、という形になるだろうか。</p>
            <p>この形なら、決まった関数はベースシステム側に作られ、それを介してベースシステム側からゲーム側を操作できるようになるはずだ。</p>
        </div>
        <hr />
        <div>
            <h2>2016/01/19 00:50</h2>
            <p>お腹きゅうきゅうする。</p>
            <p>＊</p>
            <p>raspberrypiはそろそろもういいかなという感じ。</p>
            <p>というよりやりすぎた感じ。</p>
            <p>やりすぎちゃって、軽く燃え尽きちゃってる感じある。</p>
            <p>このままではいかんと思い、candymakerのソース眺めたりなどしていた。</p>
            <p>戻らねば。</p>
            <p>＊</p>
            <p>やりすぎたかいもあり、なかなかのものができた、と思うんだけど、最新の修正を適用したものの動作確認がまだ。</p>
            <p>1人では動作確認できないのが厳しいところだ。</p>
            <p>理論的にやってできないことはないはずなのだが、なぜかうまくいかなくて困る。</p>
        </div>
        <hr />
        <div>
            <h2>2015/12/19 04:15</h2>
            <p>最近はraspberrypiをいじくりまくってた。</p>
            <p>＊</p>
            <p>そのかいあって、常にxlink kaiを動かすraspberrypiがほぼできた。</p>
            <p>私の作ったプログラムにより、raspberrypi側の無線LANアダプタを自分で操作しなくても、MACアドレスに対応したPSPのネットワークに自動接続できる。</p>
            <p>また、起動時にメモリ上にSquashFSのrootfsを配置する形にした。</p>
            <p>これにより、起動後はSDカードを取り外しても動作し続けることができる。</p>
            <p>raspberrypiにSDカードは完全には差さらず、出っ張るためうっかり触って抜けてしまったり、カードやスロットなどが破損したりということが起きかねない。</p>
            <p>それに、マウントした状態で取り外したり、電源コードを抜いたりすると、ファイルシステムが破損する可能性だってある。</p>
            <p>実際、それでSDカードのファイルシステムの再構築が必要になったことが何度かある。</p>
            <p>そもそもraspberrypiに電源スイッチなどないし、普通に終了するためには何らかの方法でログインし、shutdownコマンドを叩かなければならない。</p>
            <p>それが電源コードを抜いて電源を落としても多分大丈夫になった、というのは大きい。</p>
            <p>＊</p>
            <p>私の作ったプログラムはもう少し修正する必要がある。</p>
            <p>周囲のアドホックネットワークの検索処理を実行する間隔が短すぎて、他の通信に悪影響が出てしまっている。</p>
            <p>しかし、どうスリープしたものか。固定時間か、一定間隔毎に処理するように計算してスリープするか。</p>
        </div>
        <hr />
        <div>
            <h2>2015/11/29 00:20</h2>
            <p>昨日、いつにも増してやる気が出ん、だるいと思ったら微熱が出ていた。</p>
            <p>＊</p>
            <p>それでも、なんとかパッケージ情報に記述したゲームについての情報を取り出す処理は追加できた。</p>
            <p>月曜には、ゲームのロード処理をメイン関数に追加したいところ。</p>
            <p>明日はraspberrypiをいじくるとしよう。</p>
        </div>
        <hr />
        <div>
            <h2>2015/11/27 00:27</h2>
            <p>ショートカットファイルからゲームの参照情報を取り出すのはできた。</p>
            <p>＊</p>
            <p>まぁ、記述内容がベースシステムの参照情報とほぼ同じだから、処理をコピーして少し修正して作ったんだけど。</p>
            <p>次はパッケージ情報にゲームについての情報を追加して、それを取り出す処理かな。</p>
            <p>こっちも、ベースシステムの情報と大体似たような感じだから、処理をコピー、修正して作れば楽だろうな。</p>
            <p>その取り出した情報を使ってゲームをロードし、ベースシステムの実行時に引数として渡す、というところまで明日中にできればいいんだが。</p>
        </div>
        <hr />
        <div>
            <h2>2015/11/25 19:51</h2>
            <p>というわけで、0.5.0できた。</p>
            <p>＊</p>
            <p>ベースシステムの起動までできたところで0.5.0とした。</p>
            <p>この次はゲームの生成、破棄とゲームの制御となるわけだが、どうするかちょっと考え中。</p>
            <p>昨日の日記書いてた時には、ゲームの生成や破棄はベースシステム内でやろうかと考えたりしていたのだが、それはあまり望ましくない気がする。</p>
            <p>ゲームの生成や破棄は、色々な実装方法が思い付くような処理ではない。</p>
            <p>簡単に言えば、newとdeleteなわけだ。</p>
            <p>ならば、わざわざベースシステム側にそれを任せることもない気がする。</p>
            <p>そうすれば、ベースシステム側が設定ファイルを解析したり、モジュールをロードしたりする必要はなくなる。</p>
            <p>＊</p>
            <p>どちらにせよ、まずはショートカットファイルからゲームについての情報を取り出す処理を追加するところからだろうか。</p>
            <p>どこに記述したところで、その処理自体は変わらないだろうし。</p>
        </div>
        <hr />
        <div>
            <h2>2015/11/25 02:30</h2>
            <p>モジュールのロード、ロードしたモジュールからの関数取得も完了。</p>
            <p>＊</p>
            <p>これを使ってベースシステムの起動をするわけだが、それにはダミーのベースシステムを作る方が先か。</p>
            <p>中身空っぽでいいから、これはさっとできるだろうな。</p>
            <p>次はどうするべきかな。</p>
            <p>ベースシステムの実行の次、となるとゲームの起動だろうか。</p>
            <p>それをするとなると、ベースシステムから設定ファイルを読んだりモジュールをロードしたりする必要があるだろうから、ライブラリを作る必要がありそうだなぁ。</p>
            <p>＊</p>
            <p>3連休中、raspberrypiをいじくっていた。</p>
            <p>とりあえずの成果として、比較的簡単にraspberrypi用のgentooのrootfsを生成できるようになった。</p>
            <p>私は出来合いのカーネルとか使いたくないので、というよりカーネルの機能を増やしたい時とかに備えてカーネルは時前でビルドしたいので、その辺は自分でやる必要があるけど。</p>
            <p>で、raspberrypi版のxlink kaiとかあったんで、xlink kaiを使うためだけのraspberrypiを作れないか画策中。</p>
            <p>xlink kaiは昔windows版を使っていたことがあったが、PSPとパソコンをアドホックで接続するために、わざわざパソコン側で操作が必要になるのが面倒だった。</p>
            <p>なので、その辺の操作を自動化してみたい。</p>
            <p>しかし、アドホック接続についての情報がうまく見つからない。</p>
            <p>特定のPSPを示す識別子みたいのってないのかな。</p>
        </div>
        <hr />
        <div>
            <h2>2015/11/17 00:15</h2>
            <p>とりあえずテストプログラムのビルドルールを分離させた、のだけど。</p>
            <p>＊</p>
            <p>今のままでは、configure時にテストプログラムについてもビルドするよって指定しないとビルドしてくれない。</p>
            <p>確か前は、そういう風になってしまうのを嫌ってテストプログラムのビルド処理を分けなかったんだった気がする。</p>
            <p>実際面倒だし、テストプログラムが増えるたびにconfigureコマンドのオプション指定が増えることになる。さすがに嫌だ。</p>
            <p>＊</p>
            <p>依存関係を定義できるようにするべきかもしれない。</p>
            <p>このプログラムをビルドする場合、他のプログラムもビルドする、みたいな指定。</p>
            <p>そういう仕組みを作れば、あるプログラムに関連するテストプログラムの自動的なビルドも可能になる。</p>
        </div>
        <hr />
        <div>
            <h2>2015/11/14 00:18</h2>
            <p>いかんいかん。典型的な三日坊主じゃないか。</p>
            <p>＊</p>
            <p>微妙に詰まっている。</p>
            <p>モジュールロード機能のテストコードを作ったので、そのテストを通そうとしたところで困った。</p>
            <p>テストでモジュールをロードする必要があるので、そのためのダミーモジュールを作る、それはいい。</p>
            <p>しかし、現状ではテストコードにライブラリやらなんやらを関連付けることができない。</p>
            <p>なので、どう変えるべきか考え中。</p>
            <p>よく考えたら、テストプログラムの在り方がおかしい気がする。</p>
            <p>なんらかのプログラムに付随するものとしてるから、テストに対して他の何かを関連付けられないのだ。</p>
            <p>最初からテストプログラムも独立したプログラムとして扱えば、こんなことにはならないはずだ。</p>
            <p>不要にビルド処理を複雑にしてしまっている雰囲気がする。</p>
            <p>改善しなければ。</p>
        </div>
        <hr />
        <div>
            <h2>2015/11/11 00:17</h2>
            <p>0.4.0できた。</p>
            <p>＊</p>
            <p>パッケージ情報ファイルとショートカットファイルの内容から、取得できる範囲の情報を取得、表示するところまでやって0.4.0とした。</p>
            <p>取得した情報を使えばベースシステムの起動までできるはずだが、そのためには起動するベースシステムも中身からっぽでいいから作らないといかん。</p>
            <p>ベースシステムの起動まで作ったら、次はどうしようか。</p>
            <p>ベースシステムの中身を詰めていくべきかな。</p>
            <p>パッケージ設定ファイルの処理とかもないわけではないけど、これ以上同じような作業はきついものがある。</p>
            <p>それに前にも書いた通り、パッケージ設定ファイルは今のところ無くても問題ないのだ。</p>
            <p>これ以上モチベーションを落としたくないし。</p>
        </div>
        <hr />
        <div>
            <h2>2015/11/10 02:03</h2>
            <p>やはりそう簡単にはやる気は戻らんらしい。</p>
            <p>＊</p>
            <p>リファクタリングしたり、パッケージ情報ファイルを解析したデータからデータを取得する関数を追加したりしてたら、今日中に0.4.0を作りきれなかった。</p>
            <p>でもまぁ、パッケージ情報ファイルから名前に対応したベースシステム情報を取得する関数の処理を実装したら、あとはメインの処理を追加して、デバッグ出力を追加すれば完成だろうか。</p>
            <p>道筋は見えているので、起きたらさくさくっと完成させたい。</p>
        </div>
        <hr />
        <div>
            <h2>2015/11/09 00:38</h2>
            <p>前回から1ヶ月程度か。結構さぼってしまった。</p>
            <p>＊</p>
            <p>作業はしてたんだけど、やはり牛歩。</p>
            <p>やる気が出なかったのは、退屈な作業というか、前のバージョンで追加したのと同じような作業をやることになったからだろうな。</p>
            <p>前はショートカットファイルの解析で、今回はパッケージ情報ファイルの解析。</p>
            <p>必要なことではあるのだが、なんとも退屈な作業だった。</p>
            <p>＊</p>
            <p>パッケージ情報ファイルの解析処理はなんとかできたので、それを使って得られた情報を出力して、それを0.4.0とすることにしよう。</p>
            <p>明日にはパパッと作ってしまって、さっさと次に進みたいところ。</p>
            <p>ベースシステムの情報は取得できるようになったわけだし、次はいよいよベースシステムの起動に入れるか。</p>
        </div>
        <hr />
        <div>
            <h2>2015/10/03 00:00</h2>
            <p>機能を実装したと仮定した処理を記述していっているのだが、つまずいている。</p>
            <p>＊</p>
            <p>パッケージ情報ファイルを読み込む、これはいい。</p>
            <p>読み込んだパッケージ情報ファイルからベースシステムの情報を取り出す、これもいい。</p>
            <p>この次がしっくりこない。</p>
            <p>手順としては、まずモジュールをロードするんだろうけど。</p>
            <p>モジュールをロードして、ロードしたモジュールからベースシステムの関数を取り出し、取り出した関数を実行する。</p>
            <p>急に処理のレイヤーが低くなるから違和感を覚えるのかしら。</p>
            <p>＊</p>
            <p>ベースシステムの情報を取り出すのではなく、パッケージ情報ファイルの内容とベースシステム名を引数にベースシステムを実行する、の方がいいのかなぁ。</p>
            <p>だったら、パッケージのパスとベースシステム名を引数にベースシステムを実行する、の方がよりいいかもしれない。</p>
            <p>後のことを考慮すればもっとまとまるだろうか？</p>
            <p>パッケージ設定ファイルを読むようにした場合だ。</p>
            <p>パッケージ設定ファイルを読み、使用するパッケージのパッケージ情報ファイルを読み、使用するモジュールを列挙、ロードし、ベースシステムを含むモジュールからベースシステムの関数を取り出し、実行。</p>
            <p>関数をどう、とかなると低レイヤーすぎるから、ベースシステムの実行として1つの処理にまとめるべきだろうな。</p>
            <p>可変長の引数を取り、それを共有ライブラリから取り出した関数ポインタの引数に渡して呼び出す、みたいなことできればいいんだけどそんな簡単にできるだろうか。</p>
        </div>
        <hr />
        <div>
            <h2>2015/10/01 18:40</h2>
            <p>0.3.0できた。</p>
            <p>＊</p>
            <p>設定ファイル要素の集合体からショートカットファイルを表す構造体を生成する処理を追加した。</p>
            <p>こういう構成の設定ファイルがショートカットファイル、というのを定めたことになる。</p>
            <p>とはいえ、ベースシステム実行に必要な要素だけが記述された、暫定的なものだけど。</p>
            <p>具体的には、ベースシステムが含まれるパッケージのパスと、ベースシステム名、この2つ。</p>
            <p>この2つの情報が記載されたファイルをショートカットファイルとする。</p>
            <p>＊</p>
            <p>次は、その2つの情報を使い、ベースシステムを実行する処理を作ろう。</p>
            <p>それを0.4.0とする。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/26 00:55</h2>
            <p>昨日、方針を固めたのはいいのだが。</p>
            <p>＊</p>
            <p>実際に作業を進めようとしたものの、なんだかやりにくい。</p>
            <p>どうにも、処理が不完全な感じがある。</p>
            <p>ショートカットファイルの読み込み、解析を行なっているものの、最終的に生成しているのがショートカットファイルを表す構造体でないのが分かりにくい原因か。</p>
            <p>現状、設定ファイル要素の集合体としてしか扱っていない。</p>
            <p>データを取り出すにも、例えばマップにキーに対応するデータが存在するか、とかから始めないといけない。</p>
            <p>ショートカットファイルとして正しいのかどうかのチェックを行なっていないから、そのようなめんどうなことになるのだ。</p>
            <p>設定ファイルとして文法が正しいか、の次にショートカットファイルとして正しい構成になっているか、のチェックが必要だ。</p>
            <p>そうすれば、データを取り出す際にいちいちデータの存在チェックとかやらんで済む。</p>
            <p>＊</p>
            <p>どうしよう、それを0.3.0として作るか？</p>
            <p>機能として完全に分離させた方がよさそうだし、そうするかなぁ。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/24 23:55</h2>
            <p>考えて考えて、ようやく方針が固まった。</p>
            <p>＊</p>
            <p>次は、ベースシステムを実行する処理を作る。</p>
            <p>ベースシステムとゲームの構成についても変更する。</p>
            <p>前のプロジェクトでは、ベースシステムは生成・破棄するもの、ゲームは実行するものという扱いだったが、これは逆にする。</p>
            <p>ベースシステムは実行するもの、ゲームは生成・破棄するもの。</p>
            <p>ゲームは完全に動作を制御したいのだ。</p>
            <p>だから実行する、つまり制御を完全に移す形にするのは適切ではない。</p>
            <p>ベースシステムは制御できる形にしたところで、じゃあそれを誰が制御するんだよって話になる。</p>
            <p>起動プログラム？そんなめんどうなことはさせたくない。</p>
            <p>よって制御を完全に移す形にする。</p>
            <p>＊</p>
            <p>というわけでベースシステムのライブラリをロード、関数を取り出し呼び出す、ということをすることになるが、まずはできるだけ規模を小さくする。</p>
            <p>ライブラリを扱うということはパッケージを扱うことになるのだが、本来想定している処理の流れは以下の通りだ。</p>
            <p>・パッケージ設定ファイルを読み込み、利用するパッケージ、モジュールを特定</p>
            <p>・利用するパッケージのパッケージ情報ファイルを読み込み、ベースシステム実行関数が含まれるモジュールや、モジュールの実体（ファイル名）などを把握</p>
            <p>・利用するモジュールを全てロード、ベースシステム実行関数が含まれるモジュールから関数を取り出し呼び出す</p>
            <p>こんな感じだが、まずは最初のパッケージ設定ファイルの読み込みを行なわないことにする。</p>
            <p>単にモジュールを読み込んで関数を取り出し呼び出すだけなら、パッケージ情報ファイルを読めばできるのだ。</p>
            <p>パッケージ設定ファイルは、モジュールの利用する・しないの判断や、依存パッケージの指定、パッケージとセーブデータの関連付け、パッケージやモジュールへのパラメータの設定などなど、より高度なことを行うために必要となるが、最低限の動作では必要ない。</p>
            <p>よって、0.3.0ではパッケージ情報ファイルを読み込み、ベースシステムを実行するところまで作る。</p>
            <p>＊</p>
            <p>パッケージ設定ファイルを使う前提で考えていたから、どう進めるべきか決まらなかった感じがある。</p>
            <p>もし無理矢理その方向で進めていたら、またしても泥沼の展開だっただろうな。</p>
            <p>こんなに長く考えたのだから、それを避けられればいいのだが。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/24 12:40</h2>
            <p>連休を利用して、マシンの環境を構築し直していた。</p>
            <p>＊</p>
            <p>今までは、64bitと32bitの環境を完全に分けて構築していた。</p>
            <p>64bit環境で32bitプログラムを動かすために、エミュレーションライブラリを使う必要があるのを嫌ったためだ。</p>
            <p>しかしながら、今年の3月頃だったか、エミュレーションライブラリの使用は非推奨になった。</p>
            <p>64bit環境で32bitプログラムを動かすために必要となるライブラリも、ソースからビルドできるようになったからだ。</p>
            <p>わざわざ環境を作り直すのはめんどうなのでやってこなかったが、2つの環境を扱うのも色々めんどうがある。</p>
            <p>例えばパッケージの更新は2環境にそれぞれ実行しなければならないし、設定ファイルなんかも2箇所に置くことになるし、そもそも2環境作ると容量結構取るし。</p>
            <p>そんなわけで環境を作り直した。</p>
            <p>＊</p>
            <p>今のところ、問題なく動いているようだ。</p>
            <p>skypeなんかは、前は32bit環境で動かしていたため、32bit環境に移行→skype起動、などとするスクリプトとか用意してたんだけど、そんな必要もなくなった。</p>
            <p>32bit環境に移行する必要がなくなったからか、前より起動が速くなった気がする。</p>
            <p>＊</p>
            <p>後は、raidをマシンの外に出したいけれど、これをやるとなるとまためんどうそうだなぁ。</p>
            <p>封印してある玄箱T4を使おうと思っているが、これを普通に使おうとすると、4つ入るハードディスクのうち、どれか1つの中に環境を構築しないといけないとかいう残念なやつだし。</p>
            <p>それを避けるには、外部に環境を作りNFSでマウントして使う、とかしないといけないんだけど、これまためんどい。</p>
            <p>ちょうど使ってないraspberrypiもあることだし、それを使おうと考えているが、結局そっちの環境構築も必要になるわけだし。</p>
            <p>やるなら次の土日だろうけど、土日で完了できるだろうか。</p>
            <p>いや、まず無理だな。できてraspberrypiの環境構築くらいなものだろう。</p>
            <p>＊</p>
            <p>ちなみに環境というのはどれもGentooだ。Gentoo Linux。</p>
            <p>柔軟で扱いやすくていい。</p>
            <p>しかし、パッケージをソースからビルドする形なので時間がかかりがちなのが難点。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/16 23:50</h2>
            <p>昨日のうちに、0.2.0は完成した。</p>
            <p>＊</p>
            <p>のだが、次はどうするべきか決めかねている。</p>
            <p>ベースシステム情報が得られているのだから、ベースシステムの構築・起動をするべきだろうか。</p>
            <p>しかし、ベースシステムとゲームをどう連携させるかまだ決まってないしなぁ。</p>
            <p>最低限決まっているのはベースシステムを起動した後にゲームを起動させるという順番くらいなものだろうか。</p>
            <p>とりあえずをそれをやってしまうべきか？</p>
            <p>中身はほぼ空でも。</p>
            <p>＊</p>
            <p>しかし、それはまた行き当たりばったりな感じがするし。</p>
            <p>もうちょい考えをまとめるべきだろうなぁ。</p>
            <p>ゲームはどこでロードするのか？</p>
            <p>今作っている起動プログラムか？もしくはベースシステム内の処理か？</p>
            <p>前者の場合、ゲームをロードする必要がある時には起動プログラム側に制御を戻さなければならなくて、なんだか奇妙だ。</p>
            <p>後者の場合、起動プログラムからベースシステムをロードして動かし、ベースシステムからゲームをロードして動かす、という流れになって、見た目きれいな感じがする。</p>
            <p>しかしながら、ゲームのロードには設定ファイルの読み込みが必要になるものの、そもそもベースシステムからして設定ファイルの読み込みを行なった上でロードするのだ。</p>
            <p>設定ファイルの読み込み処理は、普通に考えたら起動プログラム部分に配置することになる。</p>
            <p>それをどうやってベースシステムから呼び出すのか？</p>
            <p>案はないわけではないが。</p>
            <p>モジュールの設定という概念を追加して対応する、というのが今考えている案。</p>
            <p>それにより起動プログラム内の関数名を指定し、モジュールロード時に関数を取得、という感じだ。</p>
            <p>そんな関数が用意されているかは謎だ。</p>
            <p>＊</p>
            <p>うーん、設定ファイル形式の解析処理はできているわけだから、解析を行なった次の段階、設定ファイルを読み込みデータを取得するための関数を実装すべきだろうか。</p>
            <p>だとして、その目的はどうするべきか？</p>
            <p>これまでは、それぞれファイルの内容を出力するためにファイル読み込み処理を追加したし、読み込んだファイルから意味あるデータを取得するために解析処理を追加した。</p>
            <p>目的を持たない機能追加はその実用性に疑問が残る。</p>
            <p>次にやる事を考えれば、ベースシステムの構築なわけで、つまりモジュールのロードや、ロードしたモジュールからの関数取得か。</p>
            <p>それらの処理を行なうための入力データとして、ファイルから読み込んだデータを構造体にまとめる、という感じになるか。</p>
            <p>＊</p>
            <p>ということで、目的はベースシステムの構築、もといベースシステムの生成・破棄関数の呼び出しか。</p>
            <p>それに付随して、モジュールのロードや、設定ファイルの形式を定めていったりする必要がある。</p>
            <p>まずは、すごい簡単なベースシステム生成・破棄関数を持ったライブラリを作るところから始めるべきか？</p>
            <p>その辺ができてこないと、設定ファイルにどう記述していいか分からないしなぁ。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/15 01:55</h2>
            <p>ちょっと不調。データ取得関数を一通り追加したところまで。</p>
            <p>＊</p>
            <p>多分、これで設定ファイルに関する関数は一通りできたはず。</p>
            <p>あとはこれらを使ってメイン処理を組み立てる。</p>
            <p>明日には0.2.0を仕上げたい。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/11 18:40</h2>
            <p>マップ要素まで完了した。</p>
            <p>＊</p>
            <p>後は、解析したデータからのデータ取得関数とか追加しながらメイン処理を組み立てて、0.2.0の完成といったところか。</p>
            <p>次はどうするべきか。</p>
            <p>設定ファイルからベースシステムについての情報とゲームについての情報を得られるわけだから、ベースシステムの生成だろうか。</p>
            <p>ベースシステムはどこで作ろうか。</p>
            <p>暫定的なものはcandymakerで作ってしまおうか。</p>
            <p>それが、とりあえずはコンパクトでいい気もする。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/11 02:05</h2>
            <p>リスト要素はできたが、マップ要素はまだ。</p>
            <p>＊</p>
            <p>来週には持ち越したくないなぁ。</p>
            <p>明日中にマップ要素を完成させて、来週からは作った処理を使って読み込んだショートカットファイルの内容を解析したいところ。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/09 23:40</h2>
            <p>リスト要素の解析は完成には至らなかった。</p>
            <p>＊</p>
            <p>しかしもう少しだ。</p>
            <p>残件は複数の要素を含むリストの場合の処理。</p>
            <p>要素が単一の場合については完了している。</p>
            <p>なので、30分、あるいは1時間もあれば十分できるんじゃないかな。</p>
            <p>ソースファイルを要素毎に分けたりしたので、作り切れなかったんだろうか。</p>
            <p>ならば、明日中にリスト要素の完成に加えて、マップ要素も完成させてしまいたいところだが。</p>
            <p>マップ要素の処理はリスト要素と似ているので、案外早く片付きそうな気がする。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/08 22:15</h2>
            <p>設定ファイルの文字列要素の解析処理はできた。</p>
            <p>＊</p>
            <p>想定よりも時間がかかってしまった感じがある。</p>
            <p>しかし、これから追加する予定のリスト、マップ要素でも共通して利用することになる処理も含んでいるので、案外こんなものかもしれない。</p>
            <p>明日はリスト要素の対応。</p>
            <p>ちゃっちゃと片付けてしまいところだが、現状の文字列要素の処理を別ファイルに分離したりとかそういう作業が必要になってくるので、意外と面倒かも。</p>
            <p>＊</p>
            <p>今回作った文字列要素解析処理のソースはおよそ300行。</p>
            <p>全てが文字列要素についての処理というわけではなく、要素共通の処理も含まれているが。</p>
            <p>それに比べて、前回のプロジェクトで作ったソースは文字列要素についてのファイルがおよそ150行、要素共通のファイルがおよそ550行。</p>
            <p>前回のプロジェクトの要素共通のファイルでかすぎない？と思って中を見てみたら、デバッグ出力に結構行数使ってた。</p>
            <p>そういや前回のは、動作確認のために読み込んだデータの内容を1つ1つ出力してたな。</p>
            <p>今回はその辺のチェックがテストコードで済むので、こんなでかいデバッグ出力処理はいらないだろう。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/08 00:05</h2>
            <p>というわけで、テストファーストで作るのを試している。</p>
            <p>＊</p>
            <p>前に作ったソースを流用する予定だったけど、テスト駆動開発の練習も兼ねてほぼ1から作っている。</p>
            <p>最初にごく単純な処理を実装するために、まずテストを書く。</p>
            <p>アサートを先に書き、そのアサートに至るための処理を書いてテストコードとする。</p>
            <p>次にそれを失敗するコードを書き、そのテストコードがテストで実行されることを確認する。</p>
            <p>次に、テストを通すことだけを目的とした、固定値を返すような不完全な仮実装を行ない、テストが通ることを確認する。</p>
            <p>仮実装では不完全ということを示すために、別の入力を行なった場合のテストを書く。</p>
            <p>本実装をして、両方のテストが通ることを確認し、完了。</p>
            <p>最後の方はなんか違うような気がするけど。</p>
            <p>確か、テストは1つで、不完全な仮実装でテストを通し、後はテストが通ることで処理が正しいことを確認する、みたいな感じだったような。</p>
            <p>テストを2つ書くのは三点測量とかいう、なんか不安な時にやる方法とかだったような。</p>
            <p>でもこっちの方がより納得できるんだよなぁ。</p>
            <p>仮実装でもテストが通るというのが気に食わない。</p>
            <p>で、仕様を追加する場合も同じ手順で進めていく。</p>
            <p>＊</p>
            <p>その結果、前に書いた時とは処理方法が変わった。</p>
            <p>まだ前に書いた機能には達していないので変わりそう、が正しいが。</p>
            <p>単純、コンパクトな実装でテストを通すようにしているためか、前に書いたのより見やすく、分かりやすくなっている気がする。</p>
            <p>前はテストとか書いてなかったから、処理ありきで書いていたため、頭の中にある処理をそのまま書き出していたからごちゃごちゃしていた。</p>
            <p>今回はテスト、つまり結果が先に来て、その結果にするためにどうするか、という考え方に加えて、機能を細かく1つずつ実装していっているので、ごちゃごちゃしてない感じがある。</p>
            <p>これなら、機能を増やしていっても見やすい、分かりやすいコードが書けそうだ。</p>
            <p>＊</p>
            <p>初日ということもあってかあまり進んでいないが、大体分かってきたので明日からはもっと進められればいいのだが。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/06 01:25</h2>
            <p>CppUnit？知らない子ですね。</p>
            <p>＊</p>
            <p>Google Testに切り替えた。</p>
            <p>他にもBoost.Testとかあったらしい。</p>
            <p>完全に調査不足である。</p>
            <p>Google Testに決めたのは、出力に色が付くのでテストの成否が一目で分かるというのが一番の理由。</p>
            <p>その結果、CppUnitをより扱いやすくするために書いたコードは全て不要になった。</p>
            <p>悲しい。</p>
            <p>＊</p>
            <p>元々、CppUnitはJUnitをC++用に書き直したようなものだからか、クラスありきな書き方が気に入らなかった。</p>
            <p>Google Testなら、クラスを作らずにテストを書けるし、必要に応じてクラスを使ったテストも書くことができていい感じっぽい。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/05 13:15</h2>
            <p>昨日は久々に朝方まで作業してしまった。</p>
            <p>＊</p>
            <p>その甲斐もあって、CppUnitを利用した自動テスト実行環境は大体整った感ある。</p>
            <p>wafの自動テストサポートも使い、ビルド成功時にテストプログラムが自動的に実行されて、テストが通ったか通らんかったか表示されるようにした。</p>
            <p>ただ、テストの通った通らないはテストプログラム単位なので、テストが通らなかった時にどのテストが通らなかったのかは表示されない。</p>
            <p>なので、その場合は自分でテストプログラムを実行してどのテストが通らなかったのか確認する必要がある。</p>
            <p>そこが少し面倒だが、かといって全テストの出力を表示すると量が多すぎるか。</p>
            <p>＊</p>
            <p>テストコードのファイル数が増えれば増えるほど、テスト対象コードの全く同じコンパイル処理の回数が増えると思われる。</p>
            <p>ビルド時間の増大が懸念されるが、全く同じということはコンパイルキャッシュなるものを使えば時間短縮できるんだろうか。</p>
            <p>＊</p>
            <p>もうちょい整えたらテストファーストで作業を開始するつもりだけど、それは月曜からにしようかなぁ。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/04 02:45</h2>
            <p>タグとか初めて使った。</p>
            <p>＊</p>
            <p>使い方これでいいのかよく分からんけど。</p>
            <p>とりあえず<a href="https://bitbucket.org/tekuto/candymaker" target="_blank">リポジトリを作っておいた。</a></p>
            <p>読んだファイルの内容を処理するところまでやろうかとも思ったけど、とりあえずファイルを読み込んでその内容を出力するだけ。</p>
            <p>それでバージョン0.1.0ということにした。</p>
            <p>次は読んだ内容を処理し、データを抽出して出力する。</p>
            <p>それを0.2.0ということにしよう。</p>
            <p>基本的には、処理内容は今までに作ったやつから持ってくればいいと思う。</p>
            <p>でも今回は、自動テストを作ってから作る、テストファーストというやつをやってみよう。</p>
            <p>そのためにCppUnitをインストールしたのだ。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/02 22:45</h2>
            <p>超久しぶり。</p>
            <p>＊</p>
            <p>正直詰まってる感じある。</p>
            <p>思うに、やはり行き当たりばったりすぎるのだろう。</p>
            <p>筋道が立たずにところどころ肥大化しつつあるような、どうしようもない進め方になってしまっている。</p>
            <p>こんなことしても進んで戻ってを繰り返すことになりそうでさすがに躊躇しているのだが、1から作り直すべきかもしれない。</p>
            <p>一体何回目になるのだ。4回？5回？</p>
            <p>経験はどんどん蓄積されているわけなのだから、それをうまく利用できればいいのだけれど。</p>
            <p>＊</p>
            <p>まずは単純なものを作らなくては。いつもここが抜けている気がする。</p>
            <p>色々考えた結果、とりあえずベースファイルとかいらん。</p>
            <p>環境に1つの設定ファイルなんぞ見るとかそんなんもっと後でいい。今はいらん。</p>
            <p>コマンドライン引数から設定ファイルのパスを受け取り、そのファイルの内容を処理する。これだ。</p>
            <p>いっそそのファイルのパスも固定してしまえばもっと単純になるかもしれないが、さすがに実用性がなさすぎる気がする。</p>
            <p>＊</p>
            <p>ここまで書いといて今更だが、作ろうとしてるプログラムの大まかな流れは、</p>
            <p>・ベースシステムという機能集合体を生成</p>
            <p>・ベースシステムを利用して動作するゲームをロード</p>
            <p>・ゲームを動かす</p>
            <p>という感じになる。</p>
            <p>前述のコマンドライン引数で渡す設定ファイルのパスというのは、ゲームについての情報が書かれているファイルだ。</p>
            <p>現状では、ベースシステムについての情報は何一つ書かれていない。</p>
            <p>これまでの想定としては、ベースシステムについての情報は環境に1つの設定ファイルに記述しておく形だった。</p>
            <p>しかしよく考えると、それだと使用するベースシステムが固定的になりすぎる気がする。</p>
            <p>別のベースシステムの上でゲームを動かしたいなーとかなった時に面倒だ。</p>
            <p>なので、コマンドライン引数で渡す設定ファイルの中に、ベースシステムについての情報も書いておくべきかななどと思った。</p>
            <p>そもそもコマンドライン引数で渡す設定ファイルはショートカットファイルという名前だ。</p>
            <p>それ1つ読めば、とりあえずゲームが起動するところまでできるべきファイルなのだ。</p>
            <p>ならば、ショートカットファイルにはベースシステムの情報とゲームの情報、どちらも記述するべきだろう。</p>
            <p>後々既定のベースシステムとか作る場合には、ベースシステムの情報の記述は必須ではないとかにすればよかろう。</p>
            <p>＊</p>
            <p>そこからまた展開させようとすると、どんどん肥大化していく悪寒がする。</p>
            <p>なのでとりあえず決まったそこまで作ろう。</p>
            <p>まずコマンドライン引数でショートカットファイルパスを受け取る。</p>
            <p>次にそのファイルを読む。</p>
            <p>最後に読んだ内容を出力する。</p>
            <p>これだ。これで行こう。</p>
            <p>ここまで作ったらまた書く。</p>
        </div>
        <hr />
        <div>
            <h2>2015/03/02 20:49</h2>
            <p>パッケージ設定に対応するパッケージ情報と、依存パッケージ設定の読み込み処理まで作った。</p>
            <p>＊</p>
            <p>次は、その読み込んだ設定ファイル群からベースシステム情報を取得する処理と、その構築に必要なモジュール群の列挙処理か。</p>
            <p>それを終えて初めてモジュールマネージャに取りかかれるな。</p>
        </div>
        <hr />
        <div>
            <h2>2015/02/25 16:02</h2>
            <p>設定ファイル、JSONじゃない方がいいかもしれない。</p>
            <p>＊</p>
            <p>思いの他扱いやすいし見づらくもないので大体問題はないんだけど、JSONの仕様には存在しない要素がほしい。</p>
            <p>具体的に言うと集合がほしい。</p>
            <p>現時点では、やろうとするとリストとして記述し、JSONを読み込んでデータを取り出した後に、重複するデータは削除するなどすればできるけど、なんだか回りくどい。</p>
            <p>JSONを読み込んだ時点で、重複するデータは削除するようにしてしまいたいところ。</p>
            <p>[]はリストで、{}はオブジェクトだから、適当なところで()だろうか。</p>
            <p>pythonと同じような感じになりそうだな。</p>
            <p>ただこれをやるとなると、JSONの比較処理も追加しなければならないな。</p>
            <p>＊</p>
            <p>JSON読み込み処理は現時点ではかなり限定的でJSONとは呼び難いのだけど、この機能を追加するとJSONの定義から完全に外れることになる。</p>
            <p>だからどうだということも、特にないが。</p>
        </div>
        <hr />
        <div>
            <h2>2015/02/25 13:01</h2>
            <p>設定ディレクトリ内にあるコンフィグディレクトリってなんだろうな。</p>
            <p>＊</p>
            <p>パッケージのモジュールの使用許可やセーブデータディレクトリとの関連付けなどを記述した設定ファイルなんだけど、パッケージ設定とは呼びにくい。</p>
            <p>パッケージディレクトリに配置されている各パッケージ内にも設定ファイルが存在するからだ。</p>
            <p>現時点では、後者を読み込む時にPackageConfigという構造体にデータをつっこんでいる。</p>
            <p>しかし、このファイルは基本的にユーザーが変更することはないため、設定というよりは情報が記述されているだけのファイル、と考えるべきかもしれない。</p>
            <p>そう考えると、PackageConfigではなくPackageInfo、パッケージ情報ファイルと呼ぶべきかもしれない。</p>
            <p>そうすれば、モジュールの使用許可などを記述したファイルのことをパッケージ設定ファイルと呼べるし。</p>
            <p>今まで脳内ではコンフィグ設定ファイルとか呼んでいたが、コンフィグと設定って同じ意味だし、構造体にしようとするとConfigConfigになっちゃうしで困っていたが、これでどうにかなりそうだ。</p>
            <p>＊</p>
            <p>前の記事に書いた作業については昨日のうちに終わらせておいた。</p>
        </div>
        <hr />
        <div>
            <h2>2015/02/23 23:31</h2>
            <p>思うに、ソースコードが読みにくい。</p>
            <p>＊</p>
            <p>情報を表すデータと、情報を参照するための情報を表すデータがほぼ同じ名前で定義されているため分かりにくい。</p>
            <p>前者をXXとしたら、後者はXXRefという感じに命名するようにしようかなぁ。</p>
            <p>デバッグ出力も、後者もXXとほぼ同じ出力になっちゃってるから分かりにくいし。</p>
            <p>＊</p>
            <p>モジュールマネージャに取りかかる前に、まずはそこらのリファクタリングからだな。</p>
        </div>
        <hr />
        <div>
            <h2>2015/02/23 19:29</h2>
            <p>牛歩、牛歩。</p>
            <p>＊</p>
            <p>ようやくモジュールマネージャに取りかかれそう。</p>
            <p>パッケージ設定ファイルからベースシステムの設定を取得するところまではできたので、ベースシステムを生成するために生成関数と破棄関数の取得を行なわねばならない。</p>
            <p>関数の取得の前にはモジュールのロードを行なわなければならないし、つまりいよいよモジュールマネージャというわけである。</p>
            <p>＊</p>
            <p>基本データ型の定義を変えるべきかもしれない。</p>
            <p>現時点では、typedefを使ってintをfg::Intと定義したりしてるのだけど、モジュールがエクスポートするシンボルのことを考慮すると、これはあまりよくない気がする。</p>
            <p>fg::Intはシンボルとしてはintと同じように扱われてしまう。</p>
            <p>これはあまり都合がよくない。</p>
            <p>fg::Intはfg::Intとして扱われていた方が都合がいいのだ。</p>
            <p>主に、シンボル名のマングリングとかそこらの処理のために。</p>
            <p>それをやるためには、fg::Intをtypedefではなくクラスとして定義すればいいのだろうけど、ソースコード上での扱いは今までのから変更したくはない。</p>
            <p>演算子のオーバーロードを駆使することで達成できるのかなぁ。不安だ。</p>
        </div>
        <hr />
        <div>
            <h2>2015/02/10 22:35</h2>
            <p>このところ、raspberrypiをいじくっていた。ちょうど日記が途切れた辺りから。</p>
            <p>＊</p>
            <p>raspbmcをつっこんでみたり、openelecをつっこんでみたり。</p>
            <p>raspberrypiでradiko使ってラジオが聴けるようになったり、インターネットラジオ聴けるようになったり、youtube見れるようになったり、天気予報確認できるようになったりなど。</p>
            <p>テレビにHDMIでつなげばテレビのリモコンで操作できるようになったりしておもしろい。</p>
            <p>＊</p>
            <p>で、bindとdhcpを動かしてるraspberrypiにこれらの機能をつっこめないか、と思って色々試していたのだが、結局今動いているようなgentooにxbmcをインストールするのが一番手っ取り早そう、という結論に達した。</p>
            <p>raspbmcはなぜか無線LANがうまくつながらんし、openelecはbindとdhcpを追加するのがかなりめんどそうだし。</p>
            <p>＊</p>
            <p>しかしながら、gentooをまた構築するのもそれはそれでめんどうだったり。</p>
            <p>いい加減dropmakerの方進めたくなってきたし、休みの日とかに気が向いたらちょっとずつ進めてみようかと。</p>
            <p>って明日祝日？明日はやらん。どうもraspberrypiに関わると頭が痛くなりやすい気がする。</p>
        </div>
        <hr />
        <div>
            <h2>2015/02/04 00:12</h2>
            <p>モチベーションが下がっているが、ちょっとずつ進んでいる。</p>
            <p>＊</p>
            <p>パッケージ設定ファイルも、大部分は処理できている。</p>
            <p>例によって、暫定的な実装であるため穴だらけだが、そのうちなんとかする予定。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/29 21:11</h2>
            <p>進みが遅くなっている。</p>
            <p>＊</p>
            <p>パス型の扱いを少し変えたり、パッケージ設定を読み込む際の処理で、今まで書いた処理を共通関数化して使えるようにしてから処理したりなど。</p>
            <p>パッケージ設定ファイルを見てて思ったのは、これまた割と適当に決めた感じがあるなぁということ。</p>
            <p>でもまぁ、とりあえず全部読み込んで型に落とし込む。</p>
            <p>そうしないと始まらん。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/28 00:28</h2>
            <p>パス型を文字列に変換する暫定的な処理ができた。</p>
            <p>＊</p>
            <p>しかし、本当に暫定的だ。</p>
            <p>機能も少ない。循環参照エラーの検出ができないため、設定ファイルでまずい記述をすると無限ループが発生する可能性もある。</p>
            <p>その辺の問題は後々解決していくとしよう。めんどいので。</p>
            <p>＊</p>
            <p>とりあえずパス型を文字列に変換し、ファイルを読み込むところまではできたが、読み込んだものの処理はまだ実装していない。</p>
            <p>その辺は明日やる。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/26 19:49</h2>
            <p>パッケージ設定の読み込み処理を作っているところ。</p>
            <p>＊</p>
            <p>ファイルをJSONとして読み込む処理とかは、ベース設定の読み込みでも使っているので使い回せるが、パスの扱いは今回が初になるため、そこで少し手間取っている。</p>
            <p>具体的にはパス型を文字列型に変換し、ファイルオープンなどに使えるようにする処理なのだが、今回作成するものは限定的な機能を持ったものでいいだろう。</p>
            <p>とにかく、パッケージ設定のパスを文字列にできればいいのだ。そのために全機能は必要ない。</p>
            <p>後々きちんと全機能作らなければならないだろうけど、今それをやると間違いなくだれる。</p>
            <p>今回作らない機能についても、大体どのように実装すればいいのかはイメージできているので多分大丈夫。多分。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/23 21:06</h2>
            <p>ひとまず、ベースシステム生成、破棄関数取得までの流れは作った。</p>
            <p>＊</p>
            <p>ベースシステムの生成、破棄に関わるモジュール群生成までの流れも作ってしまいたいところだったが、これにはモジュールローダの設計が大きく関わってくる。</p>
            <p>そして、今のところモジュールローダは中身が空っぽの状態だ。</p>
            <p>よってまだ書けない。書くのはモジュールローダの設計をまとめて、というかモジュールローダを作ってからだな。</p>
            <p>＊</p>
            <p>やはり今週中は無理だったな。来週中ならいけるかしら。</p>
            <p>来週の作業手順は、とりあえず流れを作ってあるベースシステム生成、破棄関数取得までの部分の実装を作るところからだろう。</p>
            <p>それを終えたら、モジュールローダを作るのとベースシステムの生成、破棄に関わるモジュール群生成を並行して行なう感じだろうか。</p>
            <p>大体後者が主導になると思うが。部品を先に作ってしまって、実際に使う場面でやっぱりびみょう、使い物にならんとかなったら目も当てられん。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/23 14:00</h2>
            <p>というわけで、サイトをgithub pagesに移行した。</p>
            <p>＊</p>
            <p>何日か前に書いたような気がしたけど書いてなかったので、経緯を書いておこう。</p>
            <p>gaeのツールが動かんくなった。</p>
            <p>どうもpythonのバージョンとうまく噛み合っていないらしく、バグ報告も上がっているようだけどツールのバージョンアップが来ない。</p>
            <p>現状やってることと言えば静的ページの公開だけだし、記事書いた後にコミットとは別にアップロードコマンド打つのもめんどうなので、github pagesに移行した。</p>
            <p>github pagesなら独自ドメイン使用時にサブドメイン付けなくていいし、サブドメインからリダイレクトさせることもできるので、URLをtekuto.netにできていい感じ。</p>
            <p>今までのwww.tekuto.netにアクセスすれば、tekuto.netにリダイレクトしてくれる。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/23 00:15</h2>
            <p>今週中に終わらせられれば、とか昨日書いたけど早速今日、諸事情により作業できなかった。</p>
            <p>＊</p>
            <p>明日から本気出す。</p>
            <p>でもさすがに明日1日で終わらせるのは無理だろうなぁ。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/21 18:10</h2>
            <p>ベース設定ファイルからベースシステムとシェルについての情報を読み込む処理を書いた。</p>
            <p>＊</p>
            <p>Baroqueのサントラ流しながら作業すると集中できていいな。</p>
            <p>歌が入ってるタイプの曲は、作業中の私にはあまり向かないようだ。</p>
            <p>気が散りやすいというか、ヘッドホンで聞きながら作業すると頭痛くなったりする。</p>
            <p>＊</p>
            <p>さて、ベース設定ファイルに記述する内容はひとまず全て読み込む処理を書いたので、次はそれを元にベースシステムを生成するための情報を生成する処理か。</p>
            <p>まずはどこからだろうか。ベースシステム情報に記述してある、パスに対応した設定ファイルを読み込む処理からかな。</p>
            <p>その設定ファイルには、対応するパッケージについて、そのパッケージのパスや、対応するセーブデータのパス、使用を許可するモジュールのリストなどが含まれている。</p>
            <p>ので、その設定ファイルを読んだら次はパッケージの設定ファイルを読み込んで、とかそういう流れになるんだろうな。</p>
            <p>なかなか負荷の高そうな内容だ。今週中に終わらせられればいいのだが。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/21 16:00</h2>
            <p>パス型の定義変更に対応完了。</p>
            <p>＊</p>
            <p>昨日に済ませておきたかったところだけど、ちょうどその直前できりがよかったため、昨日の作業はそこで切り上げてしまった。</p>
            <p>で、今日その辺をさくっと終わらせた。</p>
            <p>次はベースシステムやシェルについての情報をベース設定ファイルから読み込む処理と、ベース設定ファイルの情報を元に、色々設定ファイルとか読み込んで、ベースシステム生成に必要な情報を構築する処理かな。</p>
            <p>ベースシステムについての情報が記述されてるんならそれでいいじゃないかと思うかもしれないが、記述されているのは設定ファイルのパスとベースシステム名だけなので、具体的にどのモジュールをロードし、なんて関数を呼び出して生成し、破棄するか、といった情報は他の設定ファイルを読まないと分からない。</p>
            <p>なので、その辺どうにかする処理を書く、といった感じだ。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/20 14:38</h2>
            <p>やはりきちんと毎日書かんとだめだな。すっかり習慣がなくなってる。</p>
            <p>＊</p>
            <p>昨日の作業としては、設定ファイルの記述を修正したり、パス型の読み込み処理を独立させたりなど。</p>
            <p>パス型の定義を変えてあるため、現時点の処理では対応できないので、使う場面になったら修正することになるだろう。</p>
            <p>今日はベースシステム構築のためにコンフィグマネージャから情報を取得する処理とか書くつもりなので、前述の修正はやることになるかも。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/17 00:38</h2>
            <p>できるだけ忘れずに書いていくことにする。</p>
            <p>＊</p>
            <p>早速忘れかけていた上に、ツールがちゃんと動作するようになるまでネット上に上げられんけども。</p>
            <p>さて、結局設定ファイルの扱いについては、いっそのこと全ての設定ファイルを1箇所で管理した方が分かりやすいのでは、ということで話が進んでいる。</p>
            <p>設定ファイル間で関連性があるものも結構あるわけだし、管理オブジェクトに対し、情報を要求すれば必要に応じて設定ファイルを読み込んで情報を生成して返す、みたいな。</p>
            <p>一度読み込んだ設定ファイルはキャッシュしておいたり、もし要求があればキャッシュを削除したりなども考えているけど、前者はともかく後者は後回しだろうな。</p>
            <p>いや、前者も別に必須ではないな。</p>
            <p>もやもやは晴れつつあるし、ペース上げていきたいところだが。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/15 20:42</h2>
            <p>過去ログは年単位で分ければいいのでは、という声が一部でささやかれている。</p>
            <p>＊</p>
            <p>進みはスローペース。もっとさくさくやりたいところだが。</p>
            <p>ベース設定の一部を読み取る処理はできた。</p>
            <p>一部というのはパスの別名定義。パスに名前を付けて管理する形を取るので、そう呼んでいる。</p>
            <p>これにより、それぞれのデータのパスを指定できるようになった。</p>
            <p>最終的には、ベースシステムの構築→シェルの起動→ゲームの起動となるわけだが、それまでにどういう処理が必要になるだろうか。</p>
            <p>ベースシステムの構築やシェル、ゲームの起動のためには、やはりモジュールのロードが不可欠。</p>
            <p>よって、モジュールマネージャの生成が必要になるだろう。</p>
            <p>モジュールのロードには、パッケージディレクトリとコンフィグディレクトリに置かれているファイルの読み込みが必要になってくるはずだ。</p>
            <p>しかしその処理はモジュールマネージャ内で行うべきだろうか？難しいところだ。</p>
            <p>それを含めてしまうと、モジュールマネージャが肥大化してしまう気がする。</p>
            <p>とはいえ、どこかでは設定ファイル間の関連付けを解決する処理をやらねばならない。</p>
            <p>いっそ、モジュールマネージャではなく設定ファイルマネージャと考えるべきだろうか。</p>
            <p>モジュールのロードとかは、それとは別にモジュールローダというか、モジュールロードマネージャというか、そんな感じの機能を別に作り、そこでやらせる。</p>
            <p>パッケージディレクトリの設定ファイルと、コンフィグディレクトリの設定ファイル読み込み処理については、別々の機能に分けることはできないだろうな。</p>
            <p>パッケージに含まれるモジュール一覧とその詳細情報は前者に書かれているが、どのモジュールの読み込みが許可されているかどうかは後者に書かれている。</p>
            <p>あるモジュールを読み込むだけなら、後者の設定ファイルを読んだ後に前者の設定ファイルを読めばいいだけだが、モジュールによっては依存モジュールが存在する。</p>
            <p>依存モジュールについては、また後者の設定ファイルから読み直す必要がある。</p>
            <p>これを別々の機能に分けるとなると、循環参照になってしまって気持ちの悪いことになりそうな感じがある。</p>
            <p>＊</p>
            <p>書いてたら、ちょっともやもやが晴れた気がする。</p>
            <p>完全にクリアになったわけではないのだが。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/26 19:15</h2>
            <p>難航していたが、ようやくまとまってきた感ある。</p>
            <p>＊</p>
            <p>今までのファイル構成は、dropmakerのホームディレクトリ直下にベース設定ファイル、パッケージディレクトリ、ゲームディレクトリがあった。</p>
            <p>セーブデータディレクトリなんかも置く予定だったけど、まだそれが必要になる段階まで到達していない。</p>
            <p>実際には、ベース設定ファイル以外のディレクトリはベース設定ファイル内で指定した位置なので、ホームディレクトリの下に置く必要はないが。</p>
            <p>それはともかく、パッケージディレクトリにはゲーム本体、プログラムやら、画像とか音楽とかのリソースやらが配置される。</p>
            <p>一旦配置されたら、削除されるまで変更がかかることは基本的にない。</p>
            <p>ゲームディレクトリには、ゲームパッケージを起動するための情報を記述した設定ファイルを置く。起動するパッケージ名やらモジュール名やらゲーム名やら。パッケージがなんらかのインターフェースを使用する場合、その実装モジュールの指定もする。</p>
            <p>プレステで例えれば、パッケージディレクトリはCD、ゲームディレクトリ（とセーブデータディレクトリ）はメモリーカードである。</p>
            <p>＊</p>
            <p>今回の構成変更で、とりあえずゲームディレクトリは無くした、というより分割した。</p>
            <p>その前に、モジュールの扱いを変えたのを説明するべきか。</p>
            <p>今までは、モジュールはゲームディレクトリの設定ファイルでインターフェースとの関連付けを行っていた。</p>
            <p>今回の変更で、その関連付けはやめた。</p>
            <p>その代わり、パッケージディレクトリの設定ファイルに、各モジュールが実装しているインターフェースを記述しておく形にした。</p>
            <p>ゲームディレクトリの設定ファイルでは、使用を許可するモジュールのリストアップのみ行う。</p>
            <p>あるインターフェースの使用が要求された場合、使用が許可されているモジュールの中から、そのインターフェースが実装されているモジュールを検索し、使用する。</p>
            <p>もし該当するモジュールが2つ以上ある場合には、衝突が発生しているので要求は失敗となる。</p>
            <p>該当するモジュールが存在しない場合には、インターフェースを定義するパッケージが提供するダミーモジュールを使用する。</p>
            <p>ダミーモジュールを使うことで、例えばネットとの通信モジュールを使用するゲームであっても、ユーザー側でその機能を無効化する、ということも可能になる。</p>
            <p>とはいえ、ゲーム側がネットとの通信ができないなら動作しないようにしたりしていれば、そもそもゲーム自体できなくなってしまうわけだが、それはまた別の問題だ。</p>
            <p>＊</p>
            <p>で、ゲームディレクトリをコンフィグディレクトリとショートカットディレクトリの2つのディレクトリに分けた。</p>
            <p>コンフィグディレクトリでは、パッケージディレクトリとセーブディレクトリとの関連付けや、前述の使用を許可するモジュールのリストアップなどを行う。</p>
            <p>パッケージが他のパッケージに依存する場合、対象のパッケージについての設定が書かれたファイルの指定などもできる。</p>
            <p>ショートカットディレクトリでは、起動に関する設定をまとめる。</p>
            <p>起動するゲームの指定、メインウィンドウのサイズの指定など。</p>
            <p>＊</p>
            <p>まとめると、</p>
            <p>パッケージディレクトリにゲーム本体をつっこみ、</p>
            <p>コンフィグディレクトリにパッケージの設定をつっこみ、</p>
            <p>ショートカットディレクトリにゲーム起動時の設定をつっこむ、といった具合か。</p>
            <p>あと、セーブデータディレクトリにゲームのセーブデータをつっこむ。</p>
            <p>＊</p>
            <p>一部の設定ファイルについては、拡張子が一致していれば複数のファイルに分割することも許可する予定。具体的にはベース設定とパッケージ設定。</p>
            <p>コンフィグディレクトリに配置する設定ファイルについても複数のファイルに分割できるようにしたいが、いい案が浮かばない。</p>
            <p>前述のファイル分割は、見やすさ、扱いやすさの向上などが目的だが、こちらは違う。</p>
            <p>パッケージとセーブデータの関連付けと、使用許可モジュールリストを別ファイルに分けることで、例えば使用するモジュールはそのままに別のセーブデータを使いたいとか、同じセーブデータを使うけど使用するモジュールは変えたいとか、そんな感じだ。</p>
            <p>ならばその2つの設定を別のディレクトリに分けてしまえば、と思わないでもないが、そこまですることだろうか。少なくともパッケージとセーブデータの関連付けの方はデータ量が少なすぎる。</p>
            <p>細切れになるばかりで扱いにくくなりそう。</p>
            <p>その辺は後々対応することにしようかしら。そのくらいなら、全体的に修正をかけなければならない、というレベルのものでもないだろうし。</p>
            <p>＊</p>
            <p>ともかく、現時点ではファイルとディレクトリの構成を考えただけであり、実際にそれを運用するためのプログラムは存在していない。</p>
            <p>今までのdropmakerは断片的にしか役に立たないだろうし、1から作っていくとしよう。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/22 00:14</h2>
            <p>色々考えていたが、dropmakerはまた作り直した方がいいかもしらんね。</p>
            <p>＊</p>
            <p>どうにもモジュールの管理周りがうすらぼんやりとしてよくない。</p>
            <p>指定したモジュールから関数のアドレスを取得する関数を、全てのロード済みモジュールから関数のアドレスを探して取得する関数に変えようとするだけでもなんかうまくいかない。</p>
            <p>うまくいかないというより、変更が大きくなりすぎるというか、1から作り直した方が早そうというか。</p>
            <p>この際、ディレクトリや設定ファイルの構成らへんから練り直すべきかもしれない。</p>
            <p>現状では、直接起動するパッケージ以外はセーブデータを持てないし。</p>
            <p>依存モジュールの解決も、今は単純な構成だからましだけど、ちょっと複雑な構成になるとすぐだめになりそう。</p>
            <p>＊</p>
            <p>大まかな構成はテキストに書き出したので、土日に実際にディレクトリや設定ファイルを並べてみるつもり。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/18 00:40</h2>
            <p>日をまたいでしまった。</p>
            <p>＊</p>
            <p>次の日のやる気に影響するかもしれないので、こんな時間まで作業するべきではない。</p>
            <p>さて、fg::Windowからfg::Screenを分離した。</p>
            <p>デモを使って正常に動作することも確認済み。</p>
            <p>ここまでは大したことはない。ファイルの移動と記述の置換、それと多少の修正でできた。</p>
            <p>ここからが本番。メインウィンドウの生成と、それをゲーム側から触れるようにする。</p>
            <p>＊</p>
            <p>sucrose-screen-*モジュールを追加したので、パッケージ設定ファイルに記述を追加していて思ったが、もうちょっと要素を追加した方がよさそうだな。</p>
            <p>そのモジュールがなんのインターフェースの実装なのかを示す情報が現時点では存在しない。</p>
            <p>今のところはモジュール名を同じにすることでそのインターフェースの実装モジュール、ということにしているが、それだと実装が複数存在する場合に対応できない。</p>
            <p>そこで、モジュールの設定ツリーになんのインターフェースの実装なのかを示す要素を追加してみようか、などと考えている。</p>
            <p>そこまで優先度が高いわけではないので、後々実装する予定。</p>
            <p>あるいはもっといい設計が思い浮かぶかもしれないし。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/14 12:40</h2>
            <p>ウィンドウを2つの型に分離することを検討している。</p>
            <p>＊</p>
            <p>OpenGLコンテキストの扱い方については昨日の調査で大体把握できたので、以降はメインウィンドウをどのように実装するか考えていた。</p>
            <p>しかし、どうにもうまくまとまらない。</p>
            <p>今のところ、ウィンドウはfg::Windowという型で表現しているが、これを直接使うと色々問題がある。</p>
            <p>例えば、fg::Windowはfg::close()を使えばウィンドウクローズ、fg::resize()という関数を使えばリサイズなどの要求が行なえるが、メインウィンドウに関してはこれらは必要ないように思う。</p>
            <p>また、fg::free()を使えばウィンドウの破棄ができてしまう。</p>
            <p>破棄はメインウィンドウを生成、制御するゲーム起動側でやるので、ゲーム側ではできないようにしたい。</p>
            <p>他にも色々あるが、要はウィンドウを表現するという意味ではfg::Windowでいいのだが、その機能などがメインウィンドウと合致しない、といった感じだ。</p>
            <p>＊</p>
            <p>ぱっと思い付いた対応として、例えばfg::MainWindowという型を作り、内部的にfg::Windowを持たせ、fg::MainWindowにはfg::Windowの持つ関数のうち一部だけを用意すればいいのではと考えた。</p>
            <p>しかしこれはあまりいい対応ではない。</p>
            <p>簡単に言えば面倒なのである。fg::MainWindowの内部にfg::Windowを持たせ、fg::Windowと似たような関数を用意するということは、fg::Windowに新たに関数を増やし、それがfg::MainWindowでも使えるようにすべき関数である場合、fg::MainWindowにも同じように関数を増やさなければならない。</p>
            <p>当たり前ではあるが、こういうのは忘れてしまう可能性があるし、またfg::MainWindowの方の関数はfg::Windowの同じ関数を呼び出すラッパー程度の関数になるとはいえ、記述ミスによるバグを抱えてしまう可能性もある。</p>
            <p>＊</p>
            <p>そこで考えたのが、ウィンドウを2つの型に分離する、という方法だ。</p>
            <p>今はウィンドウを表現する型はfg::Windowのみだが、これとは別に表示領域を表現する型を用意する。</p>
            <p>仮にfg::Screenということにするが、fg::Screenは自発的に生成、破棄することができない。</p>
            <p>再描画やリサイズなどのイベントについてはイベントハンドラを設定できるようにするが、リサイズリクエストはできないようにする。</p>
            <p>例えば、fg::Windowの内部的にfg::Screenを持たせる、という感じにする。</p>
            <p>fg::Windowを生成すれば、それに対応したfg::Screenも同時に作られる、ということだ。</p>
            <p>それで、fg::Windowの関数としてfg::getScreen()とかいう関数を用意して、fg::Screenの参照を取得できるようにする。</p>
            <p>メインウィンドウについては、ゲーム側からはfg::Screenの参照のみを扱えるようにする。</p>
            <p>fg::Screenの参照だけ、つまりメインウィンドウの表示領域だけなら、破棄もできないし勝手なクローズやサイズ変更の要求もできない。</p>
            <p>おまけに、ラッピングした型でもないのでラッパー関数を作る必要などもない。</p>
            <p>＊</p>
            <p>うまくいきそうな気はしている。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/13 16:00</h2>
            <p>OpenGLのコンテキストについて色々試したので、整理しておこう。</p>
            <p>＊</p>
            <p>ある1つのウィンドウを、複数のスレッドのカレントコンテキストに設定することは可能。</p>
            <p>ある1つのOpenGLコンテキストを、複数のスレッドのカレントコンテキストに設定することは不可能。</p>
            <p>やろうとすると、glXMakeCurrent()を呼び出すタイミングでセグメント例外が発生する。</p>
            <p>一度、スレッドのカレントコンテキストを別のOpenGLコンテキストに変えるなりすれば、別のスレッドのカレントコンテキストに設定することはできる。</p>
            <p>しかしその場合、別のスレッドのカレントコンテキストに設定する前に行なわれ、まだ画面に表示されていない描画処理は無かったことになる。</p>
            <p>なので、一度カレントコンテキストに設定したOpenGLコンテキストを、別のスレッドのカレントコンテキストに移すとかいうのは、あまり意味がないように感じる。</p>
            <p>少なくとも、ゲーム起動側がメインウィンドウに描画を行なうためのOpenGLコンテキストを、ゲーム側から参照できるようにする必要性は、ほぼないことが確認できたと言っていいだろう。</p>
            <p>OpenGLコンテキストを複数のスレッドで使えないので、複数のウィンドウに対して1つのOpenGLコンテキストを割り当てる、とかいう構成も当然無理。</p>
            <p>＊</p>
            <p>今の構成は、fg::GLContextを生成し、その参照とfg::Windowの参照を使ってfg::GLCurrentを生成、それを使ってOpenGLの関数を呼び出す、といった具合。</p>
            <p>別のスレッドのカレントコンテキストに設定し直す意味があまりないということは、fg::GLCurrentなんて作らず、fg::GLContextの生成時にOpenGLコンテキストの生成とカレントコンテキストの設定を行ない、破棄時にカレントコンテキストからの設定解除とOpenGLコンテキストの破棄をやってしまえばいいのでは、ともちょっと思ったけど、それもまたちょっと違うんだろうな。</p>
            <p>例えばテクスチャの情報などはOpenGLコンテキストに関連付けられるだろうし、ウィンドウを一度破棄してもう一度ウィンドウを作り、以前と同じような表示をしたい場合、その度にOpenGLコンテキストの生成を行なっていたのでは再度テクスチャの情報なども作り直さなくてはならない。</p>
            <p>OpenGLコンテキストの生成・破棄とカレントコンテキストの設定・設定解除を分離しておけば、その辺うまく使い回せそうな気がする。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/12 23:00</h2>
            <p>今まで中途半端に作っていたデモをきちんと整えるなど。</p>
            <p>＊</p>
            <p>メインウィンドウ、どうやって実装しようか考え中。</p>
            <p>実質的に、ウィンドウのイベントは再描画要求以外触れないようにしたいところ。</p>
            <p>加えて、必要に応じてゲーム起動側、つまりメインウィンドウを生成した側でも画面に描画を行なえるようにしたい。</p>
            <p>それはつまり、ゲーム起動側にメインウィンドウで使用するOpenGLのコンテキストを持たせるわけで。</p>
            <p>それがカレントコンテキストになっているスレッドも持たせる必要があるわけで。</p>
            <p>描画することを考えなければカレントコンテキストの件は無視できるので、とりあえずそれでやってみようかなぁ。</p>
            <p>1つのウィンドウを、複数のスレッドでカレントコンテキストにする、とかってできるのかなぁ。</p>
            <p>今まで試したことがないから、明日試してみようかな。</p>
            <p>その結果次第では、OpenGLコンテキストはゲーム側から参照できるようにしなくても済むかも。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/11 19:45</h2>
            <p>昨日書いた通り、OpenGLの関数を使えるようにした。</p>
            <p>＊</p>
            <p>ほとんど前のプロジェクトで書いたものを流用しただけだが、やはり少し手を加えなければ使える状態にはならなかった。</p>
            <p>しかし、OpenGLの関数や定数は数が多いため、一気にファイルの総行数が1万行ほど増えてしまった。</p>
            <p>定数が書かれたファイルでおよそ5500行、関数が書かれたファイルでおよそ3500行あり、これだけで9000行に達するので仕方ないが。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/10 19:50</h2>
            <p>垂直同期については対応した。</p>
            <p>＊</p>
            <p>あとはOpenGLの関数だが、前のプロジェクトで書いたものを流用すれば明日にも完了できる気がする。</p>
            <p>垂直同期の対応についても、基本的には前のプロジェクトのものを流用したわけだが。</p>
            <p>しかしながら、xlibのDisplayをグローバルでなくしたなど、構成を変えているために修正は必要だったが。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/07 20:20</h2>
            <p>OpenGLの対応の残件は、OpenGLの関数を使えるようにするのと、垂直同期対応。</p>
            <p>＊</p>
            <p>今日かコンテキストをカレントに設定する処理を作っていた。</p>
            <p>それに付随して、バッファの切り替え処理も対応した。</p>
            <p>現時点ではglClear()とか使えないので、バッファを切り替えてもゴミデータが表示されてしまうだけだが。</p>
            <p>これであとは、OpenGLの関数を使えるようになれば描画ができるようになる。</p>
            <p>＊</p>
            <p>OpenGLの残件を対応したら、メインウィンドウ機能を対応したいところだ。</p>
            <p>ゲームの実行前に自動的に作られ、ゲーム側に渡されるサイズ変更不可、移動検知不可のウィンドウ。</p>
            <p>事前に設定することでサイズを変更できたり、フルスクリーンで実行できたりなどというのを考えているのだが。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/06 19:15</h2>
            <p>昨日のは勘違いだった。</p>
            <p>＊</p>
            <p>見るデータが間違ってて、実際にはおそらく問題なかった。</p>
            <p>なんであんな勘違いをしたのか。</p>
            <p>あの勘違いをしたやつは直ちに名乗り出ろ。</p>
            <p>＊</p>
            <p>OpenGLの対応を進めている途中で、試しに動かしてみてどうしてもOpenGLの関数を呼び出すところでこけてしまう問題が起きていた。</p>
            <p>1時間程度試行錯誤して、valgrindを使って実行するとこけた気がするのを思い出して、valgrindを使わずに実行したらすんなり動いてがっくりした。</p>
            <p>無駄に疲れた。</p>
            <p>もうこんなことはしたくないものだが、忘れた頃にまたやりそう。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/05 19:50</h2>
            <p>排他処理、スレッドや、ウィンドウについてはとりあえず出来上がっている。</p>
            <p>＊</p>
            <p>今はOpenGLの対応を進めている。</p>
            <p>その途中で、スレッドのライブラリにwaitやnotifyを行なうためのインターフェースを追加したり、その実装を作ったりもした。</p>
            <p>とにかく画面に描画をできるようにしたいところ。</p>
            <p>＊</p>
            <p>valgrind使っててなんかおかしいと思ったら、dlopen()したライブラリがdlclose()されてなかった。</p>
            <p>なんかdlclose()にnullが渡されてるから、クローズされないし失敗もしない。</p>
            <p>ていうかNewModuleの型がおかしい。</p>
            <p>なんでこんな型になっているのか。</p>
            <p>この処理を書いたやつは直ちに名乗り出ろ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/30 20:35</h2>
            <p>イベントハンドラの対応、一応できた。</p>
            <p>＊</p>
            <p>しかし、排他処理のインターフェースを作っていなかったため、まだ実用的でない。</p>
            <p>ロックしてないから、データがおかしくなるかもしれない。</p>
            <p>やはりスレッドのインターフェースも作るべきだろうか。</p>
            <p>ロック関係をそこに含めるか。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/29 19:35</h2>
            <p>まためんどくなってた。</p>
            <p>＊</p>
            <p>sucrose-windowを作成中。あとはイベントハンドラの対応のみ。</p>
            <p>色々考えて、また少しイベントハンドラの扱いを変えた。</p>
            <p>イベントハンドラ部分については、ウィンドウシステムの実装とは無関係だと思ったので、sucrose-window-commonというライブラリに分離させた。</p>
            <p>linux用の、xlibを使う実装はsucrose-window-xlibとして作成してある。</p>
            <p>で、イベントハンドラ部分をあまりめんどくなさそうな感じに設計を変えたので、明日ぐらいには作り終えられるのではと考えている。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/20 19:25</h2>
            <p>順調、と言いたいがやはりスローペースな気がする。</p>
            <p>＊</p>
            <p>とりあえず、sucrose-jsonは使えるようにした。</p>
            <p>あとはsucrose-mainを使えるようにすれば、dropmakerを動かせるが。</p>
            <p>しかし、シンボルの取得とかは処理を書き直さねばならないだろう。</p>
            <p>CからC++にした影響だ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/17 21:20</h2>
            <p>よくよく考えたら、イベントハンドラでつまづいただけだったなぁ。</p>
            <p>＊</p>
            <p>なので、dropmakerに関しては、ほとんどそのままソースを持ってくればいいか、という気分になっている。</p>
            <p>細かく修正を入れようとして時間食うよりずっといい。</p>
            <p>昨日加えた修正の件も考えて、持ってきたソースの中の不要になるconst_castを消していっているのだが、参照系のクラスは全部2種類用意するべきかもしれないなぁ。</p>
            <p>というのも、fg::JsonObjectPairsで似たような状態が発生しているのだ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/16 21:00</h2>
            <p>体調がびみょう。</p>
            <p>＊</p>
            <p>このところ、そのせいか分からんがびみょうに思考がまとまりにくいし、集中もできてないような。</p>
            <p>そんな感じで進みも悪い。</p>
            <p>＊</p>
            <p>文字列参照型を2種類にした。</p>
            <p>std::basic_stringみたいな位置付けのやつだが、std::basic_stringと違い、自身では文字列の領域を保持したりせず、他のところに配置されている文字列を参照する型なのだが。</p>
            <p>今までの構成だとコンストラクタがchar *なので、const char *を入れようとするとconst_castしなければならなくてめんどすぎる。</p>
            <p>なので、コンストラクタにconst char *をつっこむのと、char *をつっこむやつの2種類の型を作ることにした。</p>
            <p>後者の型を前者の型の子クラスにしたので、わざわざオーバーロードした関数を用意しなくても済むし。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/14 21:30</h2>
            <p>10日に書き忘れた。</p>
            <p>＊</p>
            <p>gitのログ見てみたらなんかおかしいな。何回sucrose-commonの生成ルールを追加してるんだ。</p>
            <p>直すのもめんどくさいが。</p>
            <p>＊</p>
            <p>とりあえず、sucrose-commonとsucrose-strconv-iconvを作った。</p>
            <p>前のプロジェクトではstrconvは一度に1種類しかビルドできなかったが、今のプロジェクトでは複数の実装を一緒にビルドできるようにしてあるため、名前を変えた。iconvを使っているので末尾にiconvと足してある。</p>
            <p>commonとstrconvを作ったので、コマンドライン引数を処理するだけのプログラムがビルドできるようになった。</p>
            <p>が、リンクする静的ライブラリ名をハードコーディングしているので、それはどうにかするべきだな。</p>
            <p>必要に応じてコマンドライン引数から指定できるようにしたいが、どうやって処理するべきか。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/09 21:11</h2>
            <p>前のプロジェクトからソースをどんどん持ってきている。</p>
            <p>＊</p>
            <p>2種類のライブラリを生成する件についてはどうにかなった。</p>
            <p>違うプロジェクト間で、wscriptを同一にしなければならないという決まりがあるでもなし、プロジェクト毎に不要なものは削除し、必要なものは追加して対応することにした。</p>
            <p>早いところ、今までに作った部分は移行してしまって、新機能を作成していきたいところ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/08 20:10</h2>
            <p>ビルドの簡略化はできた。</p>
            <p>＊</p>
            <p>とりあえず前のプロジェクトからソースファイルをそのまま持ってきて、fg-commonの生成がきちんとできるのは確認した。</p>
            <p>正確には、fgppからソースを持ってきたのでFGPPをFGに、fgppをfgに置換したりはしたが。</p>
            <p>あれ、よく考えたらあるライブラリについて、静的ライブラリと動的ライブラリの2種類作るのはできなくないか？</p>
            <p>どうしよう。ぱっと思い付く修正案はあるものの、それでいいのかどうか。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/07 22:55</h2>
            <p>早速、作り直し中。</p>
            <p>＊</p>
            <p>ビルドの簡略化を行なっているが、想定よりちょっとめんどかった。</p>
            <p>あるパッケージに存在するモジュールの一覧を取得する処理が、そう簡単にはいかなかった。</p>
            <p>dir()はロード済みのモジュールしか取得できないし。</p>
            <p>調べたら、ModuleScannerというのを使えばいいというのは分かったので、それを使ってコマンドラインオプションを作るところまではやった。</p>
            <p>次は、そのコマンドラインオプションを使用した際に、対象のモジュールのビルドを実行する処理を作る。</p>
            <p>うまくいけば、新たにモジュールのビルドルールを追加しても、他のところにその処理を呼び出す処理を追加しなくても済む。</p>
            <p>configure時にコマンドラインオプションを追加するだけで、そのビルドルールでモジュールが生成されるようになる。</p>
            <p>また、コマンドラインオプションで指定しなければ、モジュールをビルドしないようにもできる。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/06 22:56</h2>
            <p>って、いかん。何また難しくしようとしてるんだ。</p>
            <p>＊</p>
            <p>まずはC/C++だけ、もしくはC++だけ扱うのでもいいじゃないか。</p>
            <p>まだ一つも完成させてすらいないのに、最初から事を大きくしすぎだ。</p>
            <p>JavaとかPythonとかPerlとか、まだ必要な場面ではないのだ。</p>
            <p>＊</p>
            <p>また迷走して時間ばかりかけてしまうところだった。</p>
            <p>メインのライブラリはどうしよう。また作り直すべきだろうか。</p>
            <p>今度は本格的に処理は丸々使えるが、今のプロジェクトに修正を加える形でもいい気がする。</p>
            <p>しかし、この機会にビルドの仕組みの簡略化もしてしまいたいし。</p>
            <p>それをする場合、やはり作り直すべきな気がする。</p>
            <p>というか、インターフェースライブラリはそのままでいいな。</p>
            <p>いや、ビルドの仕組みの簡略化はインターフェースライブラリもやるけど、それは修正を加える形でいいだろう。</p>
            <p>この際だから、Cのラッパーライブラリも作らず、完全にC++だけの構成にしてしまってもいいかもしれない。</p>
            <p>ラッパーというか、他の言語に同じインターフェースがあると、一方に修正を加えたらそちらにも同じ加えたくなるし。</p>
            <p>コードの量は増えてもできることは増えてないという、効率の悪いことになるし。</p>
            <p>＊</p>
            <p>うむ。C++のインターフェースライブラリ「fg」、実装ライブラリ「sucrose」、ライブラリ利用環境「dropmaker」という3つのプロジェクトから成る構成にするかな。</p>
            <p>あと、ライブラリ利用デモ「fgdemos」の4つか。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/06 22:20</h2>
            <p>結局、C++のライブラリをメインにした方がいい気がしてきた。</p>
            <p>＊</p>
            <p>イベントハンドラの関係で、C言語のライブラリをメインにしているとラッパーライブラリがうまく作れないのだ。</p>
            <p>逆に、C++のライブラリをメインにして、C言語のそのラッパーライブラリにすればうまくいくんじゃないかなぁ、といったところ。</p>
            <p>そもそもC言語のライブラリをメインに持ってきたところで、それを直接使うわけでもないし。</p>
            <p>C言語を直接使ってゲーム作るのとかやりたくないし。</p>
            <p>しかし、その程度で大きく変更をかけるのは場当たりすぎる気がする。</p>
            <p>もうちょっとこう、他の言語との連携周りなのだから、その辺どのように対応するのかを考えてから処理したいところだが。</p>
            <p>現状ではどうあがいてもC/C++などで作られた、lib*.soとか*.dllとかのライブラリしか対応できないわけで。</p>
            <p>例えば.jarやら.pyやら.pl、.pmやらも使えるようにしてみたいところ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/03 21:52</h2>
            <p>ウィンドウ制御処理、大体はできたのだが。</p>
            <p>＊</p>
            <p>ウィンドウ内全てについて再描画処理をリクエストする処理についてはまだ。</p>
            <p>XGetGeometry()の処理が完了せず止まってしまうことがある。原因はまだ不明。</p>
            <p>おそらく、このへんも昔に通った道のはずなのだが。</p>
            <p>もしかしたら、xorg-serverのバージョンアップが影響しているかもしれないが、多分そんな大げさなことはないだろう。</p>
            <p>というか、この関数本当に必要だろうか。なんとなく必要な気がする、というだけで存在させている感は否めない。</p>
            <p>やりたいなら、ウィンドウサイズ変更イベントのイベントハンドラを設定しておいてウィンドウサイズを取得し、それを使ってウィンドウ内全てに再描画リクエストを投げてもいいのだ。</p>
            <p>ウィンドウの位置についても、どうもxlibではうまいこと制御できない感があるので、というか前にもこれは体験した気がするので、ウィンドウの位置は制御できないようにした。</p>
            <p>これと同じように、関数自体を消すという対応でいい気もする。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/02 23:25</h2>
            <p>イベント発生時のイベントハンドラ呼び出し処理を追加している。</p>
            <p>＊</p>
            <p>イベントハンドラの設定とかその辺については、ウィンドウ制御側からは触らんわけだし、イベント発生時の処理を書いた後でもいいかなって感じで。</p>
            <p>イベント発生時の処理はリセット前のプロジェクトとほぼ同じで大丈夫なので、さくっと片付けてしまいたいところ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/01 19:12</h2>
            <p>おかしいな、イベントハンドラの形式が古い。</p>
            <p>＊</p>
            <p>set形式は色々だめだと判断して、add/remove形式に変えたはずなのだけれど、その形式にしたソースが見つからない。</p>
            <p>そんなもんだから、今のAPIはset形式になってしまっている。</p>
            <p>直さないといかんなー</p>
            <p>＊</p>
            <p>ウィンドウ制御については、とりあえず表示と、イベント処理スレッドの起動までは作った。</p>
            <p>で、イベントハンドラの呼び出しとかが必要になってきた時点で、前述の問題に気が付いた感じ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/30 19:45</h2>
            <p>終了関数については、結局後回し。</p>
            <p>＊</p>
            <p>xlibを使ったウィンドウ制御について実装を始めている。</p>
            <p>リセット前のプロジェクトを参考にしているものの、前の物よりは分かりやすいものにしようと考えながら記述している。</p>
            <p>その中で、ラムダ関数への変数のムーブキャプチャを使ったのだが、なんかエラーが消えないと思ったら、どうやらconstでキャプチャされるらしい。</p>
            <p>参照キャプチャではそんなことはなかったようなのだが。ふしぎ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/29 20:40</h2>
            <p>ひとまず、初期化処理呼び出しの位置変更は完了した。</p>
            <p>＊</p>
            <p>しかし、終了処理についてはまだ考え中。</p>
            <p>初期化関数の引数に、関数ポインタの参照を渡してそれに終了関数のアドレスを設定するという方法はあまりよくない気がする。</p>
            <p>直感的でないというかなんというか、分かりにくいというか。</p>
            <p>そんな回りくどい方法を取るくらいなら、設定ファイルに初期化関数名と終了関数名のペアを書いておくとかの方がいい気がする。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/26 19:20</h2>
            <p>どうも暴走していたようだ。</p>
            <p>＊</p>
            <p>昨日書いたことはどうにも浅はかすぎる。終了処理の呼び出しは同じように書くべきではないと思った。</p>
            <p>初期化処理の呼び出しと同じように、終了関数を設定ファイルで指定することで、モジュールをアンロードする前に終了処理を呼び出す、というのは安直だが、安直すぎてだめだ。</p>
            <p>それだと、初期化処理が途中で失敗した場合、どの終了処理を呼び出すべきで、どの終了処理は呼び出すべきでないのか。</p>
            <p>こういうのはよく、終了処理は全て絶対に呼び出し、終了処理の中で、初期化してあるなら処理を行ない、初期化していないなら何もしない、と書くべきなどと言われるが、私はそういうのが嫌いなのだ。初期化してないなら終了処理は必要ないのだから、最初から呼び出さない方がすっきりする。</p>
            <p>例えば、初期化処理の引数として関数ポインタの参照を渡しておき、初期化処理が正常終了する場合に対応する終了関数のアドレスを設定する、などすればいい感じになりそう。</p>
            <p>＊</p>
            <p>しかしながら、現状では安直な方法ですら行なうのが困難な状況だ。</p>
            <p>モジュールのアンロード処理で、ロードしたモジュールを表現するvoid*しか情報をもらっていないため、どこかに終了処理の関数名を含めるとかいったことができないのだ。</p>
            <p>構成を間違えた感じがある。モジュールのロード、アンロード処理に、初期化、終了の処理を含めるべきではなかったのだ。</p>
            <p>単純に巻き戻してしまってもいい気がする。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/25 21:00</h2>
            <p>初期化処理できあがり。</p>
            <p>＊</p>
            <p>次は、初期化処理と共通の部分は共通化して終了処理の呼び出しを作成する。</p>
            <p>厳密には、現時点ではまだ必要ないと思われるが、ほぼ同じ処理なわけだし、ちょっとしたらすぐ必要になると思うし。</p>
            <p>作っておいて損ないだろう、といったところ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/24 23:36</h2>
            <p>初期化処理の追加、途中までできた。</p>
            <p>＊</p>
            <p>初期化処理を走らせるところはできたので、次は走らせる処理を指定するところ。</p>
            <p>それが出来たら、終了処理についても同じように追加する。</p>
            <p>しかし、ModuleInfoとModuleKeyを分けている意味がないような気がする。</p>
            <p>一緒にしちゃってもいいんじゃないかな。</p>
            <p>＊</p>
            <p>ビルドの仕組み、簡略化すべきかも。</p>
            <p>現状では、あるモジュールについて、configureする時に実装を指定することで、その実装を使ったモジュールをビルドするのだが、モジュールの名前を別にすることで、複数の実装を同時に存在できるようにしようかと。</p>
            <p>現状では、例えばウィンドウ管理のモジュールは、linux用のxlibを使った実装でも、windows用のwin32を使った実装でも、作られるモジュールの名前はlinuxならlibfg-window.so、windowsならfg-window.dllになる。</p>
            <p>でも、例えばxlibを使った実装ならfg-window-xlibとか、win32を使った実装ならfg-window-win32とかにすれば、実装が異なる複数のウィンドウ管理モジュールを共存させることができる。</p>
            <p>その環境はビルドできない実装の場合は、configureでビルドしないように指定すればいいのだし。</p>
            <p>この変更をすることで、多分ビルドの仕組みは今より簡単になるはずなのだ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/19 20:02</h2>
            <p>困った。</p>
            <p>＊</p>
            <p>初期化が必要なモジュールについての考慮が足りていなかった。</p>
            <p>今まで通り、各OSに用意されている機能を使ってもいい気がするが、あれはあまりよくない。</p>
            <p>初期化時に処理が失敗した場合にどうするとか、そういったことができない。多分。</p>
            <p>きちんと調べたわけではないのだが、少なくともwindowsでは関数が1つ固定、関数名すら固定だし、それを使うくらいならば自分で機能を作ってしまった方がいい気がする。</p>
            <p>今のところの考えでは、パッケージ設定に記述するモジュールの設定に、初期化関数を指定できる形にしようかと考えているがどうなんだろう。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/18 20:47</h2>
            <p>総ソースファイル行数が1000行ほど減った。</p>
            <p>＊</p>
            <p>今まで、共通化できそうだけどめんどうなので放置していた場所を、マクロで共通化した結果、そんな感じになった。</p>
            <p>これで、あとは実装部分をリセット前のプロジェクトから持ってくればウィンドウを扱えるようになるだろう。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/17 20:50</h2>
            <p>というわけで、ウィンドウの対応を始めた。</p>
            <p>＊</p>
            <p>リセットする前のプロジェクトからファイルを持ってきて、ちょっと修正を加えて使えるようにしたりなど。</p>
            <p>若干インターフェースやマクロの仕様が違うので、完全にそのまま使うわけにはいかない。</p>
            <p>一気にファイル数が増え、総ソースファイル数が300に迫る勢い。</p>
            <p>明日には300を越すだろう。</p>
            <p>しかし、メインウィンドウの生成はどこでやるべきか。</p>
            <p>コンテキストに参照を持たせることは決まっているが、コンテキスト生成処理に混ぜるか、生成後に参照をコンテキスト生成処理に渡すか。</p>
            <p>前者でいい気がするのだが、なんかしっくりこないような。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/16 19:08</h2>
            <p>とりあえず、コマンドライン引数対応は終えたのだが。</p>
            <p>＊</p>
            <p>この次、本当にパスの扱いについてやるべきだろうか。後回しでもいい気がしてきた。</p>
            <p>いい案がぱっと浮かばないし、なによりやる気があまりしないのだ。</p>
            <p>それよりも、リセットする前のプロジェクトには実装されていたウィンドウや入力機器、音声機器の管理機能をサクサクッと実装して、試しにゲームでも作ってみるべきな気がする。</p>
            <p>ゲームを作らんと、いつまで経っても話が進まんのだ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/12 20:23</h2>
            <p>どうにも作業速度が思うように上がらないと思ったら案の定だった。</p>
            <p>＊</p>
            <p>そんなわけでまだ出来上がっていないが今日は疲れた。</p>
            <p>このまま出来上がるまで続行するというのは昔はよくやっていた気もするが、これをするとその後一層気分がよくなくなるのだ。</p>
            <p>よくない連鎖は発生する前に止めるに限る。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/11 20:00</h2>
            <p>とりあえずコマンドライン引数対応を始めた。</p>
            <p>＊</p>
            <p>一応、リセットする前のプロジェクトでは実装されていた機能なので、大体はそこから持ってくればいいだけなのだが。</p>
            <p>その後の処理は完全に1から書くことになるわけで、出来上がるのは早くて明日だろうな。</p>
            <p>今日はこれ以上続けるとだらだらしちゃうからやめやめ。</p>
            <p>TODOコメントをいくつか、ヒントとして追加しておしまい。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/10 22:10</h2>
            <p>パスの扱いについてまだ考え中。</p>
            <p>＊</p>
            <p>今日はバグの修正やら細かい変更などをしていた。</p>
            <p>パスについては後回しにして、先にコマンドライン引数で起動するプログラムの指定をできるようにしてしまった方がいいかもしれない。</p>
            <p>実際に必要になる場面を先に作ってしまえばイメージしやすそうな気がする。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/09 19:40</h2>
            <p>静的リンクしていたライブラリを、モジュールとして動的リンクして扱うように修正した。</p>
            <p>＊</p>
            <p>当初の予定では、静的リンクしているライブラリ5つを全て動的リンクさせたかったのだが、よく考えたらそのうち4つはモジュール管理処理から使っているので分離できず、結局1つのライブラリしか取り外すことができなかった。</p>
            <p>しかしながら、そのおかげで奇妙な処理の仕方をしていた箇所を削除することができたし、成果は悪くない。イメージのサイズも小さくなったようだし。</p>
            <p>複数のライブラリを修正する予定だったのでマクロとかも作って修正しやすくしたのだが、結局1つのライブラリしか修正できなかったので、ちょっと大げさになってしまった感はある。</p>
            <p>とはいえ、今後別のライブラリをリンクさせる予定があるので、その時には役立つかも。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/08 19:26</h2>
            <p>プログラム起動前のモジュール読み込みについても、依存関係を解決した上で読み込むようにした。</p>
            <p>＊</p>
            <p>これにより、プログラム起動前に読み込むモジュールについても、別のモジュールに依存させることが可能になった。</p>
            <p>今までは対象のモジュールのみ読み込む形だったので、他のモジュールに依存させていると正しく動作しなかったが、それが解決された。</p>
            <p>現状では、プログラム起動前に読み込むモジュールは他のモジュールに依存できないのを前提とした書き方をしていたはずなので、その辺は修正していくべきだろうな。</p>
            <p>＊</p>
            <p>次はコマンドライン引数で起動するプログラムの指定をできるようにしたいところだが、これをするとなるとパスの扱いをきちんと考えんと。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/06 13:18</h2>
            <p>おとといバージョン上げて、昨日プログラム起動前に読み込むモジュールのどうのこうのの前準備をした。</p>
            <p>＊</p>
            <p>というのを昨日書けばよかったのに忘れていた。</p>
            <p>今日明日はあまり作業しないようにする。</p>
            <p>のんべんだらりとなってくると、余計にやる気が減退してしまってよくない。</p>
            <p>そんな感じで、土日やら祝日やら、あとは平日の夜とかも、意図的に作業しないようにしている。</p>
            <p>せいぜい、なんか思い付いたらメモしておく程度。</p>
            <p>その方が、作業中集中できるし気分的にもいい気がするのだ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/04 17:16</h2>
            <p>やることは色々思い付くが、ここらでバージョンを上げて区切っておくべきだろうか。</p>
            <p>＊</p>
            <p>依存解決ありのモジュールロード処理のプロトタイプは出来上がっているわけだし。</p>
            <p>今後、コマンドライン引数で起動するプログラムを指定したりとか、プログラム起動前に読み込むモジュールも依存解決ありの形にしたりだとか、その他諸々を予定している。</p>
            <p>後者の機能を実装するために、ファイルの配置を変えたりしていたが、そろそろバージョンを上げてネット上のリポジトリにpushしておくべきだろうな。</p>
            <p>調子が良さそうに思える時ほど、冷静にならねば無意識のうちに暴走、迷走して失敗するのだ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/03 19:59</h2>
            <p>あるモジュールが複数モジュールから依存されている場合に、無駄にメモリ食ったり無駄な処理したりしないように修正した。</p>
            <p>＊</p>
            <p>簡単なデモプログラムを作ってみて、問題なく動作するのを確認した。</p>
            <p>しかし、必要なモジュールを依存モジュールリストから外しておいて、動作に失敗するはずのプログラムが普通に動いた、というのが起きた時はびびった。</p>
            <p>原因を調べたら、プログラムを実行するコアプログラム側に、必要なモジュールの処理が含まれており、プログラムがコアプログラム側の処理を呼び出しているために、普通に動いているように見える、ということだった。</p>
            <p>しかしコアプログラムはシンボルを全くエクスポートしていないはずなのに、なぜプログラム側から呼び出せているのか謎だったが、コアプログラムのリンク時に-rdynamicオプションを指定しているのがまずかったらしい。</p>
            <p>このオプションを付けているとバックトレースの表示を詳しくできるため、デバックビルドのリンク時には付けていた。</p>
            <p>しかしこのオプションの機能は「生成したファイル内に動的リンク用のシンボルを残す」というものであるため、今回のような問題が発生してしまったようだ。</p>
            <p>で、バックトレースを見る機会とか今のところほぼないし、別にいいかということで問題のオプションを使わないことで対応した。</p>
            <p>そもそもgrep backtraceとかやっても1件もヒットしなかったし、この記述自体が以前に作っていたプログラムの名残だったと思われる。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/02 18:44</h2>
            <p>やたー動いたー。</p>
            <p>＊</p>
            <p>もうちょい処理を追加する必要があるが、とりあえず動作するのを確認できた。</p>
            <p>依存モジュールのロードを行ない、プログラムを起動させることに成功。</p>
            <p>依存モジュールの指定方法をもうちょい種類増やしたりだとか、そもそも今のインターフェースで他の言語のプログラムを扱えるのかなど問題は色々あるものの、とりあえず一段落した気がする。</p>
            <p>あるモジュールが複数のモジュールから依存されている場合の処理をまだ書いてないので、それは追加する必要がある。</p>
            <p>それにしたって、効率的な処理にならない、というだけであり、想定では問題なく動作するはずだが。</p>
            <p>その辺確認するためにも、デモプログラムをいくつか作ってみる必要がありそう。</p>
            <p>モジュールの依存関係が循環してしまっている場合、現時点では正しく動作しない。多分無限ループみたくなって、そのうちスタック食い潰して落ちる。</p>
            <p>そもそも循環した依存関係というのが、他の言語とかでも常に許容されるのか分からんし、動作するように対応するかどうかはびみょう。循環を検出して、起動失敗にしたりなど、なんらかの対策は必要だろうけど。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/01 15:36</h2>
            <p>もうめんどいから過去ログに分割しなくてもいいんじゃないかな。</p>
            <p>＊</p>
            <p>パッケージシステムの暫定的な根幹ができあがりそうな感じ。</p>
            <p>＊</p>
            <p>また今日も、私の頭の中から湧き出た何かを形にするべく、その正体不明の何かを解析する作業。</p>
            <p>妄想なんだろうけど、見てはいけない何かを見つめ続けてしまっている気がする。</p>
            <p>そのうちもっと頭おかしくなるのではないだろうか。</p>
            <p>＊</p>
            <p>ポケモンエメラルドで捕まえられるポケモン全部捕まえた。</p>
            <p>あとはルビーやらサファイアやらでしか出現しないポケモンを捕まえて送り込まねば、ホウエン図鑑を埋めることはできない。</p>
            <p>送り込むだけならそれぞれのカートリッジと、安価で購入したゲームキューブとポケモンボックスを持っているのでできるのだが、通信ケーブルがないため通信進化ができない。</p>
            <p>アドバンスのケーブル、通販だと中古でも新品並みの値段になってたりするから困る。新品が定価の2、3倍とか頭おかしいと思う。手を出しがたい。</p>
            <p>＊</p>
            <p>さて、こわいこわい言ってないで作業せんと。クトゥルフ神話じゃないんだから未知に対する恐怖なんてあるものか。</p>
        </div>
<!--過去ログ用
        <hr />
        <div>
            <p><a href="/">戻る</a></p>
        </div>
-->
<!-- ここから過去ログ時に削除 -->
        <hr />
        <div>
            <h2>過去ログ</h2>
            <p><a href="201405.html">201405</a></p>
            <p><a href="201404.html">201404</a></p>
            <p><a href="201402.html">201402</a></p>
            <p><a href="201401.html">201401</a></p>
            <p><a href="201312.html">201312</a></p>
            <p><a href="201311.html">201311</a></p>
            <p><a href="201310.html">201310</a></p>
            <p><a href="201309.html">201309</a></p>
            <p><a href="201308.html">201308</a></p>
            <p><a href="201307.html">201307</a></p>
            <p><a href="201306.html">201306</a></p>
        </div>
<!-- ここまで -->
        <div id="for-nostylesheet">
            <hr />
            <img src="images/uni.png" />
        </div>
    </body>
</html>
