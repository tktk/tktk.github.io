<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>tekuto.net</title>
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-23511137-1"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'UA-23511137-1');
        </script>
    </head>
    <body>
<!--過去ログ用
        <div>
            <p><a href="/">戻る</a></p>
        </div>
-->
<!-- ここから過去ログ時に削除 -->
        <h1>tekuto.net</h1>
        <div>
            <p>メール:g.tekuto@gmail.com</p>
            <p><a href="http://twitter.com/tekuto" target="_blank">twitter</a></p>
        </div>
<!--テンプレート
        <hr />
        <div>
            <h2>YYYY/MM/DD hh:mm</h2>
            内容
        </div>
-->
<!-- ここまで -->
        <hr />
        <div>
            <h2>2019/10/26 05:25</h2>
            <p>非常にまずい。</p>
            <p>＊</p>
            <p>デッドロックを起こしてる。</p>
            <p>fg::Windowを抱えるfg::Stateを破棄しようとするとデッドロックする。</p>
            <p>fg::Stateが持つスレッド終了待機と、稼働を続けているfg::Windowのスレッドが衝突している感じ。</p>
            <p>＊</p>
            <p>どうしようかと考えたところ、一番の問題はXNextEvent()だな。</p>
            <p>こいつは次のイベントが存在しない場合、次のイベントが発生するまで永遠に待機を続けてしまう。</p>
            <p>この作用により、fg::State破棄時にスレッドを開始できないようにしているにも関わらず、それ以前からfg::Windowのスレッドが待機を続けているせいで、その機能がうまく働いていない状態になっているのだ。</p>
            <p>つまり、必要なのはタイムアウトだ。</p>
            <p>XNextEvent()が一定時間でタイムアウトする仕組みだったなら、fg::State破棄後にタイムアウトした場合、以降のスレッド開始は失敗するので、デッドロックにはならない。</p>
            <p>問題は、XNextEvent()にタイムアウトを設定することなどできないところだが。</p>
            <p>＊</p>
            <p>調べたところ、どうやらポーリングができるらしい。</p>
            <p>ConnectionNumber()とかいう関数の戻り値を使えば、select()でタイムアウト付きの待機ができる。</p>
            <p>タイムアウトしなかった場合にはイベントが来たということなので、XNextEvent()をしても待機が発生しない、というわけだ。</p>
            <p>＊</p>
            <p>しかしながら、これどうやってテストしたらいいんだろう。</p>
            <p>最初に書いた通り、fg::Windowを抱えさせたfg::Stateを破棄し、問題なく処理が終了することを確認すればいいのかな。</p>
            <p>コメントで、構成によってはデッドロックを起こすことがあるのでその対応、とか書いとかないと、なんのためのテストなのか分からなくなりそうだな。</p>
        </div>
        <hr />
        <div>
            <h2>2019/10/22 01:10</h2>
            <p>sucroseの書き直しは完了。</p>
            <p>＊</p>
            <p>brownsugarにfg::BasesystemStateを追加し、テストで実用的に扱うための機能も追加した。</p>
            <p>次はzarameの書き換えだ。</p>
        </div>
        <hr />
        <div>
            <h2>2019/10/19 02:40</h2>
            <p>ペースは悪くない。</p>
            <p>＊</p>
            <p>brownsugarにcandymakerから機能を移植し、sucroseの書き直しに必要な機能を最低限用意した。</p>
            <p>その機能を使い、sucroseの機能を書き直していて、残るはudev関係のみとなった。</p>
            <p>ちゃちゃっと書き換えて次に進もう。</p>
            <p>＊</p>
            <p>brownsugarにzarame書き換え、というかベースシステム作成時のテストに必要な機能を追加し、zarameを書き換え、動作確認をし、不要になった機能の削除。</p>
            <p>負荷高い作業もなさそうだし、来週中には完了できると思うのだが。</p>
            <p>＊</p>
            <p>ベースシステムに実装する機能のインターフェースを1つのディレクトリにまとめたいが、名前はどうしようかな。</p>
        </div>
        <hr />
        <div>
            <h2>2019/10/12 02:00</h2>
            <p>ベースシステム起動処理の書き直しまでで精一杯だった。</p>
            <p>＊</p>
            <p>zarameを新しい仕様に合わせて書き直す前に、sucroseの旧構成依存の処理書き直しが先だな。</p>
            <p>そしてその前に、brownsugarを新しい仕様に合わせるのが先だな。</p>
            <p>全部完了するまでに、今月いっぱいかかってしまいそうな気がする。</p>
        </div>
        <hr />
        <div>
            <h2>2019/10/05 03:45</h2>
            <p>ペース下がってる。</p>
            <p>＊</p>
            <p>ベースシステムの起動処理書き直しに際して、既存の処理で使われてる型を排除しようとしたら妙に色々なところで参照されてて困った。</p>
            <p>多分、ファイルから読み込んで生成した型をできるだけそのまま扱い、必要になったタイミングでその型から文字列などの具体的なデータを生成する、という方針で書いたんだったような。</p>
            <p>それにより、データ生成時に生成処理で必要な型を参照する必要がある。</p>
            <p>しかし、今見返してみた感じでは変な依存関係ができて複雑化してしまうだけで意味がなさそう。</p>
            <p>なので、早いタイミングで具体的なデータを生成するように変更し、データ利用時点で変な依存関係ができないように修正している。</p>
            <p>なかなか骨が折れるが仕方がない。</p>
            <p>他にも、例外を送出しないように記述していた名残りなども見受けられるので、見つけ次第修正している。</p>
            <p>＊</p>
            <p>そんなわけでやはり今週中は無理だった。</p>
            <p>前述のような修正を始める前に、どこからどのように手を付けたらいいのか悩まされたのも大きい。</p>
            <p>来週中にはどうにかしたい。</p>
        </div>
        <hr />
        <div>
            <h2>2019/09/27 00:00</h2>
            <p>作業の進行具合は悪くない。</p>
            <p>＊</p>
            <p>fg-stateの機能をfg-coreに移し、実装もsucroseからcandymakerに移行している。</p>
            <p>スレッド周りも一緒に移行する。</p>
            <p>既存の機能で残りはイベント関係の型。</p>
            <p>この辺は、前にも書いたが仕様がちょっとおかしい部分があるので、せっかくなので解消しておこうと思う。</p>
            <p>＊</p>
            <p>機能の移行が済んだら、次はベースシステムの起動処理を書き直し、zarameも新しい仕様に合わせて書き直す。</p>
            <p>sucroseの不要になる機能に依存している処理を書き直したら、不要になった機能の削除。</p>
            <p>最終的にfgやcandymakerからも不要になった機能を削除したら完了、という感じか。</p>
            <p>来週中に完了、はちょっと厳しい気がするなぁ。</p>
            <p>再来週中には完了したいところ。</p>
        </div>
        <hr />
        <div>
            <h2>2019/09/21 01:45</h2>
            <p>昨日、未検証の部分を検証した。</p>
            <p>＊</p>
            <p>その結果、私の考えている構成が私の考えていた方法で実現可能だと確認が取れた。</p>
            <p>しかしながら、それを実現するためには根本部分に変更が必要になる。</p>
            <p>実現できるのはうれしいのだが、少し気が滅入ってしまった。</p>
            <p>大きな変更を終えてなお、大きな変更が必要になるとは。</p>
            <p>＊</p>
            <p>必要な変更は大まかに2つ。</p>
            <p>1つは昨日検証した部分とは直接の関係はない。</p>
            <p>既存の機能をちょちょいといじったものを作り、その後に大きな変更が必要になると思われる。</p>
            <p>もう1つの変更は前述の変更が前提になっている部分があるので、後に回そう。</p>
        </div>
        <hr />
        <div>
            <h2>2019/09/19 02:15</h2>
            <p>古い機能の削除と、細かい修正完了。</p>
            <p>＊</p>
            <p>これでバージョンを確定。</p>
            <p>マルチスレッド周りでバグが起きていたのが厄介だった。</p>
            <p>きちんと直ったのか、あまり自信がない。</p>
            <p>一応動いてはいるが仕様がちょっとおかしい部分とかあるので、後々その辺の修正はした方がいいな。</p>
            <p>＊</p>
            <p>最終的な全体の構成のイメージが大体まとまった。</p>
            <p>まだ未検証の部分があるので、その辺の確認が必要だな。</p>
        </div>
        <hr />
        <div>
            <h2>2019/09/12 23:30</h2>
            <p>想定より時間がかかった気がするが、機能追加完了。</p>
            <p>＊</p>
            <p>brownsugarの方を全く触ってなかった。</p>
            <p>brownsugarを新しい構成に合わせて構築し直せば、ゲーム側を除けば古い機能を利用している部分はなくなるはずだ。</p>
            <p>そうなれば、いよいよ古い機能を削除できる。</p>
            <p>古い機能の削除まで含めて明日中に終わればいいんだが、さすがに無理かな。</p>
        </div>
        <hr />
        <div>
            <h2>2019/09/12 02:10</h2>
            <p>へびゲームが動作することを確認。</p>
            <p>＊</p>
            <p>多少sucroseに修正が必要だったが、確認が取れたのでひとまず安心。</p>
            <p>ただ、実際に新しい仕様を利用してみて、少々機能の不足を感じた。</p>
            <p>不要になる機能の削除は、その機能の追加が終わってからだな。</p>
            <p>量は多くないし、明日中に追加を終えられると思うが。</p>
        </div>
        <hr />
        <div>
            <h2>2019/09/11 00:40</h2>
            <p>これで機能追加は済んだかな。</p>
            <p>＊</p>
            <p>メインウィンドウの描画イベントとコントローライベントに対応した。</p>
            <p>明日、へびゲームを新しい仕様に合わせた形に書き換えてうまくいくか確認しよう。</p>
            <p>確認が取れたら、不要になる機能を削っていく。</p>
        </div>
        <hr />
        <div>
            <h2>2019/09/05 02:00</h2>
            <p>fg-controller自体への変更は多分必要ない。</p>
            <p>＊</p>
            <p>というわけでzarameに手を加えている。</p>
            <p>zarameにメインウィンドウ描画イベントをほぼ追加した。</p>
            <p>結論としては、fg::GLTaskExecutorみたいのは必要だった。</p>
            <p>fg::GLTaskExecutorはスレッド処理の後に描画バッファのスワップをするので便利。</p>
            <p>というか、OpenGLコンテキスト使わないと描画バッファのスワップができない仕組みになっているので、ないと困る。</p>
            <p>なので、zarameのメインウィンドウ描画イベントは、今のところ描画してもバッファがスワップされないので画面に反映されない状態になっている。</p>
            <p>それでは使い物にならない。</p>
            <p>＊</p>
            <p>fg-gl_newが必要だ。</p>
            <p>新しい構成に合わせたfg::GLTaskExecutorのようなものが必要になる。</p>
        </div>
        <hr />
        <div>
            <h2>2019/09/03 02:30</h2>
            <p>fg-window_newほぼ完成。</p>
            <p>＊</p>
            <p>メインウィンドウに関する処理以外はできた。</p>
            <p>インターフェースを作ったところで、実装はzarameでやることになるし後回しにしようかと。</p>
            <p>＊</p>
            <p>次はOpenGLの対応かなと思ったけど、必要ないかもしれない。</p>
            <p>fg::GLTaskExecutorとか、スレッドで処理している型はあるが、新しい構成では必要なさそう。</p>
            <p>むしろ、これなんで必要だったんだっけ？とすら考えている。</p>
            <p>なんで必要だったんだっけ。</p>
            <p>＊</p>
            <p>そうなると、次はfg-controllerかな。</p>
            <p>後はベースシステム用のインターフェースを整え、zarameに実装し、不要になる既存のライブラリを削除し、名前を整える。</p>
            <p>そんな感じか。</p>
        </div>
        <hr />
        <div>
            <h2>2019/08/30 01:15</h2>
            <p>宣言通りにfg-state_newの改良は昨日のうちに完了して、fg-window_newに取りかかっている。</p>
            <p>＊</p>
            <p>fg-state_newの構成変更により、fg-window_newは多少構成をシンプルにできそうだ。</p>
            <p>以前のfg-windowでは、ウィンドウの実体とウィンドウのイベント処理を別の型に分ける、という構成になっていたが、そんなことせず1つにまとめられそう。</p>
            <p>ただ、1つにまとめると内容が多くなるので、結構複雑になりそう。</p>
            <p>まずウィンドウの実体のみ作るように書いて、そこにイベント処理を追加していく形で進めて行こうと思う。</p>
            <p>最初から全てつっこむのは無謀な気がする。</p>
        </div>
        <hr />
        <div>
            <h2>2019/08/28 03:00</h2>
            <p>ひらめいたのでfg-state_newを改良中。</p>
            <p>＊</p>
            <p>この変更により、一度に複数のイベント関数を有効にする、という処理ができるようになる。</p>
            <p>明日中には完了したいところ。</p>
        </div>
        <hr />
        <div>
            <h2>2019/08/23 22:20</h2>
            <p>fg-state_new完成。</p>
            <p>＊</p>
            <p>関連する機能の修正が済んだら旧版のfg-stateを削除し、名前をfg-stateと改める。</p>
            <p>＊</p>
            <p>しかしこの構成でうまくいくのだろうか。</p>
            <p>旧版なら複数のイベント関数を一度に全て変更する、という処理ができたが、新版で全く同じ処理はできない。</p>
            <p>有効だったイベント関数を一度に全て無効にする、という処理はできる。</p>
            <p>一度に複数のイベント関数を有効にする、という処理ができないのだ。</p>
            <p>どうにかできたらいいのだが。</p>
        </div>
        <hr />
        <div>
            <h2>2019/08/23 01:00</h2>
            <p>ようやくfg-stateの練り直しが終わりそう。</p>
            <p>＊</p>
            <p>ほぼ完成しているが、型名や関数名の変更した方がいいものや、追加した方がよさそうな機能などがちらほらある。</p>
            <p>名前変更は2つ、機能追加は1つだが関数としては4つか。</p>
            <p>それが済めばfg-stateの新版は完成かな。</p>
            <p>あとは、それを利用する機能、つまりウィンドウやコントローラ周りを合わせればようやく完成。</p>
            <p>明日のうちに、細かい修正は全て終えてしまいたいところ。</p>
        </div>
        <hr />
        <div>
            <h2>2019/08/02 02:20</h2>
            <p>fg::Stateは一段落。</p>
            <p>＊</p>
            <p>よく分からん死に方については、多分どうにかなった。</p>
            <p>問題は処理自体でなくテストコードの方だったようで、作り直す過程でテストを見直し、修正したら問題は起きなくなった。</p>
            <p>しかしながら、問題の原因は特定できず、直した後は今のところ起きてない、という状態なので、実は直ってないがたまたま問題が発生してないだけ、という可能性も否定できない。</p>
            <p>多分大丈夫だと思うんだけど。</p>
            <p>＊</p>
            <p>次はfg::StateManagerかな。</p>
            <p>完成し次第、fg::StateManagerが必要なfg::Stateの処理も追加し、完成させる。</p>
        </div>
        <hr />
        <div>
            <h2>2019/08/01 00:40</h2>
            <p>fg::Stateの作成に苦戦中。</p>
            <p>＊</p>
            <p>一応は動くのだが、たまによく分からん死に方をする。</p>
            <p>マルチスレッド処理はよく分からん問題がたまに起きるのが困る。</p>
            <p>決まっていつも同じ死に方をするのであれば、解決も楽なのだが。</p>
            <p>一部の関数を作り直すことで解決しようと思い、テストと処理をコメントアウトしたところで今日はおしまい。</p>
            <p>やってもやっても直らんエラーの対応は精神を削りすぎる。</p>
        </div>
        <hr />
        <div>
            <h2>2019/07/23 01:00</h2>
            <p>fg-stateのインターフェース練り直しに苦戦中。</p>
            <p>＊</p>
            <p>イベントの管理方法を変更したことで、他の部分も変更した方がよりよくなる部分が出てきた。</p>
            <p>それらをうまくまとめようとしているが、なかなかうまくいかない。</p>
            <p>イベントの管理をfg::StateStack単位でなくしたことで、積み重ねるfg::Stateを一元管理する必要がなくなった。</p>
            <p>よってfg::StateStackそのものは必要なくなり、より単純なもので代替可能になった。</p>
            <p>fg::Stateの中に次のfg::Stateを構築する、連結リストのような感じだ。</p>
            <p>ただし、fg::State自体は常に触れる状態にしたくないため、直接は構築できないようにする。</p>
            <p>先頭要素を内部で構築、保持する型として、fg::StateManagerという型を用意する。</p>
            <p>fg::StateManagerが、fg::StateStackのより単純な代替型というわけだ。</p>
            <p>＊</p>
            <p>そのように変更しようとしたが、実際に利用する上で不便がないようにまとめるのはなかなか困難だ。</p>
            <p>大体まとまったようにも思うが、まだ不十分な部分もある。</p>
            <p>できるだけ早く仕上げたい、というか時間かけすぎだ。</p>
            <p>やる気下がってるのも影響してるが。</p>
        </div>
        <hr />
        <div>
            <h2>2019/07/11 03:00</h2>
            <p>sucrose::ThreadCacheを練り直してる。</p>
            <p>＊</p>
            <p>fg-stateのインターフェース変更に伴い、スレッドを管理する部分について後々削除することになるfg-taskから独立させようとした。</p>
            <p>しかし、改めて記述を見てみるとなかなかひどかったので、作り直すことにした。</p>
            <p>標準的なスレッド、複数起動を許可しないスレッド、キャンセル可能なスレッド、といった様々な種類のスレッドを、1種類のスレッドのパラメータ違いで混在させていて、妙に複雑になっているのだ。</p>
            <p>そこで、違う種類のスレッドは違うものとして扱うことで、単純化を図った。</p>
            <p>＊</p>
            <p>その単純化はおおむね成功した、というのが昨日。</p>
            <p>sucrose-udevや、sucrose-udev-joystickの内部で使用しているスレッド処理を、新しく作ったsucrose::ThreadCacheに差し替えて従来通り動作することが確認できた。</p>
            <p>が、キャンセル可能なスレッドの破棄時、原因がよく分からないSIGABRTが発生することがあり、今日はそれに四苦八苦していた。</p>
            <p>それで、結局キャンセル可能なスレッドそのものを使わず、記述を全て破棄することで一応は解決した。</p>
            <p>しかし、問題の根本はそれで解決したわけではない。</p>
            <p>新しいsucrose::ThreadCacheの構成が、古いsucrose::ThreadCacheの構成に引っ張られている部分が多いのが問題なのだ。</p>
            <p>スレッドが保持するデータはsucrose::Threadとして分離してあるのに、std::threadを使って実際に稼働させる処理はsucrose::ThreadCache内に存在している。</p>
            <p>std::threadによるスレッド稼働部分もsucrose::Threadに分離した方が、もっと単純になるはずだ。</p>
            <p>＊</p>
            <p>というわけで、新しいsucrose::Threadを作るところまでやった。</p>
            <p>明日中には、再度新しくしたsucrose::ThreadCacheを作り切りたい。</p>
            <p>できることなら、キャンセル可能なスレッドことsucrose::CancellableThreadについても、今度はちゃんと作ってみたい気もするが、やっぱり必要ないかなぁ。</p>
            <p>POSIXであればキャンセルにpthread_cancel()を使うので、大体どの辺りでキャンセルが起きるのか分かる。</p>
            <p>しかしWindowsの場合、多分TerminateThread()を使うことになる。</p>
            <p>よく調べてないというのもあるが、TerminateThread()はキャンセルタイミングがよく分からない。</p>
            <p>というかTerminateThread()ってこれキャンセルじゃなくてスレッド強制終了だろ。</p>
            <p>正常系で使うべき関数じゃない気がするんだよなぁ。</p>
            <p>であれば、Windowsでは表現できないわけだし、キャンセルに準ずる機能を使用しない構成にするべきだと思う。</p>
        </div>
        <hr />
        <div>
            <h2>2019/06/25 01:55</h2>
            <p>fg-stateのインターフェースを練り直した。</p>
            <p>＊</p>
            <p>まだ完了はしていないが、大まかにはできている。</p>
            <p>既存のインターフェースよりもよくなっているように思う。</p>
            <p>fg::Stateに対し、インデックスと関数ポインタをペアで設定するインターフェースはやめた。</p>
            <p>そもそも、イベントの管理をfg::StateStack単位で行なっているのがよくなかったのだ。</p>
            <p>そのせいで、ステート間に妙な依存関係ができてしまっている。</p>
            <p>ステート単体の動作テストがやりにくいのも、その辺りが影響している。</p>
            <p>なので、イベントの管理をfg::State単位で行なうことにした。</p>
            <p>これにより、ステートが単体で完結する構成になったはずだ。</p>
            <p>動作テストもやりやすくなるだろう。</p>
            <p>代わりにステート1つ辺りの記述は増えてしまうだろうが、既存のものが横着していた部分を正したんだと思えば、理不尽なものでもないだろう。</p>
            <p>＊</p>
            <p>既存のインターフェースからそのまま引っ張ってきている部分も半分くらいはあり、その中には変更した方が良さそうな部分もまだある。</p>
            <p>また、自発的に非同期実行を開始するインターフェースの追加もできていない。</p>
            <p>明日中には完了させ、sucroseに実装していきたい。</p>
        </div>
        <hr />
        <div>
            <h2>2019/06/21 18:20</h2>
            <p>fg-taskをfg-stateに統合するべきかもしれない。</p>
            <p>＊</p>
            <p>現在は全体的にfg-stateありきの構成になっているのだが、fg-taskはfg-stateより前に作ったため、噛み合わない部分が出てきている。</p>
            <p>fg-taskはスレッドによる非同期実行を管理するモジュールだが、fg-stateと全く関わりがないため、ステートを意識した処理は自前で書かないといけないのが現状だ。</p>
            <p>ステートの表示をアニメーションさせたりする際に、fg-taskを用いて非同期処理しているが、他のステートに移行する前には停止する処理を記述しないと、ステートの移行後も前のステートの非同期処理が動き続けてしまう。</p>
            <p>そういった動作が有効に働く場面もあるだろうが、大抵の場合は望まない動作となるだろう。</p>
            <p>ステートが移行した時点で、基本的に前のステートは動作を完全に停止するべきなのだ。</p>
            <p>＊</p>
            <p>sucroseではudevによるデバイス管理などでスレッド処理をしているため、そのために現状と同じ仕組みはそのまま残す必要があるだろう。</p>
            <p>fgからfg-taskを削除し、fg-stateのインターフェースを一新、実装も新しく作り直す、といったところか。</p>
            <p>＊</p>
            <p>しかし、これは今やるべきなのかどうか。</p>
            <p>インターフェースが大きく変わるわけだし、早めにやっておかないと困ることになるのは確実なのだが。</p>
            <p>とりあえず、コントローラ設定の導入画面を作り切るのが先か。</p>
        </div>
        <hr />
        <div>
            <h2>2019/06/15 05:10</h2>
            <p>アニメーションを手軽に作れるようにするための型、fg::Motionは大体完成した。</p>
            <p>＊</p>
            <p>しかし、実際に使うとなると足りない機能が色々出てきて、まだタイトル画面の書き換えは完了していない。</p>
            <p>もう少しだと思うのだが。</p>
            <p>残件は、経過時間を表す型が整数型の場合に、値が滑らかに変動しない件の修正。</p>
            <p>経過時間を浮動小数点にキャストできれば解決するが、これがそれほど単純にはできない。</p>
            <p>例えば経過時間を表す型がstd::chrono::durationの場合、直接浮動小数点型にキャストできないからだ。</p>
            <p>手順としては、count()で数値を取り出し、それをキャストする、となる。</p>
            <p>キャストをファンクタで行うようにし、必要に応じてキャスト処理をユーザー定義の処理に差し替えられるようにすれば対応できるだろう。</p>
            <p>＊</p>
            <p>モチベーション的に土日に作業するのは避けたいのだが、このくらいは済ませてしまうか。</p>
        </div>
        <hr />
        <div>
            <h2>2019/06/12 03:20</h2>
            <p>アニメーションを手軽に作れるようにするための型を作っている。</p>
            <p>＊</p>
            <p>コントローラ設定の導入画面で、何かボタンを押してください、みたいな文字列を点滅させるのが目的だ。</p>
            <p>そういった処理を書くのは、そこまで面倒というわけではない。</p>
            <p>似たような処理はタイトル画面の処理で作っているのだ。</p>
            <p>しかしながら、この先似た処理は頻繁に出てくることが考えられ、そのたびに別の画面を参考にして処理を書く、なんていうのはコピペに近い。</p>
            <p>それに、コピペに近いとは言えコードを追加するということは、毎度毎度似たようなテストコードを書くはめになり、そうなってくると非常に面倒だ。</p>
            <p>というわけで、ロジック部分をテンプレートで表現した型をfgに追加することにした。</p>
            <p>＊</p>
            <p>とりあえず、3つほど型を作った。</p>
            <p>まず、開始時間から終了時間までの間に、値を開始値から終了値まで変化させる型。</p>
            <p>次に、一定の間隔で値を開始値から終了値まで変化させ、その後は今度は開始値に向けて値を変化させ、と値を振り子のように変化させる型。</p>
            <p>そして、それらの型をまとめる型だ。</p>
            <p>1番目の型は、フェードインやフェードアウトといった、1回変化させたらそれで終わり、というアニメーションに使う。</p>
            <p>タイトル画面で行なっているアニメーションもそういうタイプなので、完成したら差し替える予定だ。</p>
            <p>2番目の型は、点滅や振動など、継続的に変化させる必要があるアニメーションに使う。</p>
            <p>最初に述べた、コントローラ設定の導入画面で使用する予定だ。</p>
            <p>3番目の型は、複数のアニメーションを同時に動かす場合に使う。</p>
            <p>単純に仕組みだけで考えれば、1、2番目の型があればアニメーションの表現は可能だ。</p>
            <p>しかし、それを複数同時に動かす場合、それぞれ個別に現在値を更新する関数を呼び出すのは面倒だ。</p>
            <p>この型があることで、1回の関数呼び出しで複数のアニメーションに対して処理を適用できる。</p>
            <p>書き忘れなどによるバグも起きにくくなるはずだ。</p>
            <p>＊</p>
            <p>現在想定している型はあと2つ。</p>
            <p>1つは一定の間隔で開始値から終了値まで変化させ、その後は再度初期値に戻して同じことを繰り返す型。</p>
            <p>現時点では必要ないし、使い道があるかどうか疑問だったが、よく考えたら回転アニメーションを表現する場合には必要になるだろうし、作ることにした。</p>
            <p>もう1つは、アニメーションを管理する型だ。</p>
            <p>これがないと、今まで作った型を動作させられない。</p>
            <p>＊</p>
            <p>明日中には完成予定。</p>
            <p>完成したら、タイトル画面を書き換えてみよう。</p>
        </div>
        <hr />
        <div>
            <h2>2019/05/25 00:00</h2>
            <p>タイトル画面の描画処理を作った。</p>
            <p>＊</p>
            <p>描画処理なんて内部的には特に関係ないんだし、最初は後回しにするつもりだった。</p>
            <p>でも、なんでもかんでも後回しにするのもどうかと思ったので、skiaの利用に慣れるのも兼ねてやることにした。</p>
            <p>で、アニメーションさせてタイトル画面を表示する処理を作った。</p>
            <p>割と簡単にできていい感じだ。</p>
            <p>＊</p>
            <p>次はコントローラ設定画面か。</p>
            <p>見た目ができればなんか進んだ感触があるし、これも見た目から作っていこうかな。</p>
        </div>
        <hr />
        <div>
            <h2>2019/05/22 00:40</h2>
            <p>kasuteraに文字列描画処理追加などしていた。</p>
            <p>＊</p>
            <p>sucroseで例外を投げるように変更したり、candymakerでモジュールのロード順を修正したりなどもした。</p>
            <p>色々片付けていたら、追加した方がよさそうな機能もまた見えてきた。</p>
            <p>そろそろディレクトリ構成について考えた方がよさそう。</p>
            <p>現状存在しているカレントディレクトリ以外にも、ホームディレクトリ、システムディレクトリを扱えるようにしたい。</p>
            <p>＊</p>
            <p>しかしながら、それよりも先にkasuteraの方を進めるべきな気もする。</p>
            <p>土台固めばかりしていても前に進まない。</p>
            <p>kasuteraや、ゲームの制作を進めて行かなければ前に進まないのだ。</p>
        </div>
        <hr />
        <div>
            <h2>2019/05/11 02:30</h2>
            <p>改修完了、したはず。</p>
            <p>＊</p>
            <p>ただ、別件でもうちょい修正が必要だな。</p>
            <p>brownsugarとfg::DataElementListとかfg::DataElementMapに修正が必要だ。</p>
        </div>
        <hr />
        <div>
            <h2>2019/05/08 00:40</h2>
            <p>先週までに終わらせたかったけど無理だった。</p>
            <p>＊</p>
            <p>先週の火曜ごろに高熱が出てくたばってたので。</p>
            <p>今も微熱が残っているけど、作業に支障はない。</p>
            <p>＊</p>
            <p>zarameまで修正できた。</p>
            <p>あとはcmsnakeを修正して動作の確認取れたら、いよいよ古い処理は消していくか。</p>
            <p>いや、kasuteraの修正を終えてからか。</p>
        </div>
        <hr />
        <div>
            <h2>2019/04/20 01:00</h2>
            <p>やはりデータ構造の修正はきつい。</p>
            <p>＊</p>
            <p>ユニークポインタの新しい仕様への変更がまだ終わらない。</p>
            <p>あと少しではある。</p>
            <p>残りはコントローラとOpenGLのライブラリだ。</p>
            <p>それが終わったら関連するプロジェクトの記述を差し替えて、それが済んだら古い仕様の記述を削除する。</p>
            <p>遅くても再来週中には完了したい。</p>
            <p>＊</p>
            <p>前回最後に書いた、形にできたとかいう新しい仕様？</p>
            <p>そのうちbitbucketの方にpushするから興味ある奇特な人はそっち見て。</p>
        </div>
        <hr />
        <div>
            <h2>2019/03/13 14:00</h2>
            <p>ユニークポインタ周りの新しい仕様を模索していた。</p>
            <p>＊</p>
            <p>本当は画面周りを進めようと思っていたのだが、謎のタイミングでSEGVで死んでしまう原因が、データ解放にローカルのfree()を呼ぶ予定のはずが標準関数のfree()が呼ばれていたため、とかいうふざけた記述ミスが原因だったので気が抜けてしまった。</p>
            <p>なかなか原因を特定できなかったので、無駄に気力を消耗してしまったのだ。</p>
            <p>＊</p>
            <p>で、ユニークポインタだけど、色々と問題はあるのだがまず記述がC++風になっていないことだ。</p>
            <p>C++風と言っていいのかは分からないが、要するにメンバ関数の利用ができない、ということである。</p>
            <p>例えばウィンドウを生成し、生成したウィンドウに再描画要求を投げる、という記述を現状の構成でやると以下の通りだ。</p>
            <p>＊</p>
            <p>auto windowUnique = fg::newWindow( ... );</p>
            <p>auto &amp; window = *windowUnique;</p>
            <p>fg::repaint( window );</p>
            <p>＊</p>
            <p>fg::newWindow()はfg::Windowという型のユニークポインタ、fg::Unique&lt; fg::Window &gt;を返す。</p>
            <p>fg::Unique&lt; fg::Window &gt;というのは、大まかにはstd::unique_ptr&lt; fg::Window * &gt;のエイリアスである。</p>
            <p>実際にはデリータも設定しているが、細かいことはともかく破棄時に自動でfg::free()という破棄関数を呼び出して破棄する。</p>
            <p>この記述だと、名前空間の記述が2度登場していてよくない。</p>
            <p>この例だとfgと短いからいいが、非常に長い名前空間だと記述がごちゃごちゃして分かりにくくなる。</p>
            <p>using namespaceを使用すればそこにまとめられるだろ、という意見もあるだろうが、私としてはあまり頻繁に使いたくない機能だ。</p>
            <p>関数の記述を見た時、一目でどこの名前空間の関数なのか、というのが分かりにくくなってしまう。</p>
            <p>それ以外にも、この記述だとrepaint()とwindowの関連性がいまいち低いように思う。</p>
            <p>fg::Windowの関数であるというのなら、window.repaint()の方が分かりやすい。</p>
            <p>もっと言うなら2行目の、わざわざユニークポインタを参照にする記述も書きたくない。</p>
            <p>よって、大体以下のような記述にしたいのだ。</p>
            <p>＊</p>
            <p>auto window = fg::Window( ... );</p>
            <p>window.repaint();</p>
            <p>＊</p>
            <p>しかし、単純にそうするわけにもいかない。</p>
            <p>コンストラクタやメンバ関数を記述するということは、その型の定義を明確にする必要があるが、それができないのだ。</p>
            <p>なぜなら、fg::Windowのデータ構造は一定ではないからだ。</p>
            <p>環境によって実装を変えるし、またバグの修正や仕様変更の際にfg::Window利用側で再コンパイルの必要がないように、利用側には型の宣言のみ提供し、詳細な定義を提供したくない。</p>
            <p>詳細なデータ構造の記述を避ける場合、その型にはコンストラクタもメンバ関数も記述できなくなる。</p>
            <p>まるでCのような、メンバ関数を一切使用しない構成にしていた理由はそこにあるのだ。</p>
            <p>＊</p>
            <p>fg::Unique&lt;&gt;は私としても知恵を搾り、できるだけ利用側に負担をかけないような構成にしたつもりだ。</p>
            <p>以前なら、生成処理は以下のように書かなければならなかった。</p>
            <p>＊</p>
            <p>auto windowUnique = fg::unique( fg::newWindow( ... ) );</p>
            <p>＊</p>
            <p>現在の記述は、これと処理は全く変えず、よりシンプルにした記述できるようにした形なのだ。</p>
            <p>しかし、それでも不都合が出てきた。</p>
            <p>先ほど挙げた問題以外の問題だ。</p>
            <p>fg::Unique&lt;&gt;という名前はfg内の型に対して提供する型だが、fgを利用するプロジェクトでも同様の機能が使えるように、マクロで手軽にUnique&lt;&gt;を記述できるようにしている。</p>
            <p>kasuteraでもその機能でユニークポインタを使おうとしたのだが、そこで問題が発生した。</p>
            <p>kasuteraでは名前空間を複数に分けていたのだが、ユニークポインタの定義を1つにまとめようとすると不自然な記述になってしまうのだ。</p>
            <p>例えば、以下のような記述をしたとする。</p>
            <p>＊</p>
            <p>auto aObjUnique = kasutera::a::newObj();</p>
            <p>auto bObjUnique = kasutera::b::newObj();</p>
            <p>＊</p>
            <p>どちらも生成関数だが、これらの生成関数が返す型をそれぞれkasutera::Unique&lt; kasutera::a::Obj &gt;、kasutera::Unique&lt; kasutera::b::Obj &gt;にしようとすると、破棄関数は両方ともkasutera::free()になる。</p>
            <p>生成関数はkasutera::a::newObj()なのに、破棄関数はkasutera::free()。</p>
            <p>これはちぐはぐでよくない。</p>
            <p>関数の宣言をする際にも、以下のようになってしまう。</p>
            <p>＊</p>
            <p>namespace kasutera::a {</p>
            <p>struct Obj;</p>
            <p>kasutera::Unique&lt; Obj &gt; newObj();</p>
            <p>}</p>
            <p>namespace kasutera {</p>
            <p>void free( a::Obj &amp; );</p>
            <p>}</p>
            <p>＊</p>
            <p>本来なら、以下のようになるべきだ。</p>
            <p>＊</p>
            <p>namespace kasutera::a {</p>
            <p>struct Obj;</p>
            <p>Unique&lt; Obj &gt; newObj();</p>
            <p>void free( a::Obj &amp; );</p>
            <p>}</p>
            <p>＊</p>
            <p>しかしそのためには、各名前空間ごとにUnique&lt;&gt;を用意する必要がある。</p>
            <p>いくらマクロを使っていて手軽とはいえ、至るところにユニークポインタの定義があるというのは不自然極まりなく、気持ちが悪い。</p>
            <p>以前からもっと改良するべきだと考えていたが、不都合が出てきてしまっては本腰を入れて取り組む必要がある。</p>
            <p>＊</p>
            <p>ここまでの内容から、要件をまとめると以下の通りだ。</p>
            <p>・データへのアクセスはメンバ関数を用いる</p>
            <p>・定義1つでどの型でも利用可能</p>
            <p>また、fg::Unique&lt;&gt;で満たしていた要件は以下の通り。</p>
            <p>・データ構造を隠蔽可能</p>
            <p>・できるだけシンプルに記述できる</p>
            <p>・必要な関数（破棄関数）が存在しない場合、コンパイルエラーで検知できる</p>
            <p>・std::move()やstd::swap()といった標準関数を利用可能</p>
            <p>これら全ての要件を満たす仕組みを構築する必要がある。</p>
            <p>そしてそれは実際形にできた。</p>
            <p>いい加減長すぎるので、それについてはまた次回。</p>
        </div>
        <hr />
        <div>
            <h2>2019/03/09 02:45</h2>
            <p>パソコンを新しくすることにした。</p>
            <p>＊</p>
            <p>能力的には問題ないのだが、大きさとか重さとか、その辺がよくない。</p>
            <p>私のパソコンはパーツを集めて組み立てた、いわゆる自作パソコンだ。</p>
            <p>作った当時はただなんとなくでかいのに憧れがあったので、それを反映したかのようにでかくて重い。</p>
            <p>大きいと自然と空冷ファンも大きいものになり、空冷ファンというのは大体大きいほど静かになりやすいので、静音性はなかなか気に入っている。</p>
            <p>また、拡張性が高く、後々何か追加することもやりやすく、その大きさ故にパーツのサイズによって干渉を起こす、ということも起きにくい。</p>
            <p>しかしながら、大きく重いととりあえず動かしにくい。</p>
            <p>今はゲーム専用に使っている、少し大きめのディスプレイにつなぎたくても現状では難しい。</p>
            <p>ディスプレイが多少離れたところにあるため、パソコンを動かさなければならないからだ。</p>
            <p>大きく重いので、動かすだけでも一苦労。</p>
            <p>他にも掃除が面倒というのがあるが、これは大きさというより使ってるケースが悪いんだろうな。</p>
            <p>＊</p>
            <p>静音性については、あまり気になるようなら回転数を落とすなり静音性を売りにしている物に買い替えるなりで対策できる。</p>
            <p>拡張性なんてのは、大抵の場合何に使うかが明確でない場合に後から対応するためのものであり、使用目的が明確であれば必要性は薄く、デッドスペースにしかならない。</p>
            <p>実際、今のマシンはハードディスク6台搭載できるスペースがあるが全て空だ。</p>
            <p>よって今のマシンのような大きさは必要ないと判断。</p>
            <p>必要な構成をぴったり収めた、移動させやすいパソコンを作ることにした。</p>
            <p>＊</p>
            <p>移動をしやすくするため、マザーボードのサイズは小さいMini-ITX。</p>
            <p>より小さいMini-STXのベアボーンというのもあったが、さすがにUSBポートの数が少なすぎたり音声がオプションだったりと不便そうだったのでパス。</p>
            <p>今のマシンからパーツをいくらか引き継いで安く済ませるのも考えたが、CPUとメモリの規格が1つ古いようだ。</p>
            <p>CPUはAMDのAM3+、メモリはDDR3。</p>
            <p>今の主流はAM4にDDR4で、互換性はないため流用できない。</p>
            <p>さすがにストレージは可能だが、そのくらいだ。</p>
            <p>私はAMDとRadeonが好きなのだが、最近のAMDのGPU搭載CPUに搭載されてるGPUの性能はなかなか馬鹿にできないらしい。</p>
            <p>オンボードと言えばまずゲームには向かない、とりあえず表示ができればいいもの、という印象だったものだが、最近のは新しめの3Dゲームも割と動かせるのだとか。</p>
            <p>というか、今のマシンに積んでいるびみょうな性能のRadeonグラボよりも性能がいいらしい情報もある。</p>
            <p>私はパソコンで最新鋭のゲームなんてやらないし、AMDの比較的安価なCPUでグラボも必要ないとなれば、かなり費用が抑えられる。</p>
            <p>今回購入を決めたのも、実はその辺の理由が大きい。</p>
            <p>グラボを追加しなくて済むなら、ケースのサイズもかなり小さいもので大丈夫だろうし。</p>
            <p>＊</p>
            <p>というわけでCPUにRyzen5 2400Gを用いた構成のパーツを注文し、今日全部届いた。</p>
            <p>費用はおよそ6万円。</p>
            <p>とはいえ、小さいサイズ故にパーツの干渉などが不安なので、絶対に必要でまず干渉も起こさないと思われるものに絞ってある。</p>
            <p>後々光学ドライブとハードディスクを足す予定。</p>
            <p>ハードディスクはケースに3.5インチベイしかないが2.5インチのものを積む予定なので、マウンタなんかも必要になるだろう。</p>
            <p>その辺は実物を見ながら決めていく。</p>
            <p>土日に組み立て、動かせるようにしようと思う。</p>
        </div>
        <hr />
        <div>
            <h2>2019/02/06 03:00</h2>
            <p>もやもやしっぱなしだが、とりあえずReenterEvent対応。</p>
            <p>＊</p>
            <p>明日にはEnterEventを削除し、さっそくReenterEventを使用した処理を作る予定。</p>
        </div>
        <hr />
        <div>
            <h2>2019/02/02 03:00</h2>
            <p>fg::StateEnterEventとfg::StateLeaveEventの仕様を変更することにした。</p>
            <p>＊</p>
            <p>今までこれらのイベントは、fg::Stateをプッシュした時やポップした時に発生していた。</p>
            <p>プッシュ時には、まず元のfg::Stateについてのfg::StateLeaveEventが発生する。</p>
            <p>次にプッシュしたfg::Stateについてのfg::StatePushEvent。</p>
            <p>最後にプッシュしたfg::Stateについてのfg::StateEnterEvent、という順だ。</p>
            <p>ポップ時には元ステートについてのLeaveEvent、PopEvent、ポップ後のステートについてのEnterEvent、という順に発生する。</p>
            <p>＊</p>
            <p>この仕様を変更して、プッシュ時におけるEnterEventと、ポップ時におけるLeaveEventを発生しないようにしようと思う。</p>
            <p>1つのイベントが複数異なる状況で発生することで、扱いにくくなっているように思うのだ。</p>
            <p>現在の仕様では、ポップ時に発生するEnterEventは処理したいけど、プッシュ時に発生するEnterEventは無視する、といったことができない。</p>
            <p>そもそも、プッシュ時のEnterEventや、ポップ時のLeaveEventなんて無くても問題ないのだ。</p>
            <p>プッシュ時はPushEvent、ポップ時はPopEventで代用できる。</p>
            <p>なぜ無駄なものが付いていたのかと言えば、EnterEventとLeaveEventでリソース管理を手軽にしようとしてた、というのが主目的だった気がする。</p>
            <p>EnterEventでリソースの確保、LeaveEventでリソースの解放を行うようにすれば、ステートが有効になるタイミングでリソースが確保され、またステートが無効になるタイミングでリソースが解放される。</p>
            <p>しかし、そのようなやり方は少々安直すぎたように思える。</p>
            <p>そのステートがプッシュされて有効になった、という状況と他のステートがポップされてステートが有効になった、という状況を完全に同一に捉えてしまうのはどうかと思う。</p>
            <p>実装するにしたって、その2つの状況で同じ処理をさせる場合、処理を関数化しておいて各状況から同じ関数を呼び出す、という形にするべきだろう。</p>
            <p>＊</p>
            <p>というわけで、EnterEventはポップ時、LeaveEventはプッシュ時にしか発生しないようにする。</p>
            <p>そのような挙動の都合上、EnterEventについては名前も変えて、ReenterEventにしようと思う。</p>
            <p>＊</p>
            <p>それとは直接関係ないんだけど、ReenterEventで直前のステートを特定できるデータを取得できるようにしようと思う。</p>
            <p>ステートの管理はスタック構造により、あるステートに遷移した後元のステートに戻る、という関数のような、縦のつながりとでも呼べばいいのか、そのような挙動は表現できるようになっている。</p>
            <p>問題は、あるステートから別のステートに遷移する、というGOTOのような挙動の表現だ。</p>
            <p>＊</p>
            <p>現状絶対に表現できない、というわけではない。</p>
            <p>あるステートをポップし、直後に別のステートをプッシュしてやればいい。</p>
            <p>問題はそれをどこでやるのか、ということだ。</p>
            <p>ステート内に、別のステートへの遷移処理を記述してしまうのはまずい。</p>
            <p>ステートの遷移が1回に留まらず、何度も遷移を行なうような構成の場合、あちこちに遷移処理が書かれることになりとても把握できなくなってしまう。</p>
            <p>まさにGOTOの濫用によるスパゲッティコード状態になってしまうことだろう。</p>
            <p>＊</p>
            <p>そこで考えたのは、管理ステートという概念だ。</p>
            <p>管理ステート自体は画面の描画やコントローラの入力などの処理は行なわない。</p>
            <p>管理ステートは、別のステートへの遷移のみを行う。</p>
            <p>管理ステートがプッシュされたら、管理ステートのPushEventでステート1に遷移する。</p>
            <p>ステート1の処理が終了し、ポップされたら管理ステートのReenterEventでステート2に遷移する。</p>
            <p>ステート2が終了したら次はステート3に、といった具合だ。</p>
            <p>この構造なら、遷移処理は管理ステートに集約される。</p>
            <p>で、このような構造を実現する場合、ReenterEventでは直前のステートを特定できないといけないわけだ。</p>
            <p>ステートに対応する列挙型を用意し、それを管理ステートに持たせて現在のステートの把握に使う、という手もあるだろうけどどう考えてもバグの温床になるし。</p>
            <p>他にもっといい方法があればいいのだが、思い付かないものは仕方がない。</p>
        </div>
        <hr />
        <div>
            <h2>2019/01/31 15:10</h2>
            <p>記事を年単位で分割した。</p>
            <p>＊</p>
            <p>編集はvimでやってるけど、開くのに時間かかるのがいやだったので。</p>
            <p>前は月単位で分けてたけど、正直そんな頻繁に分割作業したくないので年単位にした。</p>
            <p>＊</p>
            <p>skiaに対応するために、OpenGLコンテキスト周りを修正した。</p>
            <p>skiaではステンシルバッファが必要だそうだが、現状ではステンシルバッファのサイズが0でサイズ指定もできなかったので、その辺のパラメータを設定できるようにした。</p>
            <p>また、skiaで生成した画像をテクスチャとして扱う、みたいなことをするにはskia用のコンテキストは別に用意した方がよさそうだが、その場合コンテキスト間でリソースを共有できた方がいい。</p>
            <p>なので、コンテキスト間のリソース共有もできるようにした。</p>
            <p>＊</p>
            <p>これでkasuteraの作り直しに入れるかな。</p>
        </div>
        <hr />
        <div>
            <h2>2019/01/26 03:10</h2>
            <p>skiaを使った簡単な描画処理は書けた。</p>
            <p>＊</p>
            <p>最初の生成処理はあれでいいのか不安だが、ヘッダファイルを見ても他の関数は見当たらないし、多分いいのだろう。</p>
            <p>書いてみた感じからすると、fgインターフェースにskia用の関数を追加するとか、そういうものは必要なさそうだ。</p>
            <p>バックエンドにOpenGLを使用する場合の関連付けも、カレントコンテキストに対してのみ行なわれるため、fg::GLContextに対して直接なにかしたり、といった処理は必要ない。</p>
            <p>skiaをモジュールとして扱うために、設定ファイルを追加すれば問題なく扱えそう。</p>
        </div>
        <hr />
        <div>
            <h2>2019/01/25 14:55</h2>
            <p>例の仕様変更については対応済み。</p>
            <p>＊</p>
            <p>テストについても、初期化関数を比較することで目的の画面に遷移していることを確認できるようになった。</p>
            <p>で、kasuteraを作り直そうと思ってるけど、その前にグラフィックライブラリを導入することにした。</p>
            <p>画面に表示する画像を用意するのが面倒なのだ。</p>
            <p>1つや2つで済むならいいけど、これから画面作るたびにその画面を画像を描かないといけない、というのは面倒で気が滅入る。</p>
            <p>なので、フォントファイルを参照して文字を描画したりなどできるライブラリを導入することにした。</p>
            <p>＊</p>
            <p>適当に検索かけて、まず見つけたのはcairo。</p>
            <p>このマシンにも導入されていて、ウィンドウマネージャのawesomeやwebブラウザのfirefox、chromeなどから使われているようだ。</p>
            <p>既に導入されているというのは手が出しやすくていい。</p>
            <p>更に調べていくと、skiaとかいうのも見つけた。</p>
            <p>androidやchromeの描画に使われているらしい。</p>
            <p>chromeはcairoにも依存してるんだけど、使うライブラリを切り替えたりできるんだろうか。</p>
            <p>chromeだけでなくfirefoxでも使われているようだ。</p>
            <p>cairoとはなんだったのか。</p>
            <p>＊</p>
            <p>ともかく2つのライブラリが見つかった。</p>
            <p>skiaの方が高速だの、有名なソフトウェアで使われててフィードバックが多いから開発が進んでるだのとskiaを評価する声が多いように思えるので、とりあえずskiaを使ってみようと思う。</p>
            <p>思ったのはいいのだが、skiaのサンプルコードがあまりネットに落ちてない。</p>
            <p>必死に色々調べた結果、skiaのリポジトリ内に参考になりそうなソースファイルがあった。</p>
            <p>それを見ながら、実際に動作するコードを自分で書いてみるとしよう。</p>
        </div>
        <hr />
        <div>
            <h2>2019/01/21 16:10</h2>
            <p>ちょっと詰まってる。</p>
            <p>＊</p>
            <p>画面遷移についてのテストの記述が直接的でなく、私はとても不満げだ。</p>
            <p>現状、特定の画面に遷移したかどうかのテストは、その画面で行なわれるべき動作が行なわれるか、という反応を見ている。</p>
            <p>その画面に遷移したなら、コントローラをこのように操作することでこういう結果になるはずだ、ということだ。</p>
            <p>はっきり言って回りくどく、非常に分かりづらい。</p>
            <p>テストコードがテスト可能になるまで、必要な記述も多すぎる。</p>
            <p>前述のようにコントローラ操作をテストに含めようとすると、その下準備もテストに記述する必要があるからだ。</p>
            <p>しかも、下準備を書いてなくても動作自体はしてしまう。</p>
            <p>動作するが、テストが成功することはない。</p>
            <p>実装が間違っているのか、テストの記述を間違えているのか見分けがつかず、とても不安になってしまう。</p>
            <p>＊</p>
            <p>これはとてもよくない。</p>
            <p>画面におけるコントローラ操作のテストであれば、下準備をする必要があるのでまだ分かるが、なぜ単なる画面遷移のテストでそれらをしなくてはいけないのか。</p>
            <p>大体、コントローラ操作が行なわれない画面だったら、この方法ではテストできなくなってしまう。</p>
            <p>長々と書いたが、要するにそのfg::Stateがなんの画面のfg::Stateなのか、特定する方法が存在していないのはまずい。</p>
            <p>fg::Stateに、画面を特定するためのデータを持たせる必要がある。</p>
            <p>＊</p>
            <p>テストのためだけに余計な情報を持たせる、ということはしたくないが、テスト以外でも有効に活用できそうな気はする。</p>
            <p>イベント中から画面特定データにアクセスできるようにすれば、1つのイベント関数を複数の画面で使い回し、画面ごとに処理を多少変える、といったことができるようになるだろう。</p>
            <p>そういった処理は複雑化の元だからあんまりやりたくないけど。</p>
            <p>＊</p>
            <p>で、問題は画面特定データとして何を持たせるか、だけど、fg::Stateの初期化関数のアドレスを持たせようかな、と。</p>
            <p>現状扱ってるデータで考えるとそれが妥当、というかそれしかない。</p>
            <p>fg::Stateに文字列で名前を付けるとかIDを振るとかも考えられるけど、扱いきれなくなって後悔する予感しかしない。</p>
            <p>というわけでそんな感じの修正をして、テストも修正しよう。</p>
            <p>＊</p>
            <p>いやむしろ、kasuteraについては作り直した方がいいかもしれない。</p>
            <p>kasuteraは最初テストができず、テストをできるようにするためにbrownsugarを追加し、新たに追加した画面についてはテストができている。</p>
            <p>まだあまり量書いてないし、未テスト部分にもbrownsugarを使ったテストコードを追加しようとしているけど、テストができなかった影響か構成がだめなのだ。</p>
            <p>なんとなくでコードを書いてしまい、処理は一応まともに動いているようだが関数の引数などのインターフェースが悪い。</p>
            <p>簡単に言えば扱いにくい、テストがしにくい。</p>
            <p>それを修正してまともな形にすることもできるだろうけど、いっそ最初からテストファーストでまともなものを作った方がよさそう。</p>
            <p>まだあまり量書いてないわけだし。</p>
        </div>
<!--過去ログ用
        <hr />
        <div>
            <p><a href="/">戻る</a></p>
        </div>
-->
<!-- ここから過去ログ時に削除 -->
        <hr />
        <div>
            <h2>過去ログ</h2>
            <p><a href="2018.html">2018</a></p>
            <p><a href="2017.html">2017</a></p>
            <p><a href="2016.html">2016</a></p>
            <p><a href="2015.html">2015</a></p>
            <p><a href="2014.html">2014</a></p>
            <p><a href="2013.html">2013</a></p>
        </div>
<!-- ここまで -->
    </body>
</html>
