<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>tekuto.net</title>
        <link rel="stylesheet" href="style.css" />
        <script type="text/javascript">
            var _gaq = _gaq || [];
            _gaq.push(['_setAccount', 'UA-23511137-1']);
            _gaq.push(['_setDomainName', '.tekuto.net']);
            _gaq.push(['_trackPageview']);

            (function() {
                var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
            })();
        </script>
    </head>
    <body>
<!--過去ログ用
        <div>
            <p><a href="/">戻る</a></p>
        </div>
-->
<!-- ここから過去ログ時に削除 -->
        <h1>tekuto.net</h1>
        <div>
            <p>メール:g.tekuto@gmail.com</p>
            <p><a href="http://twitter.com/tekuto" target="_blank">twitter</a></p>
        </div>
<!--テンプレート
        <hr />
        <div>
            <h2>YYYY/MM/DD hh:mm</h2>
            内容
        </div>
-->
<!-- ここまで -->
        <hr />
        <div>
            <h2>2016/04/09 00:50</h2>
            <p>困ったな、どっから作り始めたものか。</p>
            <p>＊</p>
            <p>やはりベースシステムメイン関数か？</p>
            <p>データはどういう処理にするのかが決まらんことには構成しようもないし。</p>
            <p>データに対する処理はベースシステムデータ構築時と、ゲームによる初期処理の2つあるが、それは後にするべきだろうな。</p>
            <p>とりあえず表示に関する部分から始めるべきか。</p>
            <p>ウィンドウ生成処理を古いプロジェクトから持ってきて構成するか。</p>
        </div>
        <hr />
        <div>
            <h2>2016/03/31 00:40</h2>
            <p>さくっとできそうだったから、ベースシステムメイン関数についての修正は昨日のうちに終わらせた。</p>
            <p>＊</p>
            <p>で、今日はゲームの初期化処理についての修正をやった。</p>
            <p>とりあえずこれを0.8.0とする予定だけど、テストで使用するモジュールとか、その辺もうちょい整えたいな。</p>
            <p>明日それをやってから0.8.0としてpushし、先に進もう。</p>
        </div>
        <hr />
        <div>
            <h2>2016/03/29 21:25</h2>
            <p>もやもやが多少消えたからか、やる気出てきた気がする。</p>
            <p>＊</p>
            <p>既存のゲームデータ生成、破棄処理をほぼそのまま引っ張ってきて、ベースシステムデータ生成、破棄処理を追加した。</p>
            <p>次はベースシステムメイン関数の引数にベースシステムデータを参照を追加し、利用できるように修正しよう。</p>
            <p>現状ではmain()でcandymaker::Basesystem内のベースシステムメイン関数を直接呼び出しているが、ベースシステム実行関数を別に作った方がいい気がする。</p>
            <p>main()でベースシステムデータを直接参照するのはレイヤーが違うと思うし。</p>
            <p>それが終わったらゲームの初期処理についてか。</p>
            <p>こっちは、今の構成は破棄して新しい構成にするわけだから、まずは別のソースファイルに作った方がいいだろうな。</p>
        </div>
        <hr />
        <div>
            <h2>2016/03/29 00:50</h2>
            <p>さすがにモジュールの扱いを段階分けするのは完了している。</p>
            <p>＊</p>
            <p>しかしモジュールの依存情報の解釈についてはまだ。</p>
            <p>というより、色々考えてたらこれもう後回しでいい感じがしているので放置。</p>
            <p>ゲーム生成処理をベースシステム関数内でやるとかいうのもありえんのでやらない。</p>
            <p>それしたところで、大した違いもないだろう。</p>
            <p>＊</p>
            <p>最近は、ゲームとベースシステムの構成が間違っているのではないかと考えている。</p>
            <p>ゲームはベースシステムにアクセスする必要があるが、そのうまい方法を思いつかない、というのが現時点での大きな問題点だ。</p>
            <p>色々考えた結果、ベースシステムがメイン関数のみの構成なのがいけないのだ。</p>
            <p>ベースシステムは処理だけでなくデータも持つべきだ。</p>
            <p>逆に、ゲームの方は初期処理だけでいい。</p>
            <p>ゲームにデータなど必要ない。</p>
            <p>そのように変更する場合、処理の大まかな流れは以下のようになる。</p>
            <p>＊</p>
            <p>1.ベースシステムデータ生成</p>
            <p>2.ゲームの初期処理</p>
            <p>3.ベースシステム実行</p>
            <p>4.ベースシステムデータ破棄</p>
            <p>＊</p>
            <p>2は引数としてベースシステムデータの参照を受け取り、それに対して処理を行なう。</p>
            <p>3はゲームが動作している段階で、4はゲーム終了後の後処理となる。</p>
            <p>＊</p>
            <p>さて、どのように作業を進めたものか。</p>
            <p>まずはベースシステムデータの生成、破棄を進めるべきか。</p>
            <p>これ自体はただの処理追加なので、楽にできるだろう。</p>
            <p>むしろそれを先にやっておかないと、他の変更はベースシステムデータの存在が前提なので作業を進めにくくなりそう。</p>
            <p>ベースシステム関数の引数にベースシステムデータの参照を追加するのもそうだし、ゲームの初期処理についてもベースシステムデータの参照を引数として渡す。</p>
            <p>それらが完了したら、ゲームからベースシステムにアクセスできるようになるわけだし、いい加減ゲームやベースシステムの方の作成に移ろう。</p>
            <p>candymakerをいじくるのはうんざりしてきているのだ。</p>
            <p>モチベーションが一向に上がらない原因はそこだと考えている。</p>
        </div>
        <hr />
        <div>
            <h2>2016/02/06 00:10</h2>
            <p>書こうとして、またも違和感。</p>
            <p>＊</p>
            <p>設定ファイルに関係する処理が置かれているディレクトリの方にソースを配置すると言ったが、それもおかしい。</p>
            <p>設定ファイルの解析処理に関係する処理なんて書かんのだから、そんなところに配置するのは不自然だ。</p>
            <p>設定ファイルについては、解析結果を参照するだけだ。</p>
            <p>ならば設定ファイルのソースが配置されているディレクトリと同列辺りに配置するのが筋だろう。</p>
            <p>昨日は違うか、と言っていた方が正しいような気がしている。</p>
            <p>やはり頭が茹で上がるとまともな思考にならん感じある。</p>
            <p>多少時間がかかっても、深く考えを巡らせるべきだろうか。</p>
            <p>そんな考えを認めてしまうと、考えるだけで無駄に時間が過ぎる気がするから、認めたくはないのだが。</p>
            <p>＊</p>
            <p>ふと思いついて、linuxのインストールCDに含まれているメモリチェックツールを使ったところ、やはりメモリがもうだめな雰囲気だった。</p>
            <p>gccがSEGVで死ぬのはおそらくそれが原因だろう。</p>
            <p>むしろ、それ以外ではほぼ問題が起こっていない理由が分からない。</p>
            <p>並列コンパイルとか高負荷の処理を流さん限り使わないような箇所がおかしくなっているのだろうか。</p>
            <p>ともあれ、運が悪いとemergeがこけるというのがいい加減嫌になってきたし、原因がメモリであろうことも特定できたので、交換することにした。</p>
            <p>今使ってるのは、安いからという理由だけでよく知らんメーカーのメモリを使っていたので、今回はトランセンドにする。</p>
            <p>これまた比較的安い気がする、というのも決めた理由の一つだけど。</p>
        </div>
        <hr />
        <div>
            <h2>2016/02/04 23:50</h2>
            <p>どうにもうまくまとまらんと思ったら、モジュールの扱いが低レイヤーすぎるのがいけないんだろうな。</p>
            <p>＊</p>
            <p>パッケージ情報ファイルに依存情報の追加はしたのだが、それをどう扱ったものか考えていた。</p>
            <p>現在、モジュールのロードについては、モジュールのパスを引数にして行なっている。</p>
            <p>依存情報を扱うなら、例えば依存情報も引数として渡し、そっちのロードを先にやる、という形になるだろうが、現状だとそれはまず無理だ。</p>
            <p>モジュールのパスというのはつまり、設定ファイルの内容を解釈した後のものだ。</p>
            <p>モジュールのロード処理中では、設定ファイルを解釈するような処理を行なっていない。</p>
            <p>依存情報というのは設定ファイルレベルの情報なので、そんなものを渡したところで扱いようがないのだ。</p>
            <p>ならばモジュールのパスではなく、設定ファイルレベルのモジュール名やら設定ファイルの内容やらを渡せばいいかもしれないが、それはしたくない。</p>
            <p>少なくとも、最終的には現在存在するモジュールのロード処理とかは必要になるのだ。</p>
            <p>それをわざわざ壊して複雑化させるなど間違っている。</p>
            <p>＊</p>
            <p>というわけで、モジュールの扱いについて、現在作ってある処理を利用する、より設定ファイル寄りの処理を追加するべきなのだろう、という結論に達した。</p>
            <p>結論に達するのが遅い気がする。やはりやる気が足りてない気がする。</p>
            <p>間に土日を挟んだり、健康診断で血を抜かれたりしたからといって、もうちょい早くその結論を出せたはずだ。</p>
            <p>それはともかく。ソースを見直したところ、現在あるモジュールを扱う処理だが、これはモジュールと言うよりローダーと言った方が正しい気がする。</p>
            <p>この辺は将来的にモジュール化して、様々な形式のモジュールを扱えるようにしたい箇所だし。</p>
            <p>だから名前を変えて、これから作る処理を新たなモジュールを扱う処理に…と思ったが、それもちょっと違うか。</p>
            <p>これから作るのは、設定ファイルの内容を解釈したりといった処理が入るから、そこに置くべきではないな。</p>
            <p>置くなら設定ファイルに関係する処理が置かれているディレクトリの方だ。</p>
            <p>危ない危ない。全く、先が思いやられる。</p>
        </div>
        <hr />
        <div>
            <h2>2016/01/28 17:05</h2>
            <p>やはり想定が甘い。</p>
            <p>＊</p>
            <p>モジュールの扱いのライブラリ化についてやるなら、暫定的、の部分をもっと細かく考えないと進められないな。</p>
            <p>依存関係解決についても、きちんとやるならパッケージ設定ファイルとか必要になるし。</p>
            <p>こちらも機能を限定した、暫定的なものから作っていくべきだろうな。</p>
            <p>やはり依存関係解決から作っていこう。</p>
            <p>パッケージ情報ファイルに依存情報を追加し、同一パッケージ内のみ対応、といった感じか？</p>
        </div>
        <hr />
        <div>
            <h2>2016/01/27 15:43</h2>
            <p>ベースシステムのメイン取得→ゲーム生成→ベースシステム実行という流れが違う気がしてきた。</p>
            <p>＊</p>
            <p>ゲーム生成関数の引数に、ベースシステムで使用するデータを渡すということは、そのデータを生成する必要があるけど、そのデータ生成どうすんの、という話だ。</p>
            <p>そこで考えたことには、ゲームの生成はベースシステムを実行してから、その中でやるべきか、ということ。</p>
            <p>これなら、ゲーム生成関数に渡すデータはベースシステム関数内で生成できる。</p>
            <p>しかし、ゲーム生成・破棄関数の取得までは定型処理だし、ベースシステム関数内でやるべきではないだろう。</p>
            <p>でも、それで本当にいけるか？ゲーム生成関数のシンボル名はベースシステムに依存するわけだし、関数の取得もベースシステム関数内でないとできないのでは？</p>
            <p>となると、モジュールのロードをしてからモジュールの参照をベースシステム関数に渡す？</p>
            <p>ということは、モジュールの型や関係する関数はライブラリ化する必要がありそうだなぁ。</p>
            <p>ライブラリ化については後回しにしたいところだが、それでできるだろうか？</p>
            <p>そもそも現時点での実装では、モジュールの依存関係解決などやっていないのだ。</p>
            <p>ライブラリだけ作ってもどうしようもない。</p>
            <p>＊</p>
            <p>色々と問題点が浮かび上がってきたな。とりあえずまとめてみよう。</p>
            <p>a.ゲーム生成処理の呼び出しをベースシステム関数内に移動</p>
            <p>b.モジュールの扱いをライブラリ化</p>
            <p>c.モジュールの依存関係解決</p>
            <p>こんな感じ？</p>
            <p>aを実現したいが、そのためにはbとcが必須。</p>
            <p>bは実現したところでcがないと活用できない。</p>
            <p>cは前提条件なし。</p>
            <p>bかcから始めよう。</p>
            <p>bはとりあえず暫定的なものでいいだろう。想定ではかなり簡単にできるはずだ。</p>
            <p>問題はcか。前のプロジェクトで似たような処理は作ったはずだから、それを活用できれば早いか？</p>
            <p>＊</p>
            <p>とりあえず現在の状態を0.6.0としてしまおう。</p>
        </div>
        <hr />
        <div>
            <h2>2016/01/26 01:25</h2>
            <p>ゲームの生成まではできた。</p>
            <p>＊</p>
            <p>しかし、このままでは生成ができるだけで、ベースシステムとはなんの通信もできない。</p>
            <p>どうするかなぁ。通信インターフェースを作るのまで含めるか、それともこの辺で、ソースを整えて0.6.0とするか。</p>
            <p>ソースを整えるのはやるとしよう。</p>
            <p>＊</p>
            <p>ベースシステムとゲームの通信はどうしよう。</p>
            <p>ベースシステムのメイン取得→ゲーム生成→ベースシステム実行としているが、ベースシステム実行時に生成したゲームを引数として渡すか？</p>
            <p>今の構想ではそれは向かないように思える。</p>
            <p>ベースシステムからゲームに対してアクションをかけるということは、ゲーム側に決まった関数でも定義しておかなければ難しいだろう。</p>
            <p>そして、ゲームにはできれば決まった関数というのは用意したくない。</p>
            <p>ゲーム側の必須関数は生成と破棄だけにしたいのだ。</p>
            <p>ゲーム側の生成関数の引数に、ベースシステムで使用するデータを渡し、そこにイベントハンドラを設定していく、という形になるだろうか。</p>
            <p>この形なら、決まった関数はベースシステム側に作られ、それを介してベースシステム側からゲーム側を操作できるようになるはずだ。</p>
        </div>
        <hr />
        <div>
            <h2>2016/01/19 00:50</h2>
            <p>お腹きゅうきゅうする。</p>
            <p>＊</p>
            <p>raspberrypiはそろそろもういいかなという感じ。</p>
            <p>というよりやりすぎた感じ。</p>
            <p>やりすぎちゃって、軽く燃え尽きちゃってる感じある。</p>
            <p>このままではいかんと思い、candymakerのソース眺めたりなどしていた。</p>
            <p>戻らねば。</p>
            <p>＊</p>
            <p>やりすぎたかいもあり、なかなかのものができた、と思うんだけど、最新の修正を適用したものの動作確認がまだ。</p>
            <p>1人では動作確認できないのが厳しいところだ。</p>
            <p>理論的にやってできないことはないはずなのだが、なぜかうまくいかなくて困る。</p>
        </div>
        <hr />
        <div>
            <h2>2015/12/19 04:15</h2>
            <p>最近はraspberrypiをいじくりまくってた。</p>
            <p>＊</p>
            <p>そのかいあって、常にxlink kaiを動かすraspberrypiがほぼできた。</p>
            <p>私の作ったプログラムにより、raspberrypi側の無線LANアダプタを自分で操作しなくても、MACアドレスに対応したPSPのネットワークに自動接続できる。</p>
            <p>また、起動時にメモリ上にSquashFSのrootfsを配置する形にした。</p>
            <p>これにより、起動後はSDカードを取り外しても動作し続けることができる。</p>
            <p>raspberrypiにSDカードは完全には差さらず、出っ張るためうっかり触って抜けてしまったり、カードやスロットなどが破損したりということが起きかねない。</p>
            <p>それに、マウントした状態で取り外したり、電源コードを抜いたりすると、ファイルシステムが破損する可能性だってある。</p>
            <p>実際、それでSDカードのファイルシステムの再構築が必要になったことが何度かある。</p>
            <p>そもそもraspberrypiに電源スイッチなどないし、普通に終了するためには何らかの方法でログインし、shutdownコマンドを叩かなければならない。</p>
            <p>それが電源コードを抜いて電源を落としても多分大丈夫になった、というのは大きい。</p>
            <p>＊</p>
            <p>私の作ったプログラムはもう少し修正する必要がある。</p>
            <p>周囲のアドホックネットワークの検索処理を実行する間隔が短すぎて、他の通信に悪影響が出てしまっている。</p>
            <p>しかし、どうスリープしたものか。固定時間か、一定間隔毎に処理するように計算してスリープするか。</p>
        </div>
        <hr />
        <div>
            <h2>2015/11/29 00:20</h2>
            <p>昨日、いつにも増してやる気が出ん、だるいと思ったら微熱が出ていた。</p>
            <p>＊</p>
            <p>それでも、なんとかパッケージ情報に記述したゲームについての情報を取り出す処理は追加できた。</p>
            <p>月曜には、ゲームのロード処理をメイン関数に追加したいところ。</p>
            <p>明日はraspberrypiをいじくるとしよう。</p>
        </div>
        <hr />
        <div>
            <h2>2015/11/27 00:27</h2>
            <p>ショートカットファイルからゲームの参照情報を取り出すのはできた。</p>
            <p>＊</p>
            <p>まぁ、記述内容がベースシステムの参照情報とほぼ同じだから、処理をコピーして少し修正して作ったんだけど。</p>
            <p>次はパッケージ情報にゲームについての情報を追加して、それを取り出す処理かな。</p>
            <p>こっちも、ベースシステムの情報と大体似たような感じだから、処理をコピー、修正して作れば楽だろうな。</p>
            <p>その取り出した情報を使ってゲームをロードし、ベースシステムの実行時に引数として渡す、というところまで明日中にできればいいんだが。</p>
        </div>
        <hr />
        <div>
            <h2>2015/11/25 19:51</h2>
            <p>というわけで、0.5.0できた。</p>
            <p>＊</p>
            <p>ベースシステムの起動までできたところで0.5.0とした。</p>
            <p>この次はゲームの生成、破棄とゲームの制御となるわけだが、どうするかちょっと考え中。</p>
            <p>昨日の日記書いてた時には、ゲームの生成や破棄はベースシステム内でやろうかと考えたりしていたのだが、それはあまり望ましくない気がする。</p>
            <p>ゲームの生成や破棄は、色々な実装方法が思い付くような処理ではない。</p>
            <p>簡単に言えば、newとdeleteなわけだ。</p>
            <p>ならば、わざわざベースシステム側にそれを任せることもない気がする。</p>
            <p>そうすれば、ベースシステム側が設定ファイルを解析したり、モジュールをロードしたりする必要はなくなる。</p>
            <p>＊</p>
            <p>どちらにせよ、まずはショートカットファイルからゲームについての情報を取り出す処理を追加するところからだろうか。</p>
            <p>どこに記述したところで、その処理自体は変わらないだろうし。</p>
        </div>
        <hr />
        <div>
            <h2>2015/11/25 02:30</h2>
            <p>モジュールのロード、ロードしたモジュールからの関数取得も完了。</p>
            <p>＊</p>
            <p>これを使ってベースシステムの起動をするわけだが、それにはダミーのベースシステムを作る方が先か。</p>
            <p>中身空っぽでいいから、これはさっとできるだろうな。</p>
            <p>次はどうするべきかな。</p>
            <p>ベースシステムの実行の次、となるとゲームの起動だろうか。</p>
            <p>それをするとなると、ベースシステムから設定ファイルを読んだりモジュールをロードしたりする必要があるだろうから、ライブラリを作る必要がありそうだなぁ。</p>
            <p>＊</p>
            <p>3連休中、raspberrypiをいじくっていた。</p>
            <p>とりあえずの成果として、比較的簡単にraspberrypi用のgentooのrootfsを生成できるようになった。</p>
            <p>私は出来合いのカーネルとか使いたくないので、というよりカーネルの機能を増やしたい時とかに備えてカーネルは時前でビルドしたいので、その辺は自分でやる必要があるけど。</p>
            <p>で、raspberrypi版のxlink kaiとかあったんで、xlink kaiを使うためだけのraspberrypiを作れないか画策中。</p>
            <p>xlink kaiは昔windows版を使っていたことがあったが、PSPとパソコンをアドホックで接続するために、わざわざパソコン側で操作が必要になるのが面倒だった。</p>
            <p>なので、その辺の操作を自動化してみたい。</p>
            <p>しかし、アドホック接続についての情報がうまく見つからない。</p>
            <p>特定のPSPを示す識別子みたいのってないのかな。</p>
        </div>
        <hr />
        <div>
            <h2>2015/11/17 00:15</h2>
            <p>とりあえずテストプログラムのビルドルールを分離させた、のだけど。</p>
            <p>＊</p>
            <p>今のままでは、configure時にテストプログラムについてもビルドするよって指定しないとビルドしてくれない。</p>
            <p>確か前は、そういう風になってしまうのを嫌ってテストプログラムのビルド処理を分けなかったんだった気がする。</p>
            <p>実際面倒だし、テストプログラムが増えるたびにconfigureコマンドのオプション指定が増えることになる。さすがに嫌だ。</p>
            <p>＊</p>
            <p>依存関係を定義できるようにするべきかもしれない。</p>
            <p>このプログラムをビルドする場合、他のプログラムもビルドする、みたいな指定。</p>
            <p>そういう仕組みを作れば、あるプログラムに関連するテストプログラムの自動的なビルドも可能になる。</p>
        </div>
        <hr />
        <div>
            <h2>2015/11/14 00:18</h2>
            <p>いかんいかん。典型的な三日坊主じゃないか。</p>
            <p>＊</p>
            <p>微妙に詰まっている。</p>
            <p>モジュールロード機能のテストコードを作ったので、そのテストを通そうとしたところで困った。</p>
            <p>テストでモジュールをロードする必要があるので、そのためのダミーモジュールを作る、それはいい。</p>
            <p>しかし、現状ではテストコードにライブラリやらなんやらを関連付けることができない。</p>
            <p>なので、どう変えるべきか考え中。</p>
            <p>よく考えたら、テストプログラムの在り方がおかしい気がする。</p>
            <p>なんらかのプログラムに付随するものとしてるから、テストに対して他の何かを関連付けられないのだ。</p>
            <p>最初からテストプログラムも独立したプログラムとして扱えば、こんなことにはならないはずだ。</p>
            <p>不要にビルド処理を複雑にしてしまっている雰囲気がする。</p>
            <p>改善しなければ。</p>
        </div>
        <hr />
        <div>
            <h2>2015/11/11 00:17</h2>
            <p>0.4.0できた。</p>
            <p>＊</p>
            <p>パッケージ情報ファイルとショートカットファイルの内容から、取得できる範囲の情報を取得、表示するところまでやって0.4.0とした。</p>
            <p>取得した情報を使えばベースシステムの起動までできるはずだが、そのためには起動するベースシステムも中身からっぽでいいから作らないといかん。</p>
            <p>ベースシステムの起動まで作ったら、次はどうしようか。</p>
            <p>ベースシステムの中身を詰めていくべきかな。</p>
            <p>パッケージ設定ファイルの処理とかもないわけではないけど、これ以上同じような作業はきついものがある。</p>
            <p>それに前にも書いた通り、パッケージ設定ファイルは今のところ無くても問題ないのだ。</p>
            <p>これ以上モチベーションを落としたくないし。</p>
        </div>
        <hr />
        <div>
            <h2>2015/11/10 02:03</h2>
            <p>やはりそう簡単にはやる気は戻らんらしい。</p>
            <p>＊</p>
            <p>リファクタリングしたり、パッケージ情報ファイルを解析したデータからデータを取得する関数を追加したりしてたら、今日中に0.4.0を作りきれなかった。</p>
            <p>でもまぁ、パッケージ情報ファイルから名前に対応したベースシステム情報を取得する関数の処理を実装したら、あとはメインの処理を追加して、デバッグ出力を追加すれば完成だろうか。</p>
            <p>道筋は見えているので、起きたらさくさくっと完成させたい。</p>
        </div>
        <hr />
        <div>
            <h2>2015/11/09 00:38</h2>
            <p>前回から1ヶ月程度か。結構さぼってしまった。</p>
            <p>＊</p>
            <p>作業はしてたんだけど、やはり牛歩。</p>
            <p>やる気が出なかったのは、退屈な作業というか、前のバージョンで追加したのと同じような作業をやることになったからだろうな。</p>
            <p>前はショートカットファイルの解析で、今回はパッケージ情報ファイルの解析。</p>
            <p>必要なことではあるのだが、なんとも退屈な作業だった。</p>
            <p>＊</p>
            <p>パッケージ情報ファイルの解析処理はなんとかできたので、それを使って得られた情報を出力して、それを0.4.0とすることにしよう。</p>
            <p>明日にはパパッと作ってしまって、さっさと次に進みたいところ。</p>
            <p>ベースシステムの情報は取得できるようになったわけだし、次はいよいよベースシステムの起動に入れるか。</p>
        </div>
        <hr />
        <div>
            <h2>2015/10/03 00:00</h2>
            <p>機能を実装したと仮定した処理を記述していっているのだが、つまずいている。</p>
            <p>＊</p>
            <p>パッケージ情報ファイルを読み込む、これはいい。</p>
            <p>読み込んだパッケージ情報ファイルからベースシステムの情報を取り出す、これもいい。</p>
            <p>この次がしっくりこない。</p>
            <p>手順としては、まずモジュールをロードするんだろうけど。</p>
            <p>モジュールをロードして、ロードしたモジュールからベースシステムの関数を取り出し、取り出した関数を実行する。</p>
            <p>急に処理のレイヤーが低くなるから違和感を覚えるのかしら。</p>
            <p>＊</p>
            <p>ベースシステムの情報を取り出すのではなく、パッケージ情報ファイルの内容とベースシステム名を引数にベースシステムを実行する、の方がいいのかなぁ。</p>
            <p>だったら、パッケージのパスとベースシステム名を引数にベースシステムを実行する、の方がよりいいかもしれない。</p>
            <p>後のことを考慮すればもっとまとまるだろうか？</p>
            <p>パッケージ設定ファイルを読むようにした場合だ。</p>
            <p>パッケージ設定ファイルを読み、使用するパッケージのパッケージ情報ファイルを読み、使用するモジュールを列挙、ロードし、ベースシステムを含むモジュールからベースシステムの関数を取り出し、実行。</p>
            <p>関数をどう、とかなると低レイヤーすぎるから、ベースシステムの実行として1つの処理にまとめるべきだろうな。</p>
            <p>可変長の引数を取り、それを共有ライブラリから取り出した関数ポインタの引数に渡して呼び出す、みたいなことできればいいんだけどそんな簡単にできるだろうか。</p>
        </div>
        <hr />
        <div>
            <h2>2015/10/01 18:40</h2>
            <p>0.3.0できた。</p>
            <p>＊</p>
            <p>設定ファイル要素の集合体からショートカットファイルを表す構造体を生成する処理を追加した。</p>
            <p>こういう構成の設定ファイルがショートカットファイル、というのを定めたことになる。</p>
            <p>とはいえ、ベースシステム実行に必要な要素だけが記述された、暫定的なものだけど。</p>
            <p>具体的には、ベースシステムが含まれるパッケージのパスと、ベースシステム名、この2つ。</p>
            <p>この2つの情報が記載されたファイルをショートカットファイルとする。</p>
            <p>＊</p>
            <p>次は、その2つの情報を使い、ベースシステムを実行する処理を作ろう。</p>
            <p>それを0.4.0とする。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/26 00:55</h2>
            <p>昨日、方針を固めたのはいいのだが。</p>
            <p>＊</p>
            <p>実際に作業を進めようとしたものの、なんだかやりにくい。</p>
            <p>どうにも、処理が不完全な感じがある。</p>
            <p>ショートカットファイルの読み込み、解析を行なっているものの、最終的に生成しているのがショートカットファイルを表す構造体でないのが分かりにくい原因か。</p>
            <p>現状、設定ファイル要素の集合体としてしか扱っていない。</p>
            <p>データを取り出すにも、例えばマップにキーに対応するデータが存在するか、とかから始めないといけない。</p>
            <p>ショートカットファイルとして正しいのかどうかのチェックを行なっていないから、そのようなめんどうなことになるのだ。</p>
            <p>設定ファイルとして文法が正しいか、の次にショートカットファイルとして正しい構成になっているか、のチェックが必要だ。</p>
            <p>そうすれば、データを取り出す際にいちいちデータの存在チェックとかやらんで済む。</p>
            <p>＊</p>
            <p>どうしよう、それを0.3.0として作るか？</p>
            <p>機能として完全に分離させた方がよさそうだし、そうするかなぁ。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/24 23:55</h2>
            <p>考えて考えて、ようやく方針が固まった。</p>
            <p>＊</p>
            <p>次は、ベースシステムを実行する処理を作る。</p>
            <p>ベースシステムとゲームの構成についても変更する。</p>
            <p>前のプロジェクトでは、ベースシステムは生成・破棄するもの、ゲームは実行するものという扱いだったが、これは逆にする。</p>
            <p>ベースシステムは実行するもの、ゲームは生成・破棄するもの。</p>
            <p>ゲームは完全に動作を制御したいのだ。</p>
            <p>だから実行する、つまり制御を完全に移す形にするのは適切ではない。</p>
            <p>ベースシステムは制御できる形にしたところで、じゃあそれを誰が制御するんだよって話になる。</p>
            <p>起動プログラム？そんなめんどうなことはさせたくない。</p>
            <p>よって制御を完全に移す形にする。</p>
            <p>＊</p>
            <p>というわけでベースシステムのライブラリをロード、関数を取り出し呼び出す、ということをすることになるが、まずはできるだけ規模を小さくする。</p>
            <p>ライブラリを扱うということはパッケージを扱うことになるのだが、本来想定している処理の流れは以下の通りだ。</p>
            <p>・パッケージ設定ファイルを読み込み、利用するパッケージ、モジュールを特定</p>
            <p>・利用するパッケージのパッケージ情報ファイルを読み込み、ベースシステム実行関数が含まれるモジュールや、モジュールの実体（ファイル名）などを把握</p>
            <p>・利用するモジュールを全てロード、ベースシステム実行関数が含まれるモジュールから関数を取り出し呼び出す</p>
            <p>こんな感じだが、まずは最初のパッケージ設定ファイルの読み込みを行なわないことにする。</p>
            <p>単にモジュールを読み込んで関数を取り出し呼び出すだけなら、パッケージ情報ファイルを読めばできるのだ。</p>
            <p>パッケージ設定ファイルは、モジュールの利用する・しないの判断や、依存パッケージの指定、パッケージとセーブデータの関連付け、パッケージやモジュールへのパラメータの設定などなど、より高度なことを行うために必要となるが、最低限の動作では必要ない。</p>
            <p>よって、0.3.0ではパッケージ情報ファイルを読み込み、ベースシステムを実行するところまで作る。</p>
            <p>＊</p>
            <p>パッケージ設定ファイルを使う前提で考えていたから、どう進めるべきか決まらなかった感じがある。</p>
            <p>もし無理矢理その方向で進めていたら、またしても泥沼の展開だっただろうな。</p>
            <p>こんなに長く考えたのだから、それを避けられればいいのだが。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/24 12:40</h2>
            <p>連休を利用して、マシンの環境を構築し直していた。</p>
            <p>＊</p>
            <p>今までは、64bitと32bitの環境を完全に分けて構築していた。</p>
            <p>64bit環境で32bitプログラムを動かすために、エミュレーションライブラリを使う必要があるのを嫌ったためだ。</p>
            <p>しかしながら、今年の3月頃だったか、エミュレーションライブラリの使用は非推奨になった。</p>
            <p>64bit環境で32bitプログラムを動かすために必要となるライブラリも、ソースからビルドできるようになったからだ。</p>
            <p>わざわざ環境を作り直すのはめんどうなのでやってこなかったが、2つの環境を扱うのも色々めんどうがある。</p>
            <p>例えばパッケージの更新は2環境にそれぞれ実行しなければならないし、設定ファイルなんかも2箇所に置くことになるし、そもそも2環境作ると容量結構取るし。</p>
            <p>そんなわけで環境を作り直した。</p>
            <p>＊</p>
            <p>今のところ、問題なく動いているようだ。</p>
            <p>skypeなんかは、前は32bit環境で動かしていたため、32bit環境に移行→skype起動、などとするスクリプトとか用意してたんだけど、そんな必要もなくなった。</p>
            <p>32bit環境に移行する必要がなくなったからか、前より起動が速くなった気がする。</p>
            <p>＊</p>
            <p>後は、raidをマシンの外に出したいけれど、これをやるとなるとまためんどうそうだなぁ。</p>
            <p>封印してある玄箱T4を使おうと思っているが、これを普通に使おうとすると、4つ入るハードディスクのうち、どれか1つの中に環境を構築しないといけないとかいう残念なやつだし。</p>
            <p>それを避けるには、外部に環境を作りNFSでマウントして使う、とかしないといけないんだけど、これまためんどい。</p>
            <p>ちょうど使ってないraspberrypiもあることだし、それを使おうと考えているが、結局そっちの環境構築も必要になるわけだし。</p>
            <p>やるなら次の土日だろうけど、土日で完了できるだろうか。</p>
            <p>いや、まず無理だな。できてraspberrypiの環境構築くらいなものだろう。</p>
            <p>＊</p>
            <p>ちなみに環境というのはどれもGentooだ。Gentoo Linux。</p>
            <p>柔軟で扱いやすくていい。</p>
            <p>しかし、パッケージをソースからビルドする形なので時間がかかりがちなのが難点。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/16 23:50</h2>
            <p>昨日のうちに、0.2.0は完成した。</p>
            <p>＊</p>
            <p>のだが、次はどうするべきか決めかねている。</p>
            <p>ベースシステム情報が得られているのだから、ベースシステムの構築・起動をするべきだろうか。</p>
            <p>しかし、ベースシステムとゲームをどう連携させるかまだ決まってないしなぁ。</p>
            <p>最低限決まっているのはベースシステムを起動した後にゲームを起動させるという順番くらいなものだろうか。</p>
            <p>とりあえずをそれをやってしまうべきか？</p>
            <p>中身はほぼ空でも。</p>
            <p>＊</p>
            <p>しかし、それはまた行き当たりばったりな感じがするし。</p>
            <p>もうちょい考えをまとめるべきだろうなぁ。</p>
            <p>ゲームはどこでロードするのか？</p>
            <p>今作っている起動プログラムか？もしくはベースシステム内の処理か？</p>
            <p>前者の場合、ゲームをロードする必要がある時には起動プログラム側に制御を戻さなければならなくて、なんだか奇妙だ。</p>
            <p>後者の場合、起動プログラムからベースシステムをロードして動かし、ベースシステムからゲームをロードして動かす、という流れになって、見た目きれいな感じがする。</p>
            <p>しかしながら、ゲームのロードには設定ファイルの読み込みが必要になるものの、そもそもベースシステムからして設定ファイルの読み込みを行なった上でロードするのだ。</p>
            <p>設定ファイルの読み込み処理は、普通に考えたら起動プログラム部分に配置することになる。</p>
            <p>それをどうやってベースシステムから呼び出すのか？</p>
            <p>案はないわけではないが。</p>
            <p>モジュールの設定という概念を追加して対応する、というのが今考えている案。</p>
            <p>それにより起動プログラム内の関数名を指定し、モジュールロード時に関数を取得、という感じだ。</p>
            <p>そんな関数が用意されているかは謎だ。</p>
            <p>＊</p>
            <p>うーん、設定ファイル形式の解析処理はできているわけだから、解析を行なった次の段階、設定ファイルを読み込みデータを取得するための関数を実装すべきだろうか。</p>
            <p>だとして、その目的はどうするべきか？</p>
            <p>これまでは、それぞれファイルの内容を出力するためにファイル読み込み処理を追加したし、読み込んだファイルから意味あるデータを取得するために解析処理を追加した。</p>
            <p>目的を持たない機能追加はその実用性に疑問が残る。</p>
            <p>次にやる事を考えれば、ベースシステムの構築なわけで、つまりモジュールのロードや、ロードしたモジュールからの関数取得か。</p>
            <p>それらの処理を行なうための入力データとして、ファイルから読み込んだデータを構造体にまとめる、という感じになるか。</p>
            <p>＊</p>
            <p>ということで、目的はベースシステムの構築、もといベースシステムの生成・破棄関数の呼び出しか。</p>
            <p>それに付随して、モジュールのロードや、設定ファイルの形式を定めていったりする必要がある。</p>
            <p>まずは、すごい簡単なベースシステム生成・破棄関数を持ったライブラリを作るところから始めるべきか？</p>
            <p>その辺ができてこないと、設定ファイルにどう記述していいか分からないしなぁ。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/15 01:55</h2>
            <p>ちょっと不調。データ取得関数を一通り追加したところまで。</p>
            <p>＊</p>
            <p>多分、これで設定ファイルに関する関数は一通りできたはず。</p>
            <p>あとはこれらを使ってメイン処理を組み立てる。</p>
            <p>明日には0.2.0を仕上げたい。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/11 18:40</h2>
            <p>マップ要素まで完了した。</p>
            <p>＊</p>
            <p>後は、解析したデータからのデータ取得関数とか追加しながらメイン処理を組み立てて、0.2.0の完成といったところか。</p>
            <p>次はどうするべきか。</p>
            <p>設定ファイルからベースシステムについての情報とゲームについての情報を得られるわけだから、ベースシステムの生成だろうか。</p>
            <p>ベースシステムはどこで作ろうか。</p>
            <p>暫定的なものはcandymakerで作ってしまおうか。</p>
            <p>それが、とりあえずはコンパクトでいい気もする。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/11 02:05</h2>
            <p>リスト要素はできたが、マップ要素はまだ。</p>
            <p>＊</p>
            <p>来週には持ち越したくないなぁ。</p>
            <p>明日中にマップ要素を完成させて、来週からは作った処理を使って読み込んだショートカットファイルの内容を解析したいところ。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/09 23:40</h2>
            <p>リスト要素の解析は完成には至らなかった。</p>
            <p>＊</p>
            <p>しかしもう少しだ。</p>
            <p>残件は複数の要素を含むリストの場合の処理。</p>
            <p>要素が単一の場合については完了している。</p>
            <p>なので、30分、あるいは1時間もあれば十分できるんじゃないかな。</p>
            <p>ソースファイルを要素毎に分けたりしたので、作り切れなかったんだろうか。</p>
            <p>ならば、明日中にリスト要素の完成に加えて、マップ要素も完成させてしまいたいところだが。</p>
            <p>マップ要素の処理はリスト要素と似ているので、案外早く片付きそうな気がする。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/08 22:15</h2>
            <p>設定ファイルの文字列要素の解析処理はできた。</p>
            <p>＊</p>
            <p>想定よりも時間がかかってしまった感じがある。</p>
            <p>しかし、これから追加する予定のリスト、マップ要素でも共通して利用することになる処理も含んでいるので、案外こんなものかもしれない。</p>
            <p>明日はリスト要素の対応。</p>
            <p>ちゃっちゃと片付けてしまいところだが、現状の文字列要素の処理を別ファイルに分離したりとかそういう作業が必要になってくるので、意外と面倒かも。</p>
            <p>＊</p>
            <p>今回作った文字列要素解析処理のソースはおよそ300行。</p>
            <p>全てが文字列要素についての処理というわけではなく、要素共通の処理も含まれているが。</p>
            <p>それに比べて、前回のプロジェクトで作ったソースは文字列要素についてのファイルがおよそ150行、要素共通のファイルがおよそ550行。</p>
            <p>前回のプロジェクトの要素共通のファイルでかすぎない？と思って中を見てみたら、デバッグ出力に結構行数使ってた。</p>
            <p>そういや前回のは、動作確認のために読み込んだデータの内容を1つ1つ出力してたな。</p>
            <p>今回はその辺のチェックがテストコードで済むので、こんなでかいデバッグ出力処理はいらないだろう。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/08 00:05</h2>
            <p>というわけで、テストファーストで作るのを試している。</p>
            <p>＊</p>
            <p>前に作ったソースを流用する予定だったけど、テスト駆動開発の練習も兼ねてほぼ1から作っている。</p>
            <p>最初にごく単純な処理を実装するために、まずテストを書く。</p>
            <p>アサートを先に書き、そのアサートに至るための処理を書いてテストコードとする。</p>
            <p>次にそれを失敗するコードを書き、そのテストコードがテストで実行されることを確認する。</p>
            <p>次に、テストを通すことだけを目的とした、固定値を返すような不完全な仮実装を行ない、テストが通ることを確認する。</p>
            <p>仮実装では不完全ということを示すために、別の入力を行なった場合のテストを書く。</p>
            <p>本実装をして、両方のテストが通ることを確認し、完了。</p>
            <p>最後の方はなんか違うような気がするけど。</p>
            <p>確か、テストは1つで、不完全な仮実装でテストを通し、後はテストが通ることで処理が正しいことを確認する、みたいな感じだったような。</p>
            <p>テストを2つ書くのは三点測量とかいう、なんか不安な時にやる方法とかだったような。</p>
            <p>でもこっちの方がより納得できるんだよなぁ。</p>
            <p>仮実装でもテストが通るというのが気に食わない。</p>
            <p>で、仕様を追加する場合も同じ手順で進めていく。</p>
            <p>＊</p>
            <p>その結果、前に書いた時とは処理方法が変わった。</p>
            <p>まだ前に書いた機能には達していないので変わりそう、が正しいが。</p>
            <p>単純、コンパクトな実装でテストを通すようにしているためか、前に書いたのより見やすく、分かりやすくなっている気がする。</p>
            <p>前はテストとか書いてなかったから、処理ありきで書いていたため、頭の中にある処理をそのまま書き出していたからごちゃごちゃしていた。</p>
            <p>今回はテスト、つまり結果が先に来て、その結果にするためにどうするか、という考え方に加えて、機能を細かく1つずつ実装していっているので、ごちゃごちゃしてない感じがある。</p>
            <p>これなら、機能を増やしていっても見やすい、分かりやすいコードが書けそうだ。</p>
            <p>＊</p>
            <p>初日ということもあってかあまり進んでいないが、大体分かってきたので明日からはもっと進められればいいのだが。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/06 01:25</h2>
            <p>CppUnit？知らない子ですね。</p>
            <p>＊</p>
            <p>Google Testに切り替えた。</p>
            <p>他にもBoost.Testとかあったらしい。</p>
            <p>完全に調査不足である。</p>
            <p>Google Testに決めたのは、出力に色が付くのでテストの成否が一目で分かるというのが一番の理由。</p>
            <p>その結果、CppUnitをより扱いやすくするために書いたコードは全て不要になった。</p>
            <p>悲しい。</p>
            <p>＊</p>
            <p>元々、CppUnitはJUnitをC++用に書き直したようなものだからか、クラスありきな書き方が気に入らなかった。</p>
            <p>Google Testなら、クラスを作らずにテストを書けるし、必要に応じてクラスを使ったテストも書くことができていい感じっぽい。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/05 13:15</h2>
            <p>昨日は久々に朝方まで作業してしまった。</p>
            <p>＊</p>
            <p>その甲斐もあって、CppUnitを利用した自動テスト実行環境は大体整った感ある。</p>
            <p>wafの自動テストサポートも使い、ビルド成功時にテストプログラムが自動的に実行されて、テストが通ったか通らんかったか表示されるようにした。</p>
            <p>ただ、テストの通った通らないはテストプログラム単位なので、テストが通らなかった時にどのテストが通らなかったのかは表示されない。</p>
            <p>なので、その場合は自分でテストプログラムを実行してどのテストが通らなかったのか確認する必要がある。</p>
            <p>そこが少し面倒だが、かといって全テストの出力を表示すると量が多すぎるか。</p>
            <p>＊</p>
            <p>テストコードのファイル数が増えれば増えるほど、テスト対象コードの全く同じコンパイル処理の回数が増えると思われる。</p>
            <p>ビルド時間の増大が懸念されるが、全く同じということはコンパイルキャッシュなるものを使えば時間短縮できるんだろうか。</p>
            <p>＊</p>
            <p>もうちょい整えたらテストファーストで作業を開始するつもりだけど、それは月曜からにしようかなぁ。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/04 02:45</h2>
            <p>タグとか初めて使った。</p>
            <p>＊</p>
            <p>使い方これでいいのかよく分からんけど。</p>
            <p>とりあえず<a href="https://bitbucket.org/tekuto/candymaker" target="_blank">リポジトリを作っておいた。</a></p>
            <p>読んだファイルの内容を処理するところまでやろうかとも思ったけど、とりあえずファイルを読み込んでその内容を出力するだけ。</p>
            <p>それでバージョン0.1.0ということにした。</p>
            <p>次は読んだ内容を処理し、データを抽出して出力する。</p>
            <p>それを0.2.0ということにしよう。</p>
            <p>基本的には、処理内容は今までに作ったやつから持ってくればいいと思う。</p>
            <p>でも今回は、自動テストを作ってから作る、テストファーストというやつをやってみよう。</p>
            <p>そのためにCppUnitをインストールしたのだ。</p>
        </div>
        <hr />
        <div>
            <h2>2015/09/02 22:45</h2>
            <p>超久しぶり。</p>
            <p>＊</p>
            <p>正直詰まってる感じある。</p>
            <p>思うに、やはり行き当たりばったりすぎるのだろう。</p>
            <p>筋道が立たずにところどころ肥大化しつつあるような、どうしようもない進め方になってしまっている。</p>
            <p>こんなことしても進んで戻ってを繰り返すことになりそうでさすがに躊躇しているのだが、1から作り直すべきかもしれない。</p>
            <p>一体何回目になるのだ。4回？5回？</p>
            <p>経験はどんどん蓄積されているわけなのだから、それをうまく利用できればいいのだけれど。</p>
            <p>＊</p>
            <p>まずは単純なものを作らなくては。いつもここが抜けている気がする。</p>
            <p>色々考えた結果、とりあえずベースファイルとかいらん。</p>
            <p>環境に1つの設定ファイルなんぞ見るとかそんなんもっと後でいい。今はいらん。</p>
            <p>コマンドライン引数から設定ファイルのパスを受け取り、そのファイルの内容を処理する。これだ。</p>
            <p>いっそそのファイルのパスも固定してしまえばもっと単純になるかもしれないが、さすがに実用性がなさすぎる気がする。</p>
            <p>＊</p>
            <p>ここまで書いといて今更だが、作ろうとしてるプログラムの大まかな流れは、</p>
            <p>・ベースシステムという機能集合体を生成</p>
            <p>・ベースシステムを利用して動作するゲームをロード</p>
            <p>・ゲームを動かす</p>
            <p>という感じになる。</p>
            <p>前述のコマンドライン引数で渡す設定ファイルのパスというのは、ゲームについての情報が書かれているファイルだ。</p>
            <p>現状では、ベースシステムについての情報は何一つ書かれていない。</p>
            <p>これまでの想定としては、ベースシステムについての情報は環境に1つの設定ファイルに記述しておく形だった。</p>
            <p>しかしよく考えると、それだと使用するベースシステムが固定的になりすぎる気がする。</p>
            <p>別のベースシステムの上でゲームを動かしたいなーとかなった時に面倒だ。</p>
            <p>なので、コマンドライン引数で渡す設定ファイルの中に、ベースシステムについての情報も書いておくべきかななどと思った。</p>
            <p>そもそもコマンドライン引数で渡す設定ファイルはショートカットファイルという名前だ。</p>
            <p>それ1つ読めば、とりあえずゲームが起動するところまでできるべきファイルなのだ。</p>
            <p>ならば、ショートカットファイルにはベースシステムの情報とゲームの情報、どちらも記述するべきだろう。</p>
            <p>後々既定のベースシステムとか作る場合には、ベースシステムの情報の記述は必須ではないとかにすればよかろう。</p>
            <p>＊</p>
            <p>そこからまた展開させようとすると、どんどん肥大化していく悪寒がする。</p>
            <p>なのでとりあえず決まったそこまで作ろう。</p>
            <p>まずコマンドライン引数でショートカットファイルパスを受け取る。</p>
            <p>次にそのファイルを読む。</p>
            <p>最後に読んだ内容を出力する。</p>
            <p>これだ。これで行こう。</p>
            <p>ここまで作ったらまた書く。</p>
        </div>
        <hr />
        <div>
            <h2>2015/03/02 20:49</h2>
            <p>パッケージ設定に対応するパッケージ情報と、依存パッケージ設定の読み込み処理まで作った。</p>
            <p>＊</p>
            <p>次は、その読み込んだ設定ファイル群からベースシステム情報を取得する処理と、その構築に必要なモジュール群の列挙処理か。</p>
            <p>それを終えて初めてモジュールマネージャに取りかかれるな。</p>
        </div>
        <hr />
        <div>
            <h2>2015/02/25 16:02</h2>
            <p>設定ファイル、JSONじゃない方がいいかもしれない。</p>
            <p>＊</p>
            <p>思いの他扱いやすいし見づらくもないので大体問題はないんだけど、JSONの仕様には存在しない要素がほしい。</p>
            <p>具体的に言うと集合がほしい。</p>
            <p>現時点では、やろうとするとリストとして記述し、JSONを読み込んでデータを取り出した後に、重複するデータは削除するなどすればできるけど、なんだか回りくどい。</p>
            <p>JSONを読み込んだ時点で、重複するデータは削除するようにしてしまいたいところ。</p>
            <p>[]はリストで、{}はオブジェクトだから、適当なところで()だろうか。</p>
            <p>pythonと同じような感じになりそうだな。</p>
            <p>ただこれをやるとなると、JSONの比較処理も追加しなければならないな。</p>
            <p>＊</p>
            <p>JSON読み込み処理は現時点ではかなり限定的でJSONとは呼び難いのだけど、この機能を追加するとJSONの定義から完全に外れることになる。</p>
            <p>だからどうだということも、特にないが。</p>
        </div>
        <hr />
        <div>
            <h2>2015/02/25 13:01</h2>
            <p>設定ディレクトリ内にあるコンフィグディレクトリってなんだろうな。</p>
            <p>＊</p>
            <p>パッケージのモジュールの使用許可やセーブデータディレクトリとの関連付けなどを記述した設定ファイルなんだけど、パッケージ設定とは呼びにくい。</p>
            <p>パッケージディレクトリに配置されている各パッケージ内にも設定ファイルが存在するからだ。</p>
            <p>現時点では、後者を読み込む時にPackageConfigという構造体にデータをつっこんでいる。</p>
            <p>しかし、このファイルは基本的にユーザーが変更することはないため、設定というよりは情報が記述されているだけのファイル、と考えるべきかもしれない。</p>
            <p>そう考えると、PackageConfigではなくPackageInfo、パッケージ情報ファイルと呼ぶべきかもしれない。</p>
            <p>そうすれば、モジュールの使用許可などを記述したファイルのことをパッケージ設定ファイルと呼べるし。</p>
            <p>今まで脳内ではコンフィグ設定ファイルとか呼んでいたが、コンフィグと設定って同じ意味だし、構造体にしようとするとConfigConfigになっちゃうしで困っていたが、これでどうにかなりそうだ。</p>
            <p>＊</p>
            <p>前の記事に書いた作業については昨日のうちに終わらせておいた。</p>
        </div>
        <hr />
        <div>
            <h2>2015/02/23 23:31</h2>
            <p>思うに、ソースコードが読みにくい。</p>
            <p>＊</p>
            <p>情報を表すデータと、情報を参照するための情報を表すデータがほぼ同じ名前で定義されているため分かりにくい。</p>
            <p>前者をXXとしたら、後者はXXRefという感じに命名するようにしようかなぁ。</p>
            <p>デバッグ出力も、後者もXXとほぼ同じ出力になっちゃってるから分かりにくいし。</p>
            <p>＊</p>
            <p>モジュールマネージャに取りかかる前に、まずはそこらのリファクタリングからだな。</p>
        </div>
        <hr />
        <div>
            <h2>2015/02/23 19:29</h2>
            <p>牛歩、牛歩。</p>
            <p>＊</p>
            <p>ようやくモジュールマネージャに取りかかれそう。</p>
            <p>パッケージ設定ファイルからベースシステムの設定を取得するところまではできたので、ベースシステムを生成するために生成関数と破棄関数の取得を行なわねばならない。</p>
            <p>関数の取得の前にはモジュールのロードを行なわなければならないし、つまりいよいよモジュールマネージャというわけである。</p>
            <p>＊</p>
            <p>基本データ型の定義を変えるべきかもしれない。</p>
            <p>現時点では、typedefを使ってintをfg::Intと定義したりしてるのだけど、モジュールがエクスポートするシンボルのことを考慮すると、これはあまりよくない気がする。</p>
            <p>fg::Intはシンボルとしてはintと同じように扱われてしまう。</p>
            <p>これはあまり都合がよくない。</p>
            <p>fg::Intはfg::Intとして扱われていた方が都合がいいのだ。</p>
            <p>主に、シンボル名のマングリングとかそこらの処理のために。</p>
            <p>それをやるためには、fg::Intをtypedefではなくクラスとして定義すればいいのだろうけど、ソースコード上での扱いは今までのから変更したくはない。</p>
            <p>演算子のオーバーロードを駆使することで達成できるのかなぁ。不安だ。</p>
        </div>
        <hr />
        <div>
            <h2>2015/02/10 22:35</h2>
            <p>このところ、raspberrypiをいじくっていた。ちょうど日記が途切れた辺りから。</p>
            <p>＊</p>
            <p>raspbmcをつっこんでみたり、openelecをつっこんでみたり。</p>
            <p>raspberrypiでradiko使ってラジオが聴けるようになったり、インターネットラジオ聴けるようになったり、youtube見れるようになったり、天気予報確認できるようになったりなど。</p>
            <p>テレビにHDMIでつなげばテレビのリモコンで操作できるようになったりしておもしろい。</p>
            <p>＊</p>
            <p>で、bindとdhcpを動かしてるraspberrypiにこれらの機能をつっこめないか、と思って色々試していたのだが、結局今動いているようなgentooにxbmcをインストールするのが一番手っ取り早そう、という結論に達した。</p>
            <p>raspbmcはなぜか無線LANがうまくつながらんし、openelecはbindとdhcpを追加するのがかなりめんどそうだし。</p>
            <p>＊</p>
            <p>しかしながら、gentooをまた構築するのもそれはそれでめんどうだったり。</p>
            <p>いい加減dropmakerの方進めたくなってきたし、休みの日とかに気が向いたらちょっとずつ進めてみようかと。</p>
            <p>って明日祝日？明日はやらん。どうもraspberrypiに関わると頭が痛くなりやすい気がする。</p>
        </div>
        <hr />
        <div>
            <h2>2015/02/04 00:12</h2>
            <p>モチベーションが下がっているが、ちょっとずつ進んでいる。</p>
            <p>＊</p>
            <p>パッケージ設定ファイルも、大部分は処理できている。</p>
            <p>例によって、暫定的な実装であるため穴だらけだが、そのうちなんとかする予定。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/29 21:11</h2>
            <p>進みが遅くなっている。</p>
            <p>＊</p>
            <p>パス型の扱いを少し変えたり、パッケージ設定を読み込む際の処理で、今まで書いた処理を共通関数化して使えるようにしてから処理したりなど。</p>
            <p>パッケージ設定ファイルを見てて思ったのは、これまた割と適当に決めた感じがあるなぁということ。</p>
            <p>でもまぁ、とりあえず全部読み込んで型に落とし込む。</p>
            <p>そうしないと始まらん。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/28 00:28</h2>
            <p>パス型を文字列に変換する暫定的な処理ができた。</p>
            <p>＊</p>
            <p>しかし、本当に暫定的だ。</p>
            <p>機能も少ない。循環参照エラーの検出ができないため、設定ファイルでまずい記述をすると無限ループが発生する可能性もある。</p>
            <p>その辺の問題は後々解決していくとしよう。めんどいので。</p>
            <p>＊</p>
            <p>とりあえずパス型を文字列に変換し、ファイルを読み込むところまではできたが、読み込んだものの処理はまだ実装していない。</p>
            <p>その辺は明日やる。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/26 19:49</h2>
            <p>パッケージ設定の読み込み処理を作っているところ。</p>
            <p>＊</p>
            <p>ファイルをJSONとして読み込む処理とかは、ベース設定の読み込みでも使っているので使い回せるが、パスの扱いは今回が初になるため、そこで少し手間取っている。</p>
            <p>具体的にはパス型を文字列型に変換し、ファイルオープンなどに使えるようにする処理なのだが、今回作成するものは限定的な機能を持ったものでいいだろう。</p>
            <p>とにかく、パッケージ設定のパスを文字列にできればいいのだ。そのために全機能は必要ない。</p>
            <p>後々きちんと全機能作らなければならないだろうけど、今それをやると間違いなくだれる。</p>
            <p>今回作らない機能についても、大体どのように実装すればいいのかはイメージできているので多分大丈夫。多分。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/23 21:06</h2>
            <p>ひとまず、ベースシステム生成、破棄関数取得までの流れは作った。</p>
            <p>＊</p>
            <p>ベースシステムの生成、破棄に関わるモジュール群生成までの流れも作ってしまいたいところだったが、これにはモジュールローダの設計が大きく関わってくる。</p>
            <p>そして、今のところモジュールローダは中身が空っぽの状態だ。</p>
            <p>よってまだ書けない。書くのはモジュールローダの設計をまとめて、というかモジュールローダを作ってからだな。</p>
            <p>＊</p>
            <p>やはり今週中は無理だったな。来週中ならいけるかしら。</p>
            <p>来週の作業手順は、とりあえず流れを作ってあるベースシステム生成、破棄関数取得までの部分の実装を作るところからだろう。</p>
            <p>それを終えたら、モジュールローダを作るのとベースシステムの生成、破棄に関わるモジュール群生成を並行して行なう感じだろうか。</p>
            <p>大体後者が主導になると思うが。部品を先に作ってしまって、実際に使う場面でやっぱりびみょう、使い物にならんとかなったら目も当てられん。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/23 14:00</h2>
            <p>というわけで、サイトをgithub pagesに移行した。</p>
            <p>＊</p>
            <p>何日か前に書いたような気がしたけど書いてなかったので、経緯を書いておこう。</p>
            <p>gaeのツールが動かんくなった。</p>
            <p>どうもpythonのバージョンとうまく噛み合っていないらしく、バグ報告も上がっているようだけどツールのバージョンアップが来ない。</p>
            <p>現状やってることと言えば静的ページの公開だけだし、記事書いた後にコミットとは別にアップロードコマンド打つのもめんどうなので、github pagesに移行した。</p>
            <p>github pagesなら独自ドメイン使用時にサブドメイン付けなくていいし、サブドメインからリダイレクトさせることもできるので、URLをtekuto.netにできていい感じ。</p>
            <p>今までのwww.tekuto.netにアクセスすれば、tekuto.netにリダイレクトしてくれる。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/23 00:15</h2>
            <p>今週中に終わらせられれば、とか昨日書いたけど早速今日、諸事情により作業できなかった。</p>
            <p>＊</p>
            <p>明日から本気出す。</p>
            <p>でもさすがに明日1日で終わらせるのは無理だろうなぁ。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/21 18:10</h2>
            <p>ベース設定ファイルからベースシステムとシェルについての情報を読み込む処理を書いた。</p>
            <p>＊</p>
            <p>Baroqueのサントラ流しながら作業すると集中できていいな。</p>
            <p>歌が入ってるタイプの曲は、作業中の私にはあまり向かないようだ。</p>
            <p>気が散りやすいというか、ヘッドホンで聞きながら作業すると頭痛くなったりする。</p>
            <p>＊</p>
            <p>さて、ベース設定ファイルに記述する内容はひとまず全て読み込む処理を書いたので、次はそれを元にベースシステムを生成するための情報を生成する処理か。</p>
            <p>まずはどこからだろうか。ベースシステム情報に記述してある、パスに対応した設定ファイルを読み込む処理からかな。</p>
            <p>その設定ファイルには、対応するパッケージについて、そのパッケージのパスや、対応するセーブデータのパス、使用を許可するモジュールのリストなどが含まれている。</p>
            <p>ので、その設定ファイルを読んだら次はパッケージの設定ファイルを読み込んで、とかそういう流れになるんだろうな。</p>
            <p>なかなか負荷の高そうな内容だ。今週中に終わらせられればいいのだが。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/21 16:00</h2>
            <p>パス型の定義変更に対応完了。</p>
            <p>＊</p>
            <p>昨日に済ませておきたかったところだけど、ちょうどその直前できりがよかったため、昨日の作業はそこで切り上げてしまった。</p>
            <p>で、今日その辺をさくっと終わらせた。</p>
            <p>次はベースシステムやシェルについての情報をベース設定ファイルから読み込む処理と、ベース設定ファイルの情報を元に、色々設定ファイルとか読み込んで、ベースシステム生成に必要な情報を構築する処理かな。</p>
            <p>ベースシステムについての情報が記述されてるんならそれでいいじゃないかと思うかもしれないが、記述されているのは設定ファイルのパスとベースシステム名だけなので、具体的にどのモジュールをロードし、なんて関数を呼び出して生成し、破棄するか、といった情報は他の設定ファイルを読まないと分からない。</p>
            <p>なので、その辺どうにかする処理を書く、といった感じだ。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/20 14:38</h2>
            <p>やはりきちんと毎日書かんとだめだな。すっかり習慣がなくなってる。</p>
            <p>＊</p>
            <p>昨日の作業としては、設定ファイルの記述を修正したり、パス型の読み込み処理を独立させたりなど。</p>
            <p>パス型の定義を変えてあるため、現時点の処理では対応できないので、使う場面になったら修正することになるだろう。</p>
            <p>今日はベースシステム構築のためにコンフィグマネージャから情報を取得する処理とか書くつもりなので、前述の修正はやることになるかも。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/17 00:38</h2>
            <p>できるだけ忘れずに書いていくことにする。</p>
            <p>＊</p>
            <p>早速忘れかけていた上に、ツールがちゃんと動作するようになるまでネット上に上げられんけども。</p>
            <p>さて、結局設定ファイルの扱いについては、いっそのこと全ての設定ファイルを1箇所で管理した方が分かりやすいのでは、ということで話が進んでいる。</p>
            <p>設定ファイル間で関連性があるものも結構あるわけだし、管理オブジェクトに対し、情報を要求すれば必要に応じて設定ファイルを読み込んで情報を生成して返す、みたいな。</p>
            <p>一度読み込んだ設定ファイルはキャッシュしておいたり、もし要求があればキャッシュを削除したりなども考えているけど、前者はともかく後者は後回しだろうな。</p>
            <p>いや、前者も別に必須ではないな。</p>
            <p>もやもやは晴れつつあるし、ペース上げていきたいところだが。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/15 20:42</h2>
            <p>過去ログは年単位で分ければいいのでは、という声が一部でささやかれている。</p>
            <p>＊</p>
            <p>進みはスローペース。もっとさくさくやりたいところだが。</p>
            <p>ベース設定の一部を読み取る処理はできた。</p>
            <p>一部というのはパスの別名定義。パスに名前を付けて管理する形を取るので、そう呼んでいる。</p>
            <p>これにより、それぞれのデータのパスを指定できるようになった。</p>
            <p>最終的には、ベースシステムの構築→シェルの起動→ゲームの起動となるわけだが、それまでにどういう処理が必要になるだろうか。</p>
            <p>ベースシステムの構築やシェル、ゲームの起動のためには、やはりモジュールのロードが不可欠。</p>
            <p>よって、モジュールマネージャの生成が必要になるだろう。</p>
            <p>モジュールのロードには、パッケージディレクトリとコンフィグディレクトリに置かれているファイルの読み込みが必要になってくるはずだ。</p>
            <p>しかしその処理はモジュールマネージャ内で行うべきだろうか？難しいところだ。</p>
            <p>それを含めてしまうと、モジュールマネージャが肥大化してしまう気がする。</p>
            <p>とはいえ、どこかでは設定ファイル間の関連付けを解決する処理をやらねばならない。</p>
            <p>いっそ、モジュールマネージャではなく設定ファイルマネージャと考えるべきだろうか。</p>
            <p>モジュールのロードとかは、それとは別にモジュールローダというか、モジュールロードマネージャというか、そんな感じの機能を別に作り、そこでやらせる。</p>
            <p>パッケージディレクトリの設定ファイルと、コンフィグディレクトリの設定ファイル読み込み処理については、別々の機能に分けることはできないだろうな。</p>
            <p>パッケージに含まれるモジュール一覧とその詳細情報は前者に書かれているが、どのモジュールの読み込みが許可されているかどうかは後者に書かれている。</p>
            <p>あるモジュールを読み込むだけなら、後者の設定ファイルを読んだ後に前者の設定ファイルを読めばいいだけだが、モジュールによっては依存モジュールが存在する。</p>
            <p>依存モジュールについては、また後者の設定ファイルから読み直す必要がある。</p>
            <p>これを別々の機能に分けるとなると、循環参照になってしまって気持ちの悪いことになりそうな感じがある。</p>
            <p>＊</p>
            <p>書いてたら、ちょっともやもやが晴れた気がする。</p>
            <p>完全にクリアになったわけではないのだが。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/26 19:15</h2>
            <p>難航していたが、ようやくまとまってきた感ある。</p>
            <p>＊</p>
            <p>今までのファイル構成は、dropmakerのホームディレクトリ直下にベース設定ファイル、パッケージディレクトリ、ゲームディレクトリがあった。</p>
            <p>セーブデータディレクトリなんかも置く予定だったけど、まだそれが必要になる段階まで到達していない。</p>
            <p>実際には、ベース設定ファイル以外のディレクトリはベース設定ファイル内で指定した位置なので、ホームディレクトリの下に置く必要はないが。</p>
            <p>それはともかく、パッケージディレクトリにはゲーム本体、プログラムやら、画像とか音楽とかのリソースやらが配置される。</p>
            <p>一旦配置されたら、削除されるまで変更がかかることは基本的にない。</p>
            <p>ゲームディレクトリには、ゲームパッケージを起動するための情報を記述した設定ファイルを置く。起動するパッケージ名やらモジュール名やらゲーム名やら。パッケージがなんらかのインターフェースを使用する場合、その実装モジュールの指定もする。</p>
            <p>プレステで例えれば、パッケージディレクトリはCD、ゲームディレクトリ（とセーブデータディレクトリ）はメモリーカードである。</p>
            <p>＊</p>
            <p>今回の構成変更で、とりあえずゲームディレクトリは無くした、というより分割した。</p>
            <p>その前に、モジュールの扱いを変えたのを説明するべきか。</p>
            <p>今までは、モジュールはゲームディレクトリの設定ファイルでインターフェースとの関連付けを行っていた。</p>
            <p>今回の変更で、その関連付けはやめた。</p>
            <p>その代わり、パッケージディレクトリの設定ファイルに、各モジュールが実装しているインターフェースを記述しておく形にした。</p>
            <p>ゲームディレクトリの設定ファイルでは、使用を許可するモジュールのリストアップのみ行う。</p>
            <p>あるインターフェースの使用が要求された場合、使用が許可されているモジュールの中から、そのインターフェースが実装されているモジュールを検索し、使用する。</p>
            <p>もし該当するモジュールが2つ以上ある場合には、衝突が発生しているので要求は失敗となる。</p>
            <p>該当するモジュールが存在しない場合には、インターフェースを定義するパッケージが提供するダミーモジュールを使用する。</p>
            <p>ダミーモジュールを使うことで、例えばネットとの通信モジュールを使用するゲームであっても、ユーザー側でその機能を無効化する、ということも可能になる。</p>
            <p>とはいえ、ゲーム側がネットとの通信ができないなら動作しないようにしたりしていれば、そもそもゲーム自体できなくなってしまうわけだが、それはまた別の問題だ。</p>
            <p>＊</p>
            <p>で、ゲームディレクトリをコンフィグディレクトリとショートカットディレクトリの2つのディレクトリに分けた。</p>
            <p>コンフィグディレクトリでは、パッケージディレクトリとセーブディレクトリとの関連付けや、前述の使用を許可するモジュールのリストアップなどを行う。</p>
            <p>パッケージが他のパッケージに依存する場合、対象のパッケージについての設定が書かれたファイルの指定などもできる。</p>
            <p>ショートカットディレクトリでは、起動に関する設定をまとめる。</p>
            <p>起動するゲームの指定、メインウィンドウのサイズの指定など。</p>
            <p>＊</p>
            <p>まとめると、</p>
            <p>パッケージディレクトリにゲーム本体をつっこみ、</p>
            <p>コンフィグディレクトリにパッケージの設定をつっこみ、</p>
            <p>ショートカットディレクトリにゲーム起動時の設定をつっこむ、といった具合か。</p>
            <p>あと、セーブデータディレクトリにゲームのセーブデータをつっこむ。</p>
            <p>＊</p>
            <p>一部の設定ファイルについては、拡張子が一致していれば複数のファイルに分割することも許可する予定。具体的にはベース設定とパッケージ設定。</p>
            <p>コンフィグディレクトリに配置する設定ファイルについても複数のファイルに分割できるようにしたいが、いい案が浮かばない。</p>
            <p>前述のファイル分割は、見やすさ、扱いやすさの向上などが目的だが、こちらは違う。</p>
            <p>パッケージとセーブデータの関連付けと、使用許可モジュールリストを別ファイルに分けることで、例えば使用するモジュールはそのままに別のセーブデータを使いたいとか、同じセーブデータを使うけど使用するモジュールは変えたいとか、そんな感じだ。</p>
            <p>ならばその2つの設定を別のディレクトリに分けてしまえば、と思わないでもないが、そこまですることだろうか。少なくともパッケージとセーブデータの関連付けの方はデータ量が少なすぎる。</p>
            <p>細切れになるばかりで扱いにくくなりそう。</p>
            <p>その辺は後々対応することにしようかしら。そのくらいなら、全体的に修正をかけなければならない、というレベルのものでもないだろうし。</p>
            <p>＊</p>
            <p>ともかく、現時点ではファイルとディレクトリの構成を考えただけであり、実際にそれを運用するためのプログラムは存在していない。</p>
            <p>今までのdropmakerは断片的にしか役に立たないだろうし、1から作っていくとしよう。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/22 00:14</h2>
            <p>色々考えていたが、dropmakerはまた作り直した方がいいかもしらんね。</p>
            <p>＊</p>
            <p>どうにもモジュールの管理周りがうすらぼんやりとしてよくない。</p>
            <p>指定したモジュールから関数のアドレスを取得する関数を、全てのロード済みモジュールから関数のアドレスを探して取得する関数に変えようとするだけでもなんかうまくいかない。</p>
            <p>うまくいかないというより、変更が大きくなりすぎるというか、1から作り直した方が早そうというか。</p>
            <p>この際、ディレクトリや設定ファイルの構成らへんから練り直すべきかもしれない。</p>
            <p>現状では、直接起動するパッケージ以外はセーブデータを持てないし。</p>
            <p>依存モジュールの解決も、今は単純な構成だからましだけど、ちょっと複雑な構成になるとすぐだめになりそう。</p>
            <p>＊</p>
            <p>大まかな構成はテキストに書き出したので、土日に実際にディレクトリや設定ファイルを並べてみるつもり。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/18 00:40</h2>
            <p>日をまたいでしまった。</p>
            <p>＊</p>
            <p>次の日のやる気に影響するかもしれないので、こんな時間まで作業するべきではない。</p>
            <p>さて、fg::Windowからfg::Screenを分離した。</p>
            <p>デモを使って正常に動作することも確認済み。</p>
            <p>ここまでは大したことはない。ファイルの移動と記述の置換、それと多少の修正でできた。</p>
            <p>ここからが本番。メインウィンドウの生成と、それをゲーム側から触れるようにする。</p>
            <p>＊</p>
            <p>sucrose-screen-*モジュールを追加したので、パッケージ設定ファイルに記述を追加していて思ったが、もうちょっと要素を追加した方がよさそうだな。</p>
            <p>そのモジュールがなんのインターフェースの実装なのかを示す情報が現時点では存在しない。</p>
            <p>今のところはモジュール名を同じにすることでそのインターフェースの実装モジュール、ということにしているが、それだと実装が複数存在する場合に対応できない。</p>
            <p>そこで、モジュールの設定ツリーになんのインターフェースの実装なのかを示す要素を追加してみようか、などと考えている。</p>
            <p>そこまで優先度が高いわけではないので、後々実装する予定。</p>
            <p>あるいはもっといい設計が思い浮かぶかもしれないし。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/14 12:40</h2>
            <p>ウィンドウを2つの型に分離することを検討している。</p>
            <p>＊</p>
            <p>OpenGLコンテキストの扱い方については昨日の調査で大体把握できたので、以降はメインウィンドウをどのように実装するか考えていた。</p>
            <p>しかし、どうにもうまくまとまらない。</p>
            <p>今のところ、ウィンドウはfg::Windowという型で表現しているが、これを直接使うと色々問題がある。</p>
            <p>例えば、fg::Windowはfg::close()を使えばウィンドウクローズ、fg::resize()という関数を使えばリサイズなどの要求が行なえるが、メインウィンドウに関してはこれらは必要ないように思う。</p>
            <p>また、fg::free()を使えばウィンドウの破棄ができてしまう。</p>
            <p>破棄はメインウィンドウを生成、制御するゲーム起動側でやるので、ゲーム側ではできないようにしたい。</p>
            <p>他にも色々あるが、要はウィンドウを表現するという意味ではfg::Windowでいいのだが、その機能などがメインウィンドウと合致しない、といった感じだ。</p>
            <p>＊</p>
            <p>ぱっと思い付いた対応として、例えばfg::MainWindowという型を作り、内部的にfg::Windowを持たせ、fg::MainWindowにはfg::Windowの持つ関数のうち一部だけを用意すればいいのではと考えた。</p>
            <p>しかしこれはあまりいい対応ではない。</p>
            <p>簡単に言えば面倒なのである。fg::MainWindowの内部にfg::Windowを持たせ、fg::Windowと似たような関数を用意するということは、fg::Windowに新たに関数を増やし、それがfg::MainWindowでも使えるようにすべき関数である場合、fg::MainWindowにも同じように関数を増やさなければならない。</p>
            <p>当たり前ではあるが、こういうのは忘れてしまう可能性があるし、またfg::MainWindowの方の関数はfg::Windowの同じ関数を呼び出すラッパー程度の関数になるとはいえ、記述ミスによるバグを抱えてしまう可能性もある。</p>
            <p>＊</p>
            <p>そこで考えたのが、ウィンドウを2つの型に分離する、という方法だ。</p>
            <p>今はウィンドウを表現する型はfg::Windowのみだが、これとは別に表示領域を表現する型を用意する。</p>
            <p>仮にfg::Screenということにするが、fg::Screenは自発的に生成、破棄することができない。</p>
            <p>再描画やリサイズなどのイベントについてはイベントハンドラを設定できるようにするが、リサイズリクエストはできないようにする。</p>
            <p>例えば、fg::Windowの内部的にfg::Screenを持たせる、という感じにする。</p>
            <p>fg::Windowを生成すれば、それに対応したfg::Screenも同時に作られる、ということだ。</p>
            <p>それで、fg::Windowの関数としてfg::getScreen()とかいう関数を用意して、fg::Screenの参照を取得できるようにする。</p>
            <p>メインウィンドウについては、ゲーム側からはfg::Screenの参照のみを扱えるようにする。</p>
            <p>fg::Screenの参照だけ、つまりメインウィンドウの表示領域だけなら、破棄もできないし勝手なクローズやサイズ変更の要求もできない。</p>
            <p>おまけに、ラッピングした型でもないのでラッパー関数を作る必要などもない。</p>
            <p>＊</p>
            <p>うまくいきそうな気はしている。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/13 16:00</h2>
            <p>OpenGLのコンテキストについて色々試したので、整理しておこう。</p>
            <p>＊</p>
            <p>ある1つのウィンドウを、複数のスレッドのカレントコンテキストに設定することは可能。</p>
            <p>ある1つのOpenGLコンテキストを、複数のスレッドのカレントコンテキストに設定することは不可能。</p>
            <p>やろうとすると、glXMakeCurrent()を呼び出すタイミングでセグメント例外が発生する。</p>
            <p>一度、スレッドのカレントコンテキストを別のOpenGLコンテキストに変えるなりすれば、別のスレッドのカレントコンテキストに設定することはできる。</p>
            <p>しかしその場合、別のスレッドのカレントコンテキストに設定する前に行なわれ、まだ画面に表示されていない描画処理は無かったことになる。</p>
            <p>なので、一度カレントコンテキストに設定したOpenGLコンテキストを、別のスレッドのカレントコンテキストに移すとかいうのは、あまり意味がないように感じる。</p>
            <p>少なくとも、ゲーム起動側がメインウィンドウに描画を行なうためのOpenGLコンテキストを、ゲーム側から参照できるようにする必要性は、ほぼないことが確認できたと言っていいだろう。</p>
            <p>OpenGLコンテキストを複数のスレッドで使えないので、複数のウィンドウに対して1つのOpenGLコンテキストを割り当てる、とかいう構成も当然無理。</p>
            <p>＊</p>
            <p>今の構成は、fg::GLContextを生成し、その参照とfg::Windowの参照を使ってfg::GLCurrentを生成、それを使ってOpenGLの関数を呼び出す、といった具合。</p>
            <p>別のスレッドのカレントコンテキストに設定し直す意味があまりないということは、fg::GLCurrentなんて作らず、fg::GLContextの生成時にOpenGLコンテキストの生成とカレントコンテキストの設定を行ない、破棄時にカレントコンテキストからの設定解除とOpenGLコンテキストの破棄をやってしまえばいいのでは、ともちょっと思ったけど、それもまたちょっと違うんだろうな。</p>
            <p>例えばテクスチャの情報などはOpenGLコンテキストに関連付けられるだろうし、ウィンドウを一度破棄してもう一度ウィンドウを作り、以前と同じような表示をしたい場合、その度にOpenGLコンテキストの生成を行なっていたのでは再度テクスチャの情報なども作り直さなくてはならない。</p>
            <p>OpenGLコンテキストの生成・破棄とカレントコンテキストの設定・設定解除を分離しておけば、その辺うまく使い回せそうな気がする。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/12 23:00</h2>
            <p>今まで中途半端に作っていたデモをきちんと整えるなど。</p>
            <p>＊</p>
            <p>メインウィンドウ、どうやって実装しようか考え中。</p>
            <p>実質的に、ウィンドウのイベントは再描画要求以外触れないようにしたいところ。</p>
            <p>加えて、必要に応じてゲーム起動側、つまりメインウィンドウを生成した側でも画面に描画を行なえるようにしたい。</p>
            <p>それはつまり、ゲーム起動側にメインウィンドウで使用するOpenGLのコンテキストを持たせるわけで。</p>
            <p>それがカレントコンテキストになっているスレッドも持たせる必要があるわけで。</p>
            <p>描画することを考えなければカレントコンテキストの件は無視できるので、とりあえずそれでやってみようかなぁ。</p>
            <p>1つのウィンドウを、複数のスレッドでカレントコンテキストにする、とかってできるのかなぁ。</p>
            <p>今まで試したことがないから、明日試してみようかな。</p>
            <p>その結果次第では、OpenGLコンテキストはゲーム側から参照できるようにしなくても済むかも。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/11 19:45</h2>
            <p>昨日書いた通り、OpenGLの関数を使えるようにした。</p>
            <p>＊</p>
            <p>ほとんど前のプロジェクトで書いたものを流用しただけだが、やはり少し手を加えなければ使える状態にはならなかった。</p>
            <p>しかし、OpenGLの関数や定数は数が多いため、一気にファイルの総行数が1万行ほど増えてしまった。</p>
            <p>定数が書かれたファイルでおよそ5500行、関数が書かれたファイルでおよそ3500行あり、これだけで9000行に達するので仕方ないが。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/10 19:50</h2>
            <p>垂直同期については対応した。</p>
            <p>＊</p>
            <p>あとはOpenGLの関数だが、前のプロジェクトで書いたものを流用すれば明日にも完了できる気がする。</p>
            <p>垂直同期の対応についても、基本的には前のプロジェクトのものを流用したわけだが。</p>
            <p>しかしながら、xlibのDisplayをグローバルでなくしたなど、構成を変えているために修正は必要だったが。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/07 20:20</h2>
            <p>OpenGLの対応の残件は、OpenGLの関数を使えるようにするのと、垂直同期対応。</p>
            <p>＊</p>
            <p>今日かコンテキストをカレントに設定する処理を作っていた。</p>
            <p>それに付随して、バッファの切り替え処理も対応した。</p>
            <p>現時点ではglClear()とか使えないので、バッファを切り替えてもゴミデータが表示されてしまうだけだが。</p>
            <p>これであとは、OpenGLの関数を使えるようになれば描画ができるようになる。</p>
            <p>＊</p>
            <p>OpenGLの残件を対応したら、メインウィンドウ機能を対応したいところだ。</p>
            <p>ゲームの実行前に自動的に作られ、ゲーム側に渡されるサイズ変更不可、移動検知不可のウィンドウ。</p>
            <p>事前に設定することでサイズを変更できたり、フルスクリーンで実行できたりなどというのを考えているのだが。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/06 19:15</h2>
            <p>昨日のは勘違いだった。</p>
            <p>＊</p>
            <p>見るデータが間違ってて、実際にはおそらく問題なかった。</p>
            <p>なんであんな勘違いをしたのか。</p>
            <p>あの勘違いをしたやつは直ちに名乗り出ろ。</p>
            <p>＊</p>
            <p>OpenGLの対応を進めている途中で、試しに動かしてみてどうしてもOpenGLの関数を呼び出すところでこけてしまう問題が起きていた。</p>
            <p>1時間程度試行錯誤して、valgrindを使って実行するとこけた気がするのを思い出して、valgrindを使わずに実行したらすんなり動いてがっくりした。</p>
            <p>無駄に疲れた。</p>
            <p>もうこんなことはしたくないものだが、忘れた頃にまたやりそう。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/05 19:50</h2>
            <p>排他処理、スレッドや、ウィンドウについてはとりあえず出来上がっている。</p>
            <p>＊</p>
            <p>今はOpenGLの対応を進めている。</p>
            <p>その途中で、スレッドのライブラリにwaitやnotifyを行なうためのインターフェースを追加したり、その実装を作ったりもした。</p>
            <p>とにかく画面に描画をできるようにしたいところ。</p>
            <p>＊</p>
            <p>valgrind使っててなんかおかしいと思ったら、dlopen()したライブラリがdlclose()されてなかった。</p>
            <p>なんかdlclose()にnullが渡されてるから、クローズされないし失敗もしない。</p>
            <p>ていうかNewModuleの型がおかしい。</p>
            <p>なんでこんな型になっているのか。</p>
            <p>この処理を書いたやつは直ちに名乗り出ろ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/30 20:35</h2>
            <p>イベントハンドラの対応、一応できた。</p>
            <p>＊</p>
            <p>しかし、排他処理のインターフェースを作っていなかったため、まだ実用的でない。</p>
            <p>ロックしてないから、データがおかしくなるかもしれない。</p>
            <p>やはりスレッドのインターフェースも作るべきだろうか。</p>
            <p>ロック関係をそこに含めるか。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/29 19:35</h2>
            <p>まためんどくなってた。</p>
            <p>＊</p>
            <p>sucrose-windowを作成中。あとはイベントハンドラの対応のみ。</p>
            <p>色々考えて、また少しイベントハンドラの扱いを変えた。</p>
            <p>イベントハンドラ部分については、ウィンドウシステムの実装とは無関係だと思ったので、sucrose-window-commonというライブラリに分離させた。</p>
            <p>linux用の、xlibを使う実装はsucrose-window-xlibとして作成してある。</p>
            <p>で、イベントハンドラ部分をあまりめんどくなさそうな感じに設計を変えたので、明日ぐらいには作り終えられるのではと考えている。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/20 19:25</h2>
            <p>順調、と言いたいがやはりスローペースな気がする。</p>
            <p>＊</p>
            <p>とりあえず、sucrose-jsonは使えるようにした。</p>
            <p>あとはsucrose-mainを使えるようにすれば、dropmakerを動かせるが。</p>
            <p>しかし、シンボルの取得とかは処理を書き直さねばならないだろう。</p>
            <p>CからC++にした影響だ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/17 21:20</h2>
            <p>よくよく考えたら、イベントハンドラでつまづいただけだったなぁ。</p>
            <p>＊</p>
            <p>なので、dropmakerに関しては、ほとんどそのままソースを持ってくればいいか、という気分になっている。</p>
            <p>細かく修正を入れようとして時間食うよりずっといい。</p>
            <p>昨日加えた修正の件も考えて、持ってきたソースの中の不要になるconst_castを消していっているのだが、参照系のクラスは全部2種類用意するべきかもしれないなぁ。</p>
            <p>というのも、fg::JsonObjectPairsで似たような状態が発生しているのだ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/16 21:00</h2>
            <p>体調がびみょう。</p>
            <p>＊</p>
            <p>このところ、そのせいか分からんがびみょうに思考がまとまりにくいし、集中もできてないような。</p>
            <p>そんな感じで進みも悪い。</p>
            <p>＊</p>
            <p>文字列参照型を2種類にした。</p>
            <p>std::basic_stringみたいな位置付けのやつだが、std::basic_stringと違い、自身では文字列の領域を保持したりせず、他のところに配置されている文字列を参照する型なのだが。</p>
            <p>今までの構成だとコンストラクタがchar *なので、const char *を入れようとするとconst_castしなければならなくてめんどすぎる。</p>
            <p>なので、コンストラクタにconst char *をつっこむのと、char *をつっこむやつの2種類の型を作ることにした。</p>
            <p>後者の型を前者の型の子クラスにしたので、わざわざオーバーロードした関数を用意しなくても済むし。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/14 21:30</h2>
            <p>10日に書き忘れた。</p>
            <p>＊</p>
            <p>gitのログ見てみたらなんかおかしいな。何回sucrose-commonの生成ルールを追加してるんだ。</p>
            <p>直すのもめんどくさいが。</p>
            <p>＊</p>
            <p>とりあえず、sucrose-commonとsucrose-strconv-iconvを作った。</p>
            <p>前のプロジェクトではstrconvは一度に1種類しかビルドできなかったが、今のプロジェクトでは複数の実装を一緒にビルドできるようにしてあるため、名前を変えた。iconvを使っているので末尾にiconvと足してある。</p>
            <p>commonとstrconvを作ったので、コマンドライン引数を処理するだけのプログラムがビルドできるようになった。</p>
            <p>が、リンクする静的ライブラリ名をハードコーディングしているので、それはどうにかするべきだな。</p>
            <p>必要に応じてコマンドライン引数から指定できるようにしたいが、どうやって処理するべきか。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/09 21:11</h2>
            <p>前のプロジェクトからソースをどんどん持ってきている。</p>
            <p>＊</p>
            <p>2種類のライブラリを生成する件についてはどうにかなった。</p>
            <p>違うプロジェクト間で、wscriptを同一にしなければならないという決まりがあるでもなし、プロジェクト毎に不要なものは削除し、必要なものは追加して対応することにした。</p>
            <p>早いところ、今までに作った部分は移行してしまって、新機能を作成していきたいところ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/08 20:10</h2>
            <p>ビルドの簡略化はできた。</p>
            <p>＊</p>
            <p>とりあえず前のプロジェクトからソースファイルをそのまま持ってきて、fg-commonの生成がきちんとできるのは確認した。</p>
            <p>正確には、fgppからソースを持ってきたのでFGPPをFGに、fgppをfgに置換したりはしたが。</p>
            <p>あれ、よく考えたらあるライブラリについて、静的ライブラリと動的ライブラリの2種類作るのはできなくないか？</p>
            <p>どうしよう。ぱっと思い付く修正案はあるものの、それでいいのかどうか。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/07 22:55</h2>
            <p>早速、作り直し中。</p>
            <p>＊</p>
            <p>ビルドの簡略化を行なっているが、想定よりちょっとめんどかった。</p>
            <p>あるパッケージに存在するモジュールの一覧を取得する処理が、そう簡単にはいかなかった。</p>
            <p>dir()はロード済みのモジュールしか取得できないし。</p>
            <p>調べたら、ModuleScannerというのを使えばいいというのは分かったので、それを使ってコマンドラインオプションを作るところまではやった。</p>
            <p>次は、そのコマンドラインオプションを使用した際に、対象のモジュールのビルドを実行する処理を作る。</p>
            <p>うまくいけば、新たにモジュールのビルドルールを追加しても、他のところにその処理を呼び出す処理を追加しなくても済む。</p>
            <p>configure時にコマンドラインオプションを追加するだけで、そのビルドルールでモジュールが生成されるようになる。</p>
            <p>また、コマンドラインオプションで指定しなければ、モジュールをビルドしないようにもできる。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/06 22:56</h2>
            <p>って、いかん。何また難しくしようとしてるんだ。</p>
            <p>＊</p>
            <p>まずはC/C++だけ、もしくはC++だけ扱うのでもいいじゃないか。</p>
            <p>まだ一つも完成させてすらいないのに、最初から事を大きくしすぎだ。</p>
            <p>JavaとかPythonとかPerlとか、まだ必要な場面ではないのだ。</p>
            <p>＊</p>
            <p>また迷走して時間ばかりかけてしまうところだった。</p>
            <p>メインのライブラリはどうしよう。また作り直すべきだろうか。</p>
            <p>今度は本格的に処理は丸々使えるが、今のプロジェクトに修正を加える形でもいい気がする。</p>
            <p>しかし、この機会にビルドの仕組みの簡略化もしてしまいたいし。</p>
            <p>それをする場合、やはり作り直すべきな気がする。</p>
            <p>というか、インターフェースライブラリはそのままでいいな。</p>
            <p>いや、ビルドの仕組みの簡略化はインターフェースライブラリもやるけど、それは修正を加える形でいいだろう。</p>
            <p>この際だから、Cのラッパーライブラリも作らず、完全にC++だけの構成にしてしまってもいいかもしれない。</p>
            <p>ラッパーというか、他の言語に同じインターフェースがあると、一方に修正を加えたらそちらにも同じ加えたくなるし。</p>
            <p>コードの量は増えてもできることは増えてないという、効率の悪いことになるし。</p>
            <p>＊</p>
            <p>うむ。C++のインターフェースライブラリ「fg」、実装ライブラリ「sucrose」、ライブラリ利用環境「dropmaker」という3つのプロジェクトから成る構成にするかな。</p>
            <p>あと、ライブラリ利用デモ「fgdemos」の4つか。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/06 22:20</h2>
            <p>結局、C++のライブラリをメインにした方がいい気がしてきた。</p>
            <p>＊</p>
            <p>イベントハンドラの関係で、C言語のライブラリをメインにしているとラッパーライブラリがうまく作れないのだ。</p>
            <p>逆に、C++のライブラリをメインにして、C言語のそのラッパーライブラリにすればうまくいくんじゃないかなぁ、といったところ。</p>
            <p>そもそもC言語のライブラリをメインに持ってきたところで、それを直接使うわけでもないし。</p>
            <p>C言語を直接使ってゲーム作るのとかやりたくないし。</p>
            <p>しかし、その程度で大きく変更をかけるのは場当たりすぎる気がする。</p>
            <p>もうちょっとこう、他の言語との連携周りなのだから、その辺どのように対応するのかを考えてから処理したいところだが。</p>
            <p>現状ではどうあがいてもC/C++などで作られた、lib*.soとか*.dllとかのライブラリしか対応できないわけで。</p>
            <p>例えば.jarやら.pyやら.pl、.pmやらも使えるようにしてみたいところ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/03 21:52</h2>
            <p>ウィンドウ制御処理、大体はできたのだが。</p>
            <p>＊</p>
            <p>ウィンドウ内全てについて再描画処理をリクエストする処理についてはまだ。</p>
            <p>XGetGeometry()の処理が完了せず止まってしまうことがある。原因はまだ不明。</p>
            <p>おそらく、このへんも昔に通った道のはずなのだが。</p>
            <p>もしかしたら、xorg-serverのバージョンアップが影響しているかもしれないが、多分そんな大げさなことはないだろう。</p>
            <p>というか、この関数本当に必要だろうか。なんとなく必要な気がする、というだけで存在させている感は否めない。</p>
            <p>やりたいなら、ウィンドウサイズ変更イベントのイベントハンドラを設定しておいてウィンドウサイズを取得し、それを使ってウィンドウ内全てに再描画リクエストを投げてもいいのだ。</p>
            <p>ウィンドウの位置についても、どうもxlibではうまいこと制御できない感があるので、というか前にもこれは体験した気がするので、ウィンドウの位置は制御できないようにした。</p>
            <p>これと同じように、関数自体を消すという対応でいい気もする。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/02 23:25</h2>
            <p>イベント発生時のイベントハンドラ呼び出し処理を追加している。</p>
            <p>＊</p>
            <p>イベントハンドラの設定とかその辺については、ウィンドウ制御側からは触らんわけだし、イベント発生時の処理を書いた後でもいいかなって感じで。</p>
            <p>イベント発生時の処理はリセット前のプロジェクトとほぼ同じで大丈夫なので、さくっと片付けてしまいたいところ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/01 19:12</h2>
            <p>おかしいな、イベントハンドラの形式が古い。</p>
            <p>＊</p>
            <p>set形式は色々だめだと判断して、add/remove形式に変えたはずなのだけれど、その形式にしたソースが見つからない。</p>
            <p>そんなもんだから、今のAPIはset形式になってしまっている。</p>
            <p>直さないといかんなー</p>
            <p>＊</p>
            <p>ウィンドウ制御については、とりあえず表示と、イベント処理スレッドの起動までは作った。</p>
            <p>で、イベントハンドラの呼び出しとかが必要になってきた時点で、前述の問題に気が付いた感じ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/30 19:45</h2>
            <p>終了関数については、結局後回し。</p>
            <p>＊</p>
            <p>xlibを使ったウィンドウ制御について実装を始めている。</p>
            <p>リセット前のプロジェクトを参考にしているものの、前の物よりは分かりやすいものにしようと考えながら記述している。</p>
            <p>その中で、ラムダ関数への変数のムーブキャプチャを使ったのだが、なんかエラーが消えないと思ったら、どうやらconstでキャプチャされるらしい。</p>
            <p>参照キャプチャではそんなことはなかったようなのだが。ふしぎ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/29 20:40</h2>
            <p>ひとまず、初期化処理呼び出しの位置変更は完了した。</p>
            <p>＊</p>
            <p>しかし、終了処理についてはまだ考え中。</p>
            <p>初期化関数の引数に、関数ポインタの参照を渡してそれに終了関数のアドレスを設定するという方法はあまりよくない気がする。</p>
            <p>直感的でないというかなんというか、分かりにくいというか。</p>
            <p>そんな回りくどい方法を取るくらいなら、設定ファイルに初期化関数名と終了関数名のペアを書いておくとかの方がいい気がする。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/26 19:20</h2>
            <p>どうも暴走していたようだ。</p>
            <p>＊</p>
            <p>昨日書いたことはどうにも浅はかすぎる。終了処理の呼び出しは同じように書くべきではないと思った。</p>
            <p>初期化処理の呼び出しと同じように、終了関数を設定ファイルで指定することで、モジュールをアンロードする前に終了処理を呼び出す、というのは安直だが、安直すぎてだめだ。</p>
            <p>それだと、初期化処理が途中で失敗した場合、どの終了処理を呼び出すべきで、どの終了処理は呼び出すべきでないのか。</p>
            <p>こういうのはよく、終了処理は全て絶対に呼び出し、終了処理の中で、初期化してあるなら処理を行ない、初期化していないなら何もしない、と書くべきなどと言われるが、私はそういうのが嫌いなのだ。初期化してないなら終了処理は必要ないのだから、最初から呼び出さない方がすっきりする。</p>
            <p>例えば、初期化処理の引数として関数ポインタの参照を渡しておき、初期化処理が正常終了する場合に対応する終了関数のアドレスを設定する、などすればいい感じになりそう。</p>
            <p>＊</p>
            <p>しかしながら、現状では安直な方法ですら行なうのが困難な状況だ。</p>
            <p>モジュールのアンロード処理で、ロードしたモジュールを表現するvoid*しか情報をもらっていないため、どこかに終了処理の関数名を含めるとかいったことができないのだ。</p>
            <p>構成を間違えた感じがある。モジュールのロード、アンロード処理に、初期化、終了の処理を含めるべきではなかったのだ。</p>
            <p>単純に巻き戻してしまってもいい気がする。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/25 21:00</h2>
            <p>初期化処理できあがり。</p>
            <p>＊</p>
            <p>次は、初期化処理と共通の部分は共通化して終了処理の呼び出しを作成する。</p>
            <p>厳密には、現時点ではまだ必要ないと思われるが、ほぼ同じ処理なわけだし、ちょっとしたらすぐ必要になると思うし。</p>
            <p>作っておいて損ないだろう、といったところ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/24 23:36</h2>
            <p>初期化処理の追加、途中までできた。</p>
            <p>＊</p>
            <p>初期化処理を走らせるところはできたので、次は走らせる処理を指定するところ。</p>
            <p>それが出来たら、終了処理についても同じように追加する。</p>
            <p>しかし、ModuleInfoとModuleKeyを分けている意味がないような気がする。</p>
            <p>一緒にしちゃってもいいんじゃないかな。</p>
            <p>＊</p>
            <p>ビルドの仕組み、簡略化すべきかも。</p>
            <p>現状では、あるモジュールについて、configureする時に実装を指定することで、その実装を使ったモジュールをビルドするのだが、モジュールの名前を別にすることで、複数の実装を同時に存在できるようにしようかと。</p>
            <p>現状では、例えばウィンドウ管理のモジュールは、linux用のxlibを使った実装でも、windows用のwin32を使った実装でも、作られるモジュールの名前はlinuxならlibfg-window.so、windowsならfg-window.dllになる。</p>
            <p>でも、例えばxlibを使った実装ならfg-window-xlibとか、win32を使った実装ならfg-window-win32とかにすれば、実装が異なる複数のウィンドウ管理モジュールを共存させることができる。</p>
            <p>その環境はビルドできない実装の場合は、configureでビルドしないように指定すればいいのだし。</p>
            <p>この変更をすることで、多分ビルドの仕組みは今より簡単になるはずなのだ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/19 20:02</h2>
            <p>困った。</p>
            <p>＊</p>
            <p>初期化が必要なモジュールについての考慮が足りていなかった。</p>
            <p>今まで通り、各OSに用意されている機能を使ってもいい気がするが、あれはあまりよくない。</p>
            <p>初期化時に処理が失敗した場合にどうするとか、そういったことができない。多分。</p>
            <p>きちんと調べたわけではないのだが、少なくともwindowsでは関数が1つ固定、関数名すら固定だし、それを使うくらいならば自分で機能を作ってしまった方がいい気がする。</p>
            <p>今のところの考えでは、パッケージ設定に記述するモジュールの設定に、初期化関数を指定できる形にしようかと考えているがどうなんだろう。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/18 20:47</h2>
            <p>総ソースファイル行数が1000行ほど減った。</p>
            <p>＊</p>
            <p>今まで、共通化できそうだけどめんどうなので放置していた場所を、マクロで共通化した結果、そんな感じになった。</p>
            <p>これで、あとは実装部分をリセット前のプロジェクトから持ってくればウィンドウを扱えるようになるだろう。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/17 20:50</h2>
            <p>というわけで、ウィンドウの対応を始めた。</p>
            <p>＊</p>
            <p>リセットする前のプロジェクトからファイルを持ってきて、ちょっと修正を加えて使えるようにしたりなど。</p>
            <p>若干インターフェースやマクロの仕様が違うので、完全にそのまま使うわけにはいかない。</p>
            <p>一気にファイル数が増え、総ソースファイル数が300に迫る勢い。</p>
            <p>明日には300を越すだろう。</p>
            <p>しかし、メインウィンドウの生成はどこでやるべきか。</p>
            <p>コンテキストに参照を持たせることは決まっているが、コンテキスト生成処理に混ぜるか、生成後に参照をコンテキスト生成処理に渡すか。</p>
            <p>前者でいい気がするのだが、なんかしっくりこないような。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/16 19:08</h2>
            <p>とりあえず、コマンドライン引数対応は終えたのだが。</p>
            <p>＊</p>
            <p>この次、本当にパスの扱いについてやるべきだろうか。後回しでもいい気がしてきた。</p>
            <p>いい案がぱっと浮かばないし、なによりやる気があまりしないのだ。</p>
            <p>それよりも、リセットする前のプロジェクトには実装されていたウィンドウや入力機器、音声機器の管理機能をサクサクッと実装して、試しにゲームでも作ってみるべきな気がする。</p>
            <p>ゲームを作らんと、いつまで経っても話が進まんのだ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/12 20:23</h2>
            <p>どうにも作業速度が思うように上がらないと思ったら案の定だった。</p>
            <p>＊</p>
            <p>そんなわけでまだ出来上がっていないが今日は疲れた。</p>
            <p>このまま出来上がるまで続行するというのは昔はよくやっていた気もするが、これをするとその後一層気分がよくなくなるのだ。</p>
            <p>よくない連鎖は発生する前に止めるに限る。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/11 20:00</h2>
            <p>とりあえずコマンドライン引数対応を始めた。</p>
            <p>＊</p>
            <p>一応、リセットする前のプロジェクトでは実装されていた機能なので、大体はそこから持ってくればいいだけなのだが。</p>
            <p>その後の処理は完全に1から書くことになるわけで、出来上がるのは早くて明日だろうな。</p>
            <p>今日はこれ以上続けるとだらだらしちゃうからやめやめ。</p>
            <p>TODOコメントをいくつか、ヒントとして追加しておしまい。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/10 22:10</h2>
            <p>パスの扱いについてまだ考え中。</p>
            <p>＊</p>
            <p>今日はバグの修正やら細かい変更などをしていた。</p>
            <p>パスについては後回しにして、先にコマンドライン引数で起動するプログラムの指定をできるようにしてしまった方がいいかもしれない。</p>
            <p>実際に必要になる場面を先に作ってしまえばイメージしやすそうな気がする。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/09 19:40</h2>
            <p>静的リンクしていたライブラリを、モジュールとして動的リンクして扱うように修正した。</p>
            <p>＊</p>
            <p>当初の予定では、静的リンクしているライブラリ5つを全て動的リンクさせたかったのだが、よく考えたらそのうち4つはモジュール管理処理から使っているので分離できず、結局1つのライブラリしか取り外すことができなかった。</p>
            <p>しかしながら、そのおかげで奇妙な処理の仕方をしていた箇所を削除することができたし、成果は悪くない。イメージのサイズも小さくなったようだし。</p>
            <p>複数のライブラリを修正する予定だったのでマクロとかも作って修正しやすくしたのだが、結局1つのライブラリしか修正できなかったので、ちょっと大げさになってしまった感はある。</p>
            <p>とはいえ、今後別のライブラリをリンクさせる予定があるので、その時には役立つかも。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/08 19:26</h2>
            <p>プログラム起動前のモジュール読み込みについても、依存関係を解決した上で読み込むようにした。</p>
            <p>＊</p>
            <p>これにより、プログラム起動前に読み込むモジュールについても、別のモジュールに依存させることが可能になった。</p>
            <p>今までは対象のモジュールのみ読み込む形だったので、他のモジュールに依存させていると正しく動作しなかったが、それが解決された。</p>
            <p>現状では、プログラム起動前に読み込むモジュールは他のモジュールに依存できないのを前提とした書き方をしていたはずなので、その辺は修正していくべきだろうな。</p>
            <p>＊</p>
            <p>次はコマンドライン引数で起動するプログラムの指定をできるようにしたいところだが、これをするとなるとパスの扱いをきちんと考えんと。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/06 13:18</h2>
            <p>おとといバージョン上げて、昨日プログラム起動前に読み込むモジュールのどうのこうのの前準備をした。</p>
            <p>＊</p>
            <p>というのを昨日書けばよかったのに忘れていた。</p>
            <p>今日明日はあまり作業しないようにする。</p>
            <p>のんべんだらりとなってくると、余計にやる気が減退してしまってよくない。</p>
            <p>そんな感じで、土日やら祝日やら、あとは平日の夜とかも、意図的に作業しないようにしている。</p>
            <p>せいぜい、なんか思い付いたらメモしておく程度。</p>
            <p>その方が、作業中集中できるし気分的にもいい気がするのだ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/04 17:16</h2>
            <p>やることは色々思い付くが、ここらでバージョンを上げて区切っておくべきだろうか。</p>
            <p>＊</p>
            <p>依存解決ありのモジュールロード処理のプロトタイプは出来上がっているわけだし。</p>
            <p>今後、コマンドライン引数で起動するプログラムを指定したりとか、プログラム起動前に読み込むモジュールも依存解決ありの形にしたりだとか、その他諸々を予定している。</p>
            <p>後者の機能を実装するために、ファイルの配置を変えたりしていたが、そろそろバージョンを上げてネット上のリポジトリにpushしておくべきだろうな。</p>
            <p>調子が良さそうに思える時ほど、冷静にならねば無意識のうちに暴走、迷走して失敗するのだ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/03 19:59</h2>
            <p>あるモジュールが複数モジュールから依存されている場合に、無駄にメモリ食ったり無駄な処理したりしないように修正した。</p>
            <p>＊</p>
            <p>簡単なデモプログラムを作ってみて、問題なく動作するのを確認した。</p>
            <p>しかし、必要なモジュールを依存モジュールリストから外しておいて、動作に失敗するはずのプログラムが普通に動いた、というのが起きた時はびびった。</p>
            <p>原因を調べたら、プログラムを実行するコアプログラム側に、必要なモジュールの処理が含まれており、プログラムがコアプログラム側の処理を呼び出しているために、普通に動いているように見える、ということだった。</p>
            <p>しかしコアプログラムはシンボルを全くエクスポートしていないはずなのに、なぜプログラム側から呼び出せているのか謎だったが、コアプログラムのリンク時に-rdynamicオプションを指定しているのがまずかったらしい。</p>
            <p>このオプションを付けているとバックトレースの表示を詳しくできるため、デバックビルドのリンク時には付けていた。</p>
            <p>しかしこのオプションの機能は「生成したファイル内に動的リンク用のシンボルを残す」というものであるため、今回のような問題が発生してしまったようだ。</p>
            <p>で、バックトレースを見る機会とか今のところほぼないし、別にいいかということで問題のオプションを使わないことで対応した。</p>
            <p>そもそもgrep backtraceとかやっても1件もヒットしなかったし、この記述自体が以前に作っていたプログラムの名残だったと思われる。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/02 18:44</h2>
            <p>やたー動いたー。</p>
            <p>＊</p>
            <p>もうちょい処理を追加する必要があるが、とりあえず動作するのを確認できた。</p>
            <p>依存モジュールのロードを行ない、プログラムを起動させることに成功。</p>
            <p>依存モジュールの指定方法をもうちょい種類増やしたりだとか、そもそも今のインターフェースで他の言語のプログラムを扱えるのかなど問題は色々あるものの、とりあえず一段落した気がする。</p>
            <p>あるモジュールが複数のモジュールから依存されている場合の処理をまだ書いてないので、それは追加する必要がある。</p>
            <p>それにしたって、効率的な処理にならない、というだけであり、想定では問題なく動作するはずだが。</p>
            <p>その辺確認するためにも、デモプログラムをいくつか作ってみる必要がありそう。</p>
            <p>モジュールの依存関係が循環してしまっている場合、現時点では正しく動作しない。多分無限ループみたくなって、そのうちスタック食い潰して落ちる。</p>
            <p>そもそも循環した依存関係というのが、他の言語とかでも常に許容されるのか分からんし、動作するように対応するかどうかはびみょう。循環を検出して、起動失敗にしたりなど、なんらかの対策は必要だろうけど。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/01 15:36</h2>
            <p>もうめんどいから過去ログに分割しなくてもいいんじゃないかな。</p>
            <p>＊</p>
            <p>パッケージシステムの暫定的な根幹ができあがりそうな感じ。</p>
            <p>＊</p>
            <p>また今日も、私の頭の中から湧き出た何かを形にするべく、その正体不明の何かを解析する作業。</p>
            <p>妄想なんだろうけど、見てはいけない何かを見つめ続けてしまっている気がする。</p>
            <p>そのうちもっと頭おかしくなるのではないだろうか。</p>
            <p>＊</p>
            <p>ポケモンエメラルドで捕まえられるポケモン全部捕まえた。</p>
            <p>あとはルビーやらサファイアやらでしか出現しないポケモンを捕まえて送り込まねば、ホウエン図鑑を埋めることはできない。</p>
            <p>送り込むだけならそれぞれのカートリッジと、安価で購入したゲームキューブとポケモンボックスを持っているのでできるのだが、通信ケーブルがないため通信進化ができない。</p>
            <p>アドバンスのケーブル、通販だと中古でも新品並みの値段になってたりするから困る。新品が定価の2、3倍とか頭おかしいと思う。手を出しがたい。</p>
            <p>＊</p>
            <p>さて、こわいこわい言ってないで作業せんと。クトゥルフ神話じゃないんだから未知に対する恐怖なんてあるものか。</p>
        </div>
<!--過去ログ用
        <hr />
        <div>
            <p><a href="/">戻る</a></p>
        </div>
-->
<!-- ここから過去ログ時に削除 -->
        <hr />
        <div>
            <h2>過去ログ</h2>
            <p><a href="201405.html">201405</a></p>
            <p><a href="201404.html">201404</a></p>
            <p><a href="201402.html">201402</a></p>
            <p><a href="201401.html">201401</a></p>
            <p><a href="201312.html">201312</a></p>
            <p><a href="201311.html">201311</a></p>
            <p><a href="201310.html">201310</a></p>
            <p><a href="201309.html">201309</a></p>
            <p><a href="201308.html">201308</a></p>
            <p><a href="201307.html">201307</a></p>
            <p><a href="201306.html">201306</a></p>
        </div>
<!-- ここまで -->
        <div id="for-nostylesheet">
            <hr />
            <img src="images/uni.png" />
        </div>
    </body>
</html>
