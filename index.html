<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>tekuto.net</title>
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-23511137-1"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'UA-23511137-1');
        </script>
    </head>
    <body>
<!--過去ログ用
        <div>
            <p><a href="/">戻る</a></p>
        </div>
-->
<!-- ここから過去ログ時に削除 -->
        <h1>tekuto.net</h1>
        <div>
            <p>メール:g.tekuto@gmail.com</p>
            <p><a href="http://twitter.com/tekuto" target="_blank">twitter</a></p>
        </div>
<!--テンプレート
        <hr />
        <div>
            <h2>YYYY/MM/DD hh:mm</h2>
            内容
        </div>
-->
<!-- ここまで -->
        <hr />
        <div>
            <h2>2019/03/13 14:00</h2>
            <p>ユニークポインタ周りの新しい仕様を模索していた。</p>
            <p>＊</p>
            <p>本当は画面周りを進めようと思っていたのだが、謎のタイミングでSEGVで死んでしまう原因が、データ解放にローカルのfree()を呼ぶ予定のはずが標準関数のfree()が呼ばれていたため、とかいうふざけた記述ミスが原因だったので気が抜けてしまった。</p>
            <p>なかなか原因を特定できなかったので、無駄に気力を消耗してしまったのだ。</p>
            <p>＊</p>
            <p>で、ユニークポインタだけど、色々と問題はあるのだがまず記述がC++風になっていないことだ。</p>
            <p>C++風と言っていいのかは分からないが、要するにメンバ関数の利用ができない、ということである。</p>
            <p>例えばウィンドウを生成し、生成したウィンドウに再描画要求を投げる、という記述を現状の構成でやると以下の通りだ。</p>
            <p>＊</p>
            <p>auto windowUnique = fg::newWindow( ... );</p>
            <p>auto &amp; window = *windowUnique;</p>
            <p>fg::repaint( window );</p>
            <p>＊</p>
            <p>fg::newWindow()はfg::Windowという型のユニークポインタ、fg::Unique&lt; fg::Window &gt;を返す。</p>
            <p>fg::Unique&lt; fg::Window &gt;というのは、大まかにはstd::unique_ptr&lt; fg::Window * &gt;のエイリアスである。</p>
            <p>実際にはデリータも設定しているが、細かいことはともかく破棄時に自動でfg::free()という破棄関数を呼び出して破棄する。</p>
            <p>この記述だと、名前空間の記述が2度登場していてよくない。</p>
            <p>この例だとfgと短いからいいが、非常に長い名前空間だと記述がごちゃごちゃして分かりにくくなる。</p>
            <p>using namespaceを使用すればそこにまとめられるだろ、という意見もあるだろうが、私としてはあまり頻繁に使いたくない機能だ。</p>
            <p>関数の記述を見た時、一目でどこの名前空間の関数なのか、というのが分かりにくくなってしまう。</p>
            <p>それ以外にも、この記述だとrepaint()とwindowの関連性がいまいち低いように思う。</p>
            <p>fg::Windowの関数であるというのなら、window.repaint()の方が分かりやすい。</p>
            <p>もっと言うなら2行目の、わざわざユニークポインタを参照にする記述も書きたくない。</p>
            <p>よって、大体以下のような記述にしたいのだ。</p>
            <p>＊</p>
            <p>auto window = fg::Window( ... );</p>
            <p>window.repaint();</p>
            <p>＊</p>
            <p>しかし、単純にそうするわけにもいかない。</p>
            <p>コンストラクタやメンバ関数を記述するということは、その型の定義を明確にする必要があるが、それができないのだ。</p>
            <p>なぜなら、fg::Windowのデータ構造は一定ではないからだ。</p>
            <p>環境によって実装を変えるし、またバグの修正や仕様変更の際にfg::Window利用側で再コンパイルの必要がないように、利用側には型の宣言のみ提供し、詳細な定義を提供したくない。</p>
            <p>詳細なデータ構造の記述を避ける場合、その型にはコンストラクタもメンバ関数も記述できなくなる。</p>
            <p>まるでCのような、メンバ関数を一切使用しない構成にしていた理由はそこにあるのだ。</p>
            <p>＊</p>
            <p>fg::Unique&lt;&gt;は私としても知恵を搾り、できるだけ利用側に負担をかけないような構成にしたつもりだ。</p>
            <p>以前なら、生成処理は以下のように書かなければならなかった。</p>
            <p>＊</p>
            <p>auto windowUnique = fg::unique( fg::newWindow( ... ) );</p>
            <p>＊</p>
            <p>現在の記述は、これと処理は全く変えず、よりシンプルにした記述できるようにした形なのだ。</p>
            <p>しかし、それでも不都合が出てきた。</p>
            <p>先ほど挙げた問題以外の問題だ。</p>
            <p>fg::Unique&lt;&gt;という名前はfg内の型に対して提供する型だが、fgを利用するプロジェクトでも同様の機能が使えるように、マクロで手軽にUnique&lt;&gt;を記述できるようにしている。</p>
            <p>kasuteraでもその機能でユニークポインタを使おうとしたのだが、そこで問題が発生した。</p>
            <p>kasuteraでは名前空間を複数に分けていたのだが、ユニークポインタの定義を1つにまとめようとすると不自然な記述になってしまうのだ。</p>
            <p>例えば、以下のような記述をしたとする。</p>
            <p>＊</p>
            <p>auto aObjUnique = kasutera::a::newObj();</p>
            <p>auto bObjUnique = kasutera::b::newObj();</p>
            <p>＊</p>
            <p>どちらも生成関数だが、これらの生成関数が返す型をそれぞれkasutera::Unique&lt; kasutera::a::Obj &gt;、kasutera::Unique&lt; kasutera::b::Obj &gt;にしようとすると、破棄関数は両方ともkasutera::free()になる。</p>
            <p>生成関数はkasutera::a::newObj()なのに、破棄関数はkasutera::free()。</p>
            <p>これはちぐはぐでよくない。</p>
            <p>関数の宣言をする際にも、以下のようになってしまう。</p>
            <p>＊</p>
            <p>namespace kasutera::a {</p>
            <p>struct Obj;</p>
            <p>kasutera::Unique&lt; Obj &gt; newObj();</p>
            <p>}</p>
            <p>namespace kasutera {</p>
            <p>void free( a::Obj &amp; );</p>
            <p>}</p>
            <p>＊</p>
            <p>本来なら、以下のようになるべきだ。</p>
            <p>＊</p>
            <p>namespace kasutera::a {</p>
            <p>struct Obj;</p>
            <p>Unique&lt; Obj &gt; newObj();</p>
            <p>void free( a::Obj &amp; );</p>
            <p>}</p>
            <p>＊</p>
            <p>しかしそのためには、各名前空間ごとにUnique&lt;&gt;を用意する必要がある。</p>
            <p>いくらマクロを使っていて手軽とはいえ、至るところにユニークポインタの定義があるというのは不自然極まりなく、気持ちが悪い。</p>
            <p>以前からもっと改良するべきだと考えていたが、不都合が出てきてしまっては本腰を入れて取り組む必要がある。</p>
            <p>＊</p>
            <p>ここまでの内容から、要件をまとめると以下の通りだ。</p>
            <p>・データへのアクセスはメンバ関数を用いる</p>
            <p>・定義1つでどの型でも利用可能</p>
            <p>また、fg::Unique&lt;&gt;で満たしていた要件は以下の通り。</p>
            <p>・データ構造を隠蔽可能</p>
            <p>・できるだけシンプルに記述できる</p>
            <p>・必要な関数（破棄関数）が存在しない場合、コンパイルエラーで検知できる</p>
            <p>・std::move()やstd::swap()といった標準関数を利用可能</p>
            <p>これら全ての要件を満たす仕組みを構築する必要がある。</p>
            <p>そしてそれは実際形にできた。</p>
            <p>いい加減長すぎるので、それについてはまた次回。</p>
        </div>
        <hr />
        <div>
            <h2>2019/03/09 02:45</h2>
            <p>パソコンを新しくすることにした。</p>
            <p>＊</p>
            <p>能力的には問題ないのだが、大きさとか重さとか、その辺がよくない。</p>
            <p>私のパソコンはパーツを集めて組み立てた、いわゆる自作パソコンだ。</p>
            <p>作った当時はただなんとなくでかいのに憧れがあったので、それを反映したかのようにでかくて重い。</p>
            <p>大きいと自然と空冷ファンも大きいものになり、空冷ファンというのは大体大きいほど静かになりやすいので、静音性はなかなか気に入っている。</p>
            <p>また、拡張性が高く、後々何か追加することもやりやすく、その大きさ故にパーツのサイズによって干渉を起こす、ということも起きにくい。</p>
            <p>しかしながら、大きく重いととりあえず動かしにくい。</p>
            <p>今はゲーム専用に使っている、少し大きめのディスプレイにつなぎたくても現状では難しい。</p>
            <p>ディスプレイが多少離れたところにあるため、パソコンを動かさなければならないからだ。</p>
            <p>大きく重いので、動かすだけでも一苦労。</p>
            <p>他にも掃除が面倒というのがあるが、これは大きさというより使ってるケースが悪いんだろうな。</p>
            <p>＊</p>
            <p>静音性については、あまり気になるようなら回転数を落とすなり静音性を売りにしている物に買い替えるなりで対策できる。</p>
            <p>拡張性なんてのは、大抵の場合何に使うかが明確でない場合に後から対応するためのものであり、使用目的が明確であれば必要性は薄く、デッドスペースにしかならない。</p>
            <p>実際、今のマシンはハードディスク6台搭載できるスペースがあるが全て空だ。</p>
            <p>よって今のマシンのような大きさは必要ないと判断。</p>
            <p>必要な構成をぴったり収めた、移動させやすいパソコンを作ることにした。</p>
            <p>＊</p>
            <p>移動をしやすくするため、マザーボードのサイズは小さいMini-ITX。</p>
            <p>より小さいMini-STXのベアボーンというのもあったが、さすがにUSBポートの数が少なすぎたり音声がオプションだったりと不便そうだったのでパス。</p>
            <p>今のマシンからパーツをいくらか引き継いで安く済ませるのも考えたが、CPUとメモリの規格が1つ古いようだ。</p>
            <p>CPUはAMDのAM3+、メモリはDDR3。</p>
            <p>今の主流はAM4にDDR4で、互換性はないため流用できない。</p>
            <p>さすがにストレージは可能だが、そのくらいだ。</p>
            <p>私はAMDとRadeonが好きなのだが、最近のAMDのGPU搭載CPUに搭載されてるGPUの性能はなかなか馬鹿にできないらしい。</p>
            <p>オンボードと言えばまずゲームには向かない、とりあえず表示ができればいいもの、という印象だったものだが、最近のは新しめの3Dゲームも割と動かせるのだとか。</p>
            <p>というか、今のマシンに積んでいるびみょうな性能のRadeonグラボよりも性能がいいらしい情報もある。</p>
            <p>私はパソコンで最新鋭のゲームなんてやらないし、AMDの比較的安価なCPUでグラボも必要ないとなれば、かなり費用が抑えられる。</p>
            <p>今回購入を決めたのも、実はその辺の理由が大きい。</p>
            <p>グラボを追加しなくて済むなら、ケースのサイズもかなり小さいもので大丈夫だろうし。</p>
            <p>＊</p>
            <p>というわけでCPUにRyzen5 2400Gを用いた構成のパーツを注文し、今日全部届いた。</p>
            <p>費用はおよそ6万円。</p>
            <p>とはいえ、小さいサイズ故にパーツの干渉などが不安なので、絶対に必要でまず干渉も起こさないと思われるものに絞ってある。</p>
            <p>後々光学ドライブとハードディスクを足す予定。</p>
            <p>ハードディスクはケースに3.5インチベイしかないが2.5インチのものを積む予定なので、マウンタなんかも必要になるだろう。</p>
            <p>その辺は実物を見ながら決めていく。</p>
            <p>土日に組み立て、動かせるようにしようと思う。</p>
        </div>
        <hr />
        <div>
            <h2>2019/02/06 03:00</h2>
            <p>もやもやしっぱなしだが、とりあえずReenterEvent対応。</p>
            <p>＊</p>
            <p>明日にはEnterEventを削除し、さっそくReenterEventを使用した処理を作る予定。</p>
        </div>
        <hr />
        <div>
            <h2>2019/02/02 03:00</h2>
            <p>fg::StateEnterEventとfg::StateLeaveEventの仕様を変更することにした。</p>
            <p>＊</p>
            <p>今までこれらのイベントは、fg::Stateをプッシュした時やポップした時に発生していた。</p>
            <p>プッシュ時には、まず元のfg::Stateについてのfg::StateLeaveEventが発生する。</p>
            <p>次にプッシュしたfg::Stateについてのfg::StatePushEvent。</p>
            <p>最後にプッシュしたfg::Stateについてのfg::StateEnterEvent、という順だ。</p>
            <p>ポップ時には元ステートについてのLeaveEvent、PopEvent、ポップ後のステートについてのEnterEvent、という順に発生する。</p>
            <p>＊</p>
            <p>この仕様を変更して、プッシュ時におけるEnterEventと、ポップ時におけるLeaveEventを発生しないようにしようと思う。</p>
            <p>1つのイベントが複数異なる状況で発生することで、扱いにくくなっているように思うのだ。</p>
            <p>現在の仕様では、ポップ時に発生するEnterEventは処理したいけど、プッシュ時に発生するEnterEventは無視する、といったことができない。</p>
            <p>そもそも、プッシュ時のEnterEventや、ポップ時のLeaveEventなんて無くても問題ないのだ。</p>
            <p>プッシュ時はPushEvent、ポップ時はPopEventで代用できる。</p>
            <p>なぜ無駄なものが付いていたのかと言えば、EnterEventとLeaveEventでリソース管理を手軽にしようとしてた、というのが主目的だった気がする。</p>
            <p>EnterEventでリソースの確保、LeaveEventでリソースの解放を行うようにすれば、ステートが有効になるタイミングでリソースが確保され、またステートが無効になるタイミングでリソースが解放される。</p>
            <p>しかし、そのようなやり方は少々安直すぎたように思える。</p>
            <p>そのステートがプッシュされて有効になった、という状況と他のステートがポップされてステートが有効になった、という状況を完全に同一に捉えてしまうのはどうかと思う。</p>
            <p>実装するにしたって、その2つの状況で同じ処理をさせる場合、処理を関数化しておいて各状況から同じ関数を呼び出す、という形にするべきだろう。</p>
            <p>＊</p>
            <p>というわけで、EnterEventはポップ時、LeaveEventはプッシュ時にしか発生しないようにする。</p>
            <p>そのような挙動の都合上、EnterEventについては名前も変えて、ReenterEventにしようと思う。</p>
            <p>＊</p>
            <p>それとは直接関係ないんだけど、ReenterEventで直前のステートを特定できるデータを取得できるようにしようと思う。</p>
            <p>ステートの管理はスタック構造により、あるステートに遷移した後元のステートに戻る、という関数のような、縦のつながりとでも呼べばいいのか、そのような挙動は表現できるようになっている。</p>
            <p>問題は、あるステートから別のステートに遷移する、というGOTOのような挙動の表現だ。</p>
            <p>＊</p>
            <p>現状絶対に表現できない、というわけではない。</p>
            <p>あるステートをポップし、直後に別のステートをプッシュしてやればいい。</p>
            <p>問題はそれをどこでやるのか、ということだ。</p>
            <p>ステート内に、別のステートへの遷移処理を記述してしまうのはまずい。</p>
            <p>ステートの遷移が1回に留まらず、何度も遷移を行なうような構成の場合、あちこちに遷移処理が書かれることになりとても把握できなくなってしまう。</p>
            <p>まさにGOTOの濫用によるスパゲッティコード状態になってしまうことだろう。</p>
            <p>＊</p>
            <p>そこで考えたのは、管理ステートという概念だ。</p>
            <p>管理ステート自体は画面の描画やコントローラの入力などの処理は行なわない。</p>
            <p>管理ステートは、別のステートへの遷移のみを行う。</p>
            <p>管理ステートがプッシュされたら、管理ステートのPushEventでステート1に遷移する。</p>
            <p>ステート1の処理が終了し、ポップされたら管理ステートのReenterEventでステート2に遷移する。</p>
            <p>ステート2が終了したら次はステート3に、といった具合だ。</p>
            <p>この構造なら、遷移処理は管理ステートに集約される。</p>
            <p>で、このような構造を実現する場合、ReenterEventでは直前のステートを特定できないといけないわけだ。</p>
            <p>ステートに対応する列挙型を用意し、それを管理ステートに持たせて現在のステートの把握に使う、という手もあるだろうけどどう考えてもバグの温床になるし。</p>
            <p>他にもっといい方法があればいいのだが、思い付かないものは仕方がない。</p>
        </div>
        <hr />
        <div>
            <h2>2019/01/31 15:10</h2>
            <p>記事を年単位で分割した。</p>
            <p>＊</p>
            <p>編集はvimでやってるけど、開くのに時間かかるのがいやだったので。</p>
            <p>前は月単位で分けてたけど、正直そんな頻繁に分割作業したくないので年単位にした。</p>
            <p>＊</p>
            <p>skiaに対応するために、OpenGLコンテキスト周りを修正した。</p>
            <p>skiaではステンシルバッファが必要だそうだが、現状ではステンシルバッファのサイズが0でサイズ指定もできなかったので、その辺のパラメータを設定できるようにした。</p>
            <p>また、skiaで生成した画像をテクスチャとして扱う、みたいなことをするにはskia用のコンテキストは別に用意した方がよさそうだが、その場合コンテキスト間でリソースを共有できた方がいい。</p>
            <p>なので、コンテキスト間のリソース共有もできるようにした。</p>
            <p>＊</p>
            <p>これでkasuteraの作り直しに入れるかな。</p>
        </div>
        <hr />
        <div>
            <h2>2019/01/26 03:10</h2>
            <p>skiaを使った簡単な描画処理は書けた。</p>
            <p>＊</p>
            <p>最初の生成処理はあれでいいのか不安だが、ヘッダファイルを見ても他の関数は見当たらないし、多分いいのだろう。</p>
            <p>書いてみた感じからすると、fgインターフェースにskia用の関数を追加するとか、そういうものは必要なさそうだ。</p>
            <p>バックエンドにOpenGLを使用する場合の関連付けも、カレントコンテキストに対してのみ行なわれるため、fg::GLContextに対して直接なにかしたり、といった処理は必要ない。</p>
            <p>skiaをモジュールとして扱うために、設定ファイルを追加すれば問題なく扱えそう。</p>
        </div>
        <hr />
        <div>
            <h2>2019/01/25 14:55</h2>
            <p>例の仕様変更については対応済み。</p>
            <p>＊</p>
            <p>テストについても、初期化関数を比較することで目的の画面に遷移していることを確認できるようになった。</p>
            <p>で、kasuteraを作り直そうと思ってるけど、その前にグラフィックライブラリを導入することにした。</p>
            <p>画面に表示する画像を用意するのが面倒なのだ。</p>
            <p>1つや2つで済むならいいけど、これから画面作るたびにその画面を画像を描かないといけない、というのは面倒で気が滅入る。</p>
            <p>なので、フォントファイルを参照して文字を描画したりなどできるライブラリを導入することにした。</p>
            <p>＊</p>
            <p>適当に検索かけて、まず見つけたのはcairo。</p>
            <p>このマシンにも導入されていて、ウィンドウマネージャのawesomeやwebブラウザのfirefox、chromeなどから使われているようだ。</p>
            <p>既に導入されているというのは手が出しやすくていい。</p>
            <p>更に調べていくと、skiaとかいうのも見つけた。</p>
            <p>androidやchromeの描画に使われているらしい。</p>
            <p>chromeはcairoにも依存してるんだけど、使うライブラリを切り替えたりできるんだろうか。</p>
            <p>chromeだけでなくfirefoxでも使われているようだ。</p>
            <p>cairoとはなんだったのか。</p>
            <p>＊</p>
            <p>ともかく2つのライブラリが見つかった。</p>
            <p>skiaの方が高速だの、有名なソフトウェアで使われててフィードバックが多いから開発が進んでるだのとskiaを評価する声が多いように思えるので、とりあえずskiaを使ってみようと思う。</p>
            <p>思ったのはいいのだが、skiaのサンプルコードがあまりネットに落ちてない。</p>
            <p>必死に色々調べた結果、skiaのリポジトリ内に参考になりそうなソースファイルがあった。</p>
            <p>それを見ながら、実際に動作するコードを自分で書いてみるとしよう。</p>
        </div>
        <hr />
        <div>
            <h2>2019/01/21 16:10</h2>
            <p>ちょっと詰まってる。</p>
            <p>＊</p>
            <p>画面遷移についてのテストの記述が直接的でなく、私はとても不満げだ。</p>
            <p>現状、特定の画面に遷移したかどうかのテストは、その画面で行なわれるべき動作が行なわれるか、という反応を見ている。</p>
            <p>その画面に遷移したなら、コントローラをこのように操作することでこういう結果になるはずだ、ということだ。</p>
            <p>はっきり言って回りくどく、非常に分かりづらい。</p>
            <p>テストコードがテスト可能になるまで、必要な記述も多すぎる。</p>
            <p>前述のようにコントローラ操作をテストに含めようとすると、その下準備もテストに記述する必要があるからだ。</p>
            <p>しかも、下準備を書いてなくても動作自体はしてしまう。</p>
            <p>動作するが、テストが成功することはない。</p>
            <p>実装が間違っているのか、テストの記述を間違えているのか見分けがつかず、とても不安になってしまう。</p>
            <p>＊</p>
            <p>これはとてもよくない。</p>
            <p>画面におけるコントローラ操作のテストであれば、下準備をする必要があるのでまだ分かるが、なぜ単なる画面遷移のテストでそれらをしなくてはいけないのか。</p>
            <p>大体、コントローラ操作が行なわれない画面だったら、この方法ではテストできなくなってしまう。</p>
            <p>長々と書いたが、要するにそのfg::Stateがなんの画面のfg::Stateなのか、特定する方法が存在していないのはまずい。</p>
            <p>fg::Stateに、画面を特定するためのデータを持たせる必要がある。</p>
            <p>＊</p>
            <p>テストのためだけに余計な情報を持たせる、ということはしたくないが、テスト以外でも有効に活用できそうな気はする。</p>
            <p>イベント中から画面特定データにアクセスできるようにすれば、1つのイベント関数を複数の画面で使い回し、画面ごとに処理を多少変える、といったことができるようになるだろう。</p>
            <p>そういった処理は複雑化の元だからあんまりやりたくないけど。</p>
            <p>＊</p>
            <p>で、問題は画面特定データとして何を持たせるか、だけど、fg::Stateの初期化関数のアドレスを持たせようかな、と。</p>
            <p>現状扱ってるデータで考えるとそれが妥当、というかそれしかない。</p>
            <p>fg::Stateに文字列で名前を付けるとかIDを振るとかも考えられるけど、扱いきれなくなって後悔する予感しかしない。</p>
            <p>というわけでそんな感じの修正をして、テストも修正しよう。</p>
            <p>＊</p>
            <p>いやむしろ、kasuteraについては作り直した方がいいかもしれない。</p>
            <p>kasuteraは最初テストができず、テストをできるようにするためにbrownsugarを追加し、新たに追加した画面についてはテストができている。</p>
            <p>まだあまり量書いてないし、未テスト部分にもbrownsugarを使ったテストコードを追加しようとしているけど、テストができなかった影響か構成がだめなのだ。</p>
            <p>なんとなくでコードを書いてしまい、処理は一応まともに動いているようだが関数の引数などのインターフェースが悪い。</p>
            <p>簡単に言えば扱いにくい、テストがしにくい。</p>
            <p>それを修正してまともな形にすることもできるだろうけど、いっそ最初からテストファーストでまともなものを作った方がよさそう。</p>
            <p>まだあまり量書いてないわけだし。</p>
        </div>
<!--過去ログ用
        <hr />
        <div>
            <p><a href="/">戻る</a></p>
        </div>
-->
<!-- ここから過去ログ時に削除 -->
        <hr />
        <div>
            <h2>過去ログ</h2>
            <p><a href="2018.html">2018</a></p>
            <p><a href="2017.html">2017</a></p>
            <p><a href="2016.html">2016</a></p>
            <p><a href="2015.html">2015</a></p>
            <p><a href="2014.html">2014</a></p>
            <p><a href="2013.html">2013</a></p>
        </div>
<!-- ここまで -->
    </body>
</html>
