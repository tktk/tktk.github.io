<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>tekuto.net</title>
        <link rel="stylesheet" href="style.css" />
        <script type="text/javascript">
            var _gaq = _gaq || [];
            _gaq.push(['_setAccount', 'UA-23511137-1']);
            _gaq.push(['_setDomainName', '.tekuto.net']);
            _gaq.push(['_trackPageview']);

            (function() {
                var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
            })();
        </script>
    </head>
    <body>
<!--過去ログ用
        <div>
            <p><a href="/">戻る</a></p>
        </div>
-->
<!-- ここから過去ログ時に削除 -->
        <h1>tekuto.net</h1>
        <div>
            <p>メール:g.tekuto@gmail.com</p>
            <p><a href="http://twitter.com/tekuto" target="_blank">twitter</a></p>
        </div>
<!--テンプレート
        <hr />
        <div>
            <h2>YYYY/MM/DD hh:mm</h2>
            内容
        </div>
-->
<!-- ここまで -->
        <hr />
        <div>
            <h2>2015/01/23 14:00</h2>
            <p>というわけで、サイトをgithub pagesに移行した。</p>
            <p>＊</p>
            <p>何日か前に書いたような気がしたけど書いてなかったので、経緯を書いておこう。</p>
            <p>gaeのツールが動かんくなった。</p>
            <p>どうもpythonのバージョンとうまく噛み合っていないらしく、バグ報告も上がっているようだけどツールのバージョンアップが来ない。</p>
            <p>現状やってることと言えば静的ページの公開だけだし、記事書いた後にコミットとは別にアップロードコマンド打つのもめんどうなので、github pagesに移行した。</p>
            <p>github pagesなら独自ドメイン使用時にサブドメイン付けなくていいし、サブドメインからリダイレクトさせることもできるので、URLをtekuto.netにできていい感じ。</p>
            <p>今までのwww.tekuto.netにアクセスすれば、tekuto.netにリダイレクトしてくれる。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/23 00:15</h2>
            <p>今週中に終わらせられれば、とか昨日書いたけど早速今日、諸事情により作業できなかった。</p>
            <p>＊</p>
            <p>明日から本気出す。</p>
            <p>でもさすがに明日1日で終わらせるのは無理だろうなぁ。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/21 18:10</h2>
            <p>ベース設定ファイルからベースシステムとシェルについての情報を読み込む処理を書いた。</p>
            <p>＊</p>
            <p>Baroqueのサントラ流しながら作業すると集中できていいな。</p>
            <p>歌が入ってるタイプの曲は、作業中の私にはあまり向かないようだ。</p>
            <p>気が散りやすいというか、ヘッドホンで聞きながら作業すると頭痛くなったりする。</p>
            <p>＊</p>
            <p>さて、ベース設定ファイルに記述する内容はひとまず全て読み込む処理を書いたので、次はそれを元にベースシステムを生成するための情報を生成する処理か。</p>
            <p>まずはどこからだろうか。ベースシステム情報に記述してある、パスに対応した設定ファイルを読み込む処理からかな。</p>
            <p>その設定ファイルには、対応するパッケージについて、そのパッケージのパスや、対応するセーブデータのパス、使用を許可するモジュールのリストなどが含まれている。</p>
            <p>ので、その設定ファイルを読んだら次はパッケージの設定ファイルを読み込んで、とかそういう流れになるんだろうな。</p>
            <p>なかなか負荷の高そうな内容だ。今週中に終わらせられればいいのだが。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/21 16:00</h2>
            <p>パス型の定義変更に対応完了。</p>
            <p>＊</p>
            <p>昨日に済ませておきたかったところだけど、ちょうどその直前できりがよかったため、昨日の作業はそこで切り上げてしまった。</p>
            <p>で、今日その辺をさくっと終わらせた。</p>
            <p>次はベースシステムやシェルについての情報をベース設定ファイルから読み込む処理と、ベース設定ファイルの情報を元に、色々設定ファイルとか読み込んで、ベースシステム生成に必要な情報を構築する処理かな。</p>
            <p>ベースシステムについての情報が記述されてるんならそれでいいじゃないかと思うかもしれないが、記述されているのは設定ファイルのパスとベースシステム名だけなので、具体的にどのモジュールをロードし、なんて関数を呼び出して生成し、破棄するか、といった情報は他の設定ファイルを読まないと分からない。</p>
            <p>なので、その辺どうにかする処理を書く、といった感じだ。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/20 14:38</h2>
            <p>やはりきちんと毎日書かんとだめだな。すっかり習慣がなくなってる。</p>
            <p>＊</p>
            <p>昨日の作業としては、設定ファイルの記述を修正したり、パス型の読み込み処理を独立させたりなど。</p>
            <p>パス型の定義を変えてあるため、現時点の処理では対応できないので、使う場面になったら修正することになるだろう。</p>
            <p>今日はベースシステム構築のためにコンフィグマネージャから情報を取得する処理とか書くつもりなので、前述の修正はやることになるかも。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/17 00:38</h2>
            <p>できるだけ忘れずに書いていくことにする。</p>
            <p>＊</p>
            <p>早速忘れかけていた上に、ツールがちゃんと動作するようになるまでネット上に上げられんけども。</p>
            <p>さて、結局設定ファイルの扱いについては、いっそのこと全ての設定ファイルを1箇所で管理した方が分かりやすいのでは、ということで話が進んでいる。</p>
            <p>設定ファイル間で関連性があるものも結構あるわけだし、管理オブジェクトに対し、情報を要求すれば必要に応じて設定ファイルを読み込んで情報を生成して返す、みたいな。</p>
            <p>一度読み込んだ設定ファイルはキャッシュしておいたり、もし要求があればキャッシュを削除したりなども考えているけど、前者はともかく後者は後回しだろうな。</p>
            <p>いや、前者も別に必須ではないな。</p>
            <p>もやもやは晴れつつあるし、ペース上げていきたいところだが。</p>
        </div>
        <hr />
        <div>
            <h2>2015/01/15 20:42</h2>
            <p>過去ログは年単位で分ければいいのでは、という声が一部でささやかれている。</p>
            <p>＊</p>
            <p>進みはスローペース。もっとさくさくやりたいところだが。</p>
            <p>ベース設定の一部を読み取る処理はできた。</p>
            <p>一部というのはパスの別名定義。パスに名前を付けて管理する形を取るので、そう呼んでいる。</p>
            <p>これにより、それぞれのデータのパスを指定できるようになった。</p>
            <p>最終的には、ベースシステムの構築→シェルの起動→ゲームの起動となるわけだが、それまでにどういう処理が必要になるだろうか。</p>
            <p>ベースシステムの構築やシェル、ゲームの起動のためには、やはりモジュールのロードが不可欠。</p>
            <p>よって、モジュールマネージャの生成が必要になるだろう。</p>
            <p>モジュールのロードには、パッケージディレクトリとコンフィグディレクトリに置かれているファイルの読み込みが必要になってくるはずだ。</p>
            <p>しかしその処理はモジュールマネージャ内で行うべきだろうか？難しいところだ。</p>
            <p>それを含めてしまうと、モジュールマネージャが肥大化してしまう気がする。</p>
            <p>とはいえ、どこかでは設定ファイル間の関連付けを解決する処理をやらねばならない。</p>
            <p>いっそ、モジュールマネージャではなく設定ファイルマネージャと考えるべきだろうか。</p>
            <p>モジュールのロードとかは、それとは別にモジュールローダというか、モジュールロードマネージャというか、そんな感じの機能を別に作り、そこでやらせる。</p>
            <p>パッケージディレクトリの設定ファイルと、コンフィグディレクトリの設定ファイル読み込み処理については、別々の機能に分けることはできないだろうな。</p>
            <p>パッケージに含まれるモジュール一覧とその詳細情報は前者に書かれているが、どのモジュールの読み込みが許可されているかどうかは後者に書かれている。</p>
            <p>あるモジュールを読み込むだけなら、後者の設定ファイルを読んだ後に前者の設定ファイルを読めばいいだけだが、モジュールによっては依存モジュールが存在する。</p>
            <p>依存モジュールについては、また後者の設定ファイルから読み直す必要がある。</p>
            <p>これを別々の機能に分けるとなると、循環参照になってしまって気持ちの悪いことになりそうな感じがある。</p>
            <p>＊</p>
            <p>書いてたら、ちょっともやもやが晴れた気がする。</p>
            <p>完全にクリアになったわけではないのだが。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/26 19:15</h2>
            <p>難航していたが、ようやくまとまってきた感ある。</p>
            <p>＊</p>
            <p>今までのファイル構成は、dropmakerのホームディレクトリ直下にベース設定ファイル、パッケージディレクトリ、ゲームディレクトリがあった。</p>
            <p>セーブデータディレクトリなんかも置く予定だったけど、まだそれが必要になる段階まで到達していない。</p>
            <p>実際には、ベース設定ファイル以外のディレクトリはベース設定ファイル内で指定した位置なので、ホームディレクトリの下に置く必要はないが。</p>
            <p>それはともかく、パッケージディレクトリにはゲーム本体、プログラムやら、画像とか音楽とかのリソースやらが配置される。</p>
            <p>一旦配置されたら、削除されるまで変更がかかることは基本的にない。</p>
            <p>ゲームディレクトリには、ゲームパッケージを起動するための情報を記述した設定ファイルを置く。起動するパッケージ名やらモジュール名やらゲーム名やら。パッケージがなんらかのインターフェースを使用する場合、その実装モジュールの指定もする。</p>
            <p>プレステで例えれば、パッケージディレクトリはCD、ゲームディレクトリ（とセーブデータディレクトリ）はメモリーカードである。</p>
            <p>＊</p>
            <p>今回の構成変更で、とりあえずゲームディレクトリは無くした、というより分割した。</p>
            <p>その前に、モジュールの扱いを変えたのを説明するべきか。</p>
            <p>今までは、モジュールはゲームディレクトリの設定ファイルでインターフェースとの関連付けを行っていた。</p>
            <p>今回の変更で、その関連付けはやめた。</p>
            <p>その代わり、パッケージディレクトリの設定ファイルに、各モジュールが実装しているインターフェースを記述しておく形にした。</p>
            <p>ゲームディレクトリの設定ファイルでは、使用を許可するモジュールのリストアップのみ行う。</p>
            <p>あるインターフェースの使用が要求された場合、使用が許可されているモジュールの中から、そのインターフェースが実装されているモジュールを検索し、使用する。</p>
            <p>もし該当するモジュールが2つ以上ある場合には、衝突が発生しているので要求は失敗となる。</p>
            <p>該当するモジュールが存在しない場合には、インターフェースを定義するパッケージが提供するダミーモジュールを使用する。</p>
            <p>ダミーモジュールを使うことで、例えばネットとの通信モジュールを使用するゲームであっても、ユーザー側でその機能を無効化する、ということも可能になる。</p>
            <p>とはいえ、ゲーム側がネットとの通信ができないなら動作しないようにしたりしていれば、そもそもゲーム自体できなくなってしまうわけだが、それはまた別の問題だ。</p>
            <p>＊</p>
            <p>で、ゲームディレクトリをコンフィグディレクトリとショートカットディレクトリの2つのディレクトリに分けた。</p>
            <p>コンフィグディレクトリでは、パッケージディレクトリとセーブディレクトリとの関連付けや、前述の使用を許可するモジュールのリストアップなどを行う。</p>
            <p>パッケージが他のパッケージに依存する場合、対象のパッケージについての設定が書かれたファイルの指定などもできる。</p>
            <p>ショートカットディレクトリでは、起動に関する設定をまとめる。</p>
            <p>起動するゲームの指定、メインウィンドウのサイズの指定など。</p>
            <p>＊</p>
            <p>まとめると、</p>
            <p>パッケージディレクトリにゲーム本体をつっこみ、</p>
            <p>コンフィグディレクトリにパッケージの設定をつっこみ、</p>
            <p>ショートカットディレクトリにゲーム起動時の設定をつっこむ、といった具合か。</p>
            <p>あと、セーブデータディレクトリにゲームのセーブデータをつっこむ。</p>
            <p>＊</p>
            <p>一部の設定ファイルについては、拡張子が一致していれば複数のファイルに分割することも許可する予定。具体的にはベース設定とパッケージ設定。</p>
            <p>コンフィグディレクトリに配置する設定ファイルについても複数のファイルに分割できるようにしたいが、いい案が浮かばない。</p>
            <p>前述のファイル分割は、見やすさ、扱いやすさの向上などが目的だが、こちらは違う。</p>
            <p>パッケージとセーブデータの関連付けと、使用許可モジュールリストを別ファイルに分けることで、例えば使用するモジュールはそのままに別のセーブデータを使いたいとか、同じセーブデータを使うけど使用するモジュールは変えたいとか、そんな感じだ。</p>
            <p>ならばその2つの設定を別のディレクトリに分けてしまえば、と思わないでもないが、そこまですることだろうか。少なくともパッケージとセーブデータの関連付けの方はデータ量が少なすぎる。</p>
            <p>細切れになるばかりで扱いにくくなりそう。</p>
            <p>その辺は後々対応することにしようかしら。そのくらいなら、全体的に修正をかけなければならない、というレベルのものでもないだろうし。</p>
            <p>＊</p>
            <p>ともかく、現時点ではファイルとディレクトリの構成を考えただけであり、実際にそれを運用するためのプログラムは存在していない。</p>
            <p>今までのdropmakerは断片的にしか役に立たないだろうし、1から作っていくとしよう。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/22 00:14</h2>
            <p>色々考えていたが、dropmakerはまた作り直した方がいいかもしらんね。</p>
            <p>＊</p>
            <p>どうにもモジュールの管理周りがうすらぼんやりとしてよくない。</p>
            <p>指定したモジュールから関数のアドレスを取得する関数を、全てのロード済みモジュールから関数のアドレスを探して取得する関数に変えようとするだけでもなんかうまくいかない。</p>
            <p>うまくいかないというより、変更が大きくなりすぎるというか、1から作り直した方が早そうというか。</p>
            <p>この際、ディレクトリや設定ファイルの構成らへんから練り直すべきかもしれない。</p>
            <p>現状では、直接起動するパッケージ以外はセーブデータを持てないし。</p>
            <p>依存モジュールの解決も、今は単純な構成だからましだけど、ちょっと複雑な構成になるとすぐだめになりそう。</p>
            <p>＊</p>
            <p>大まかな構成はテキストに書き出したので、土日に実際にディレクトリや設定ファイルを並べてみるつもり。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/18 00:40</h2>
            <p>日をまたいでしまった。</p>
            <p>＊</p>
            <p>次の日のやる気に影響するかもしれないので、こんな時間まで作業するべきではない。</p>
            <p>さて、fg::Windowからfg::Screenを分離した。</p>
            <p>デモを使って正常に動作することも確認済み。</p>
            <p>ここまでは大したことはない。ファイルの移動と記述の置換、それと多少の修正でできた。</p>
            <p>ここからが本番。メインウィンドウの生成と、それをゲーム側から触れるようにする。</p>
            <p>＊</p>
            <p>sucrose-screen-*モジュールを追加したので、パッケージ設定ファイルに記述を追加していて思ったが、もうちょっと要素を追加した方がよさそうだな。</p>
            <p>そのモジュールがなんのインターフェースの実装なのかを示す情報が現時点では存在しない。</p>
            <p>今のところはモジュール名を同じにすることでそのインターフェースの実装モジュール、ということにしているが、それだと実装が複数存在する場合に対応できない。</p>
            <p>そこで、モジュールの設定ツリーになんのインターフェースの実装なのかを示す要素を追加してみようか、などと考えている。</p>
            <p>そこまで優先度が高いわけではないので、後々実装する予定。</p>
            <p>あるいはもっといい設計が思い浮かぶかもしれないし。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/14 12:40</h2>
            <p>ウィンドウを2つの型に分離することを検討している。</p>
            <p>＊</p>
            <p>OpenGLコンテキストの扱い方については昨日の調査で大体把握できたので、以降はメインウィンドウをどのように実装するか考えていた。</p>
            <p>しかし、どうにもうまくまとまらない。</p>
            <p>今のところ、ウィンドウはfg::Windowという型で表現しているが、これを直接使うと色々問題がある。</p>
            <p>例えば、fg::Windowはfg::close()を使えばウィンドウクローズ、fg::resize()という関数を使えばリサイズなどの要求が行なえるが、メインウィンドウに関してはこれらは必要ないように思う。</p>
            <p>また、fg::free()を使えばウィンドウの破棄ができてしまう。</p>
            <p>破棄はメインウィンドウを生成、制御するゲーム起動側でやるので、ゲーム側ではできないようにしたい。</p>
            <p>他にも色々あるが、要はウィンドウを表現するという意味ではfg::Windowでいいのだが、その機能などがメインウィンドウと合致しない、といった感じだ。</p>
            <p>＊</p>
            <p>ぱっと思い付いた対応として、例えばfg::MainWindowという型を作り、内部的にfg::Windowを持たせ、fg::MainWindowにはfg::Windowの持つ関数のうち一部だけを用意すればいいのではと考えた。</p>
            <p>しかしこれはあまりいい対応ではない。</p>
            <p>簡単に言えば面倒なのである。fg::MainWindowの内部にfg::Windowを持たせ、fg::Windowと似たような関数を用意するということは、fg::Windowに新たに関数を増やし、それがfg::MainWindowでも使えるようにすべき関数である場合、fg::MainWindowにも同じように関数を増やさなければならない。</p>
            <p>当たり前ではあるが、こういうのは忘れてしまう可能性があるし、またfg::MainWindowの方の関数はfg::Windowの同じ関数を呼び出すラッパー程度の関数になるとはいえ、記述ミスによるバグを抱えてしまう可能性もある。</p>
            <p>＊</p>
            <p>そこで考えたのが、ウィンドウを2つの型に分離する、という方法だ。</p>
            <p>今はウィンドウを表現する型はfg::Windowのみだが、これとは別に表示領域を表現する型を用意する。</p>
            <p>仮にfg::Screenということにするが、fg::Screenは自発的に生成、破棄することができない。</p>
            <p>再描画やリサイズなどのイベントについてはイベントハンドラを設定できるようにするが、リサイズリクエストはできないようにする。</p>
            <p>例えば、fg::Windowの内部的にfg::Screenを持たせる、という感じにする。</p>
            <p>fg::Windowを生成すれば、それに対応したfg::Screenも同時に作られる、ということだ。</p>
            <p>それで、fg::Windowの関数としてfg::getScreen()とかいう関数を用意して、fg::Screenの参照を取得できるようにする。</p>
            <p>メインウィンドウについては、ゲーム側からはfg::Screenの参照のみを扱えるようにする。</p>
            <p>fg::Screenの参照だけ、つまりメインウィンドウの表示領域だけなら、破棄もできないし勝手なクローズやサイズ変更の要求もできない。</p>
            <p>おまけに、ラッピングした型でもないのでラッパー関数を作る必要などもない。</p>
            <p>＊</p>
            <p>うまくいきそうな気はしている。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/13 16:00</h2>
            <p>OpenGLのコンテキストについて色々試したので、整理しておこう。</p>
            <p>＊</p>
            <p>ある1つのウィンドウを、複数のスレッドのカレントコンテキストに設定することは可能。</p>
            <p>ある1つのOpenGLコンテキストを、複数のスレッドのカレントコンテキストに設定することは不可能。</p>
            <p>やろうとすると、glXMakeCurrent()を呼び出すタイミングでセグメント例外が発生する。</p>
            <p>一度、スレッドのカレントコンテキストを別のOpenGLコンテキストに変えるなりすれば、別のスレッドのカレントコンテキストに設定することはできる。</p>
            <p>しかしその場合、別のスレッドのカレントコンテキストに設定する前に行なわれ、まだ画面に表示されていない描画処理は無かったことになる。</p>
            <p>なので、一度カレントコンテキストに設定したOpenGLコンテキストを、別のスレッドのカレントコンテキストに移すとかいうのは、あまり意味がないように感じる。</p>
            <p>少なくとも、ゲーム起動側がメインウィンドウに描画を行なうためのOpenGLコンテキストを、ゲーム側から参照できるようにする必要性は、ほぼないことが確認できたと言っていいだろう。</p>
            <p>OpenGLコンテキストを複数のスレッドで使えないので、複数のウィンドウに対して1つのOpenGLコンテキストを割り当てる、とかいう構成も当然無理。</p>
            <p>＊</p>
            <p>今の構成は、fg::GLContextを生成し、その参照とfg::Windowの参照を使ってfg::GLCurrentを生成、それを使ってOpenGLの関数を呼び出す、といった具合。</p>
            <p>別のスレッドのカレントコンテキストに設定し直す意味があまりないということは、fg::GLCurrentなんて作らず、fg::GLContextの生成時にOpenGLコンテキストの生成とカレントコンテキストの設定を行ない、破棄時にカレントコンテキストからの設定解除とOpenGLコンテキストの破棄をやってしまえばいいのでは、ともちょっと思ったけど、それもまたちょっと違うんだろうな。</p>
            <p>例えばテクスチャの情報などはOpenGLコンテキストに関連付けられるだろうし、ウィンドウを一度破棄してもう一度ウィンドウを作り、以前と同じような表示をしたい場合、その度にOpenGLコンテキストの生成を行なっていたのでは再度テクスチャの情報なども作り直さなくてはならない。</p>
            <p>OpenGLコンテキストの生成・破棄とカレントコンテキストの設定・設定解除を分離しておけば、その辺うまく使い回せそうな気がする。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/12 23:00</h2>
            <p>今まで中途半端に作っていたデモをきちんと整えるなど。</p>
            <p>＊</p>
            <p>メインウィンドウ、どうやって実装しようか考え中。</p>
            <p>実質的に、ウィンドウのイベントは再描画要求以外触れないようにしたいところ。</p>
            <p>加えて、必要に応じてゲーム起動側、つまりメインウィンドウを生成した側でも画面に描画を行なえるようにしたい。</p>
            <p>それはつまり、ゲーム起動側にメインウィンドウで使用するOpenGLのコンテキストを持たせるわけで。</p>
            <p>それがカレントコンテキストになっているスレッドも持たせる必要があるわけで。</p>
            <p>描画することを考えなければカレントコンテキストの件は無視できるので、とりあえずそれでやってみようかなぁ。</p>
            <p>1つのウィンドウを、複数のスレッドでカレントコンテキストにする、とかってできるのかなぁ。</p>
            <p>今まで試したことがないから、明日試してみようかな。</p>
            <p>その結果次第では、OpenGLコンテキストはゲーム側から参照できるようにしなくても済むかも。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/11 19:45</h2>
            <p>昨日書いた通り、OpenGLの関数を使えるようにした。</p>
            <p>＊</p>
            <p>ほとんど前のプロジェクトで書いたものを流用しただけだが、やはり少し手を加えなければ使える状態にはならなかった。</p>
            <p>しかし、OpenGLの関数や定数は数が多いため、一気にファイルの総行数が1万行ほど増えてしまった。</p>
            <p>定数が書かれたファイルでおよそ5500行、関数が書かれたファイルでおよそ3500行あり、これだけで9000行に達するので仕方ないが。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/10 19:50</h2>
            <p>垂直同期については対応した。</p>
            <p>＊</p>
            <p>あとはOpenGLの関数だが、前のプロジェクトで書いたものを流用すれば明日にも完了できる気がする。</p>
            <p>垂直同期の対応についても、基本的には前のプロジェクトのものを流用したわけだが。</p>
            <p>しかしながら、xlibのDisplayをグローバルでなくしたなど、構成を変えているために修正は必要だったが。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/07 20:20</h2>
            <p>OpenGLの対応の残件は、OpenGLの関数を使えるようにするのと、垂直同期対応。</p>
            <p>＊</p>
            <p>今日かコンテキストをカレントに設定する処理を作っていた。</p>
            <p>それに付随して、バッファの切り替え処理も対応した。</p>
            <p>現時点ではglClear()とか使えないので、バッファを切り替えてもゴミデータが表示されてしまうだけだが。</p>
            <p>これであとは、OpenGLの関数を使えるようになれば描画ができるようになる。</p>
            <p>＊</p>
            <p>OpenGLの残件を対応したら、メインウィンドウ機能を対応したいところだ。</p>
            <p>ゲームの実行前に自動的に作られ、ゲーム側に渡されるサイズ変更不可、移動検知不可のウィンドウ。</p>
            <p>事前に設定することでサイズを変更できたり、フルスクリーンで実行できたりなどというのを考えているのだが。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/06 19:15</h2>
            <p>昨日のは勘違いだった。</p>
            <p>＊</p>
            <p>見るデータが間違ってて、実際にはおそらく問題なかった。</p>
            <p>なんであんな勘違いをしたのか。</p>
            <p>あの勘違いをしたやつは直ちに名乗り出ろ。</p>
            <p>＊</p>
            <p>OpenGLの対応を進めている途中で、試しに動かしてみてどうしてもOpenGLの関数を呼び出すところでこけてしまう問題が起きていた。</p>
            <p>1時間程度試行錯誤して、valgrindを使って実行するとこけた気がするのを思い出して、valgrindを使わずに実行したらすんなり動いてがっくりした。</p>
            <p>無駄に疲れた。</p>
            <p>もうこんなことはしたくないものだが、忘れた頃にまたやりそう。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/05 19:50</h2>
            <p>排他処理、スレッドや、ウィンドウについてはとりあえず出来上がっている。</p>
            <p>＊</p>
            <p>今はOpenGLの対応を進めている。</p>
            <p>その途中で、スレッドのライブラリにwaitやnotifyを行なうためのインターフェースを追加したり、その実装を作ったりもした。</p>
            <p>とにかく画面に描画をできるようにしたいところ。</p>
            <p>＊</p>
            <p>valgrind使っててなんかおかしいと思ったら、dlopen()したライブラリがdlclose()されてなかった。</p>
            <p>なんかdlclose()にnullが渡されてるから、クローズされないし失敗もしない。</p>
            <p>ていうかNewModuleの型がおかしい。</p>
            <p>なんでこんな型になっているのか。</p>
            <p>この処理を書いたやつは直ちに名乗り出ろ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/30 20:35</h2>
            <p>イベントハンドラの対応、一応できた。</p>
            <p>＊</p>
            <p>しかし、排他処理のインターフェースを作っていなかったため、まだ実用的でない。</p>
            <p>ロックしてないから、データがおかしくなるかもしれない。</p>
            <p>やはりスレッドのインターフェースも作るべきだろうか。</p>
            <p>ロック関係をそこに含めるか。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/29 19:35</h2>
            <p>まためんどくなってた。</p>
            <p>＊</p>
            <p>sucrose-windowを作成中。あとはイベントハンドラの対応のみ。</p>
            <p>色々考えて、また少しイベントハンドラの扱いを変えた。</p>
            <p>イベントハンドラ部分については、ウィンドウシステムの実装とは無関係だと思ったので、sucrose-window-commonというライブラリに分離させた。</p>
            <p>linux用の、xlibを使う実装はsucrose-window-xlibとして作成してある。</p>
            <p>で、イベントハンドラ部分をあまりめんどくなさそうな感じに設計を変えたので、明日ぐらいには作り終えられるのではと考えている。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/20 19:25</h2>
            <p>順調、と言いたいがやはりスローペースな気がする。</p>
            <p>＊</p>
            <p>とりあえず、sucrose-jsonは使えるようにした。</p>
            <p>あとはsucrose-mainを使えるようにすれば、dropmakerを動かせるが。</p>
            <p>しかし、シンボルの取得とかは処理を書き直さねばならないだろう。</p>
            <p>CからC++にした影響だ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/17 21:20</h2>
            <p>よくよく考えたら、イベントハンドラでつまづいただけだったなぁ。</p>
            <p>＊</p>
            <p>なので、dropmakerに関しては、ほとんどそのままソースを持ってくればいいか、という気分になっている。</p>
            <p>細かく修正を入れようとして時間食うよりずっといい。</p>
            <p>昨日加えた修正の件も考えて、持ってきたソースの中の不要になるconst_castを消していっているのだが、参照系のクラスは全部2種類用意するべきかもしれないなぁ。</p>
            <p>というのも、fg::JsonObjectPairsで似たような状態が発生しているのだ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/16 21:00</h2>
            <p>体調がびみょう。</p>
            <p>＊</p>
            <p>このところ、そのせいか分からんがびみょうに思考がまとまりにくいし、集中もできてないような。</p>
            <p>そんな感じで進みも悪い。</p>
            <p>＊</p>
            <p>文字列参照型を2種類にした。</p>
            <p>std::basic_stringみたいな位置付けのやつだが、std::basic_stringと違い、自身では文字列の領域を保持したりせず、他のところに配置されている文字列を参照する型なのだが。</p>
            <p>今までの構成だとコンストラクタがchar *なので、const char *を入れようとするとconst_castしなければならなくてめんどすぎる。</p>
            <p>なので、コンストラクタにconst char *をつっこむのと、char *をつっこむやつの2種類の型を作ることにした。</p>
            <p>後者の型を前者の型の子クラスにしたので、わざわざオーバーロードした関数を用意しなくても済むし。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/14 21:30</h2>
            <p>10日に書き忘れた。</p>
            <p>＊</p>
            <p>gitのログ見てみたらなんかおかしいな。何回sucrose-commonの生成ルールを追加してるんだ。</p>
            <p>直すのもめんどくさいが。</p>
            <p>＊</p>
            <p>とりあえず、sucrose-commonとsucrose-strconv-iconvを作った。</p>
            <p>前のプロジェクトではstrconvは一度に1種類しかビルドできなかったが、今のプロジェクトでは複数の実装を一緒にビルドできるようにしてあるため、名前を変えた。iconvを使っているので末尾にiconvと足してある。</p>
            <p>commonとstrconvを作ったので、コマンドライン引数を処理するだけのプログラムがビルドできるようになった。</p>
            <p>が、リンクする静的ライブラリ名をハードコーディングしているので、それはどうにかするべきだな。</p>
            <p>必要に応じてコマンドライン引数から指定できるようにしたいが、どうやって処理するべきか。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/09 21:11</h2>
            <p>前のプロジェクトからソースをどんどん持ってきている。</p>
            <p>＊</p>
            <p>2種類のライブラリを生成する件についてはどうにかなった。</p>
            <p>違うプロジェクト間で、wscriptを同一にしなければならないという決まりがあるでもなし、プロジェクト毎に不要なものは削除し、必要なものは追加して対応することにした。</p>
            <p>早いところ、今までに作った部分は移行してしまって、新機能を作成していきたいところ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/08 20:10</h2>
            <p>ビルドの簡略化はできた。</p>
            <p>＊</p>
            <p>とりあえず前のプロジェクトからソースファイルをそのまま持ってきて、fg-commonの生成がきちんとできるのは確認した。</p>
            <p>正確には、fgppからソースを持ってきたのでFGPPをFGに、fgppをfgに置換したりはしたが。</p>
            <p>あれ、よく考えたらあるライブラリについて、静的ライブラリと動的ライブラリの2種類作るのはできなくないか？</p>
            <p>どうしよう。ぱっと思い付く修正案はあるものの、それでいいのかどうか。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/07 22:55</h2>
            <p>早速、作り直し中。</p>
            <p>＊</p>
            <p>ビルドの簡略化を行なっているが、想定よりちょっとめんどかった。</p>
            <p>あるパッケージに存在するモジュールの一覧を取得する処理が、そう簡単にはいかなかった。</p>
            <p>dir()はロード済みのモジュールしか取得できないし。</p>
            <p>調べたら、ModuleScannerというのを使えばいいというのは分かったので、それを使ってコマンドラインオプションを作るところまではやった。</p>
            <p>次は、そのコマンドラインオプションを使用した際に、対象のモジュールのビルドを実行する処理を作る。</p>
            <p>うまくいけば、新たにモジュールのビルドルールを追加しても、他のところにその処理を呼び出す処理を追加しなくても済む。</p>
            <p>configure時にコマンドラインオプションを追加するだけで、そのビルドルールでモジュールが生成されるようになる。</p>
            <p>また、コマンドラインオプションで指定しなければ、モジュールをビルドしないようにもできる。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/06 22:56</h2>
            <p>って、いかん。何また難しくしようとしてるんだ。</p>
            <p>＊</p>
            <p>まずはC/C++だけ、もしくはC++だけ扱うのでもいいじゃないか。</p>
            <p>まだ一つも完成させてすらいないのに、最初から事を大きくしすぎだ。</p>
            <p>JavaとかPythonとかPerlとか、まだ必要な場面ではないのだ。</p>
            <p>＊</p>
            <p>また迷走して時間ばかりかけてしまうところだった。</p>
            <p>メインのライブラリはどうしよう。また作り直すべきだろうか。</p>
            <p>今度は本格的に処理は丸々使えるが、今のプロジェクトに修正を加える形でもいい気がする。</p>
            <p>しかし、この機会にビルドの仕組みの簡略化もしてしまいたいし。</p>
            <p>それをする場合、やはり作り直すべきな気がする。</p>
            <p>というか、インターフェースライブラリはそのままでいいな。</p>
            <p>いや、ビルドの仕組みの簡略化はインターフェースライブラリもやるけど、それは修正を加える形でいいだろう。</p>
            <p>この際だから、Cのラッパーライブラリも作らず、完全にC++だけの構成にしてしまってもいいかもしれない。</p>
            <p>ラッパーというか、他の言語に同じインターフェースがあると、一方に修正を加えたらそちらにも同じ加えたくなるし。</p>
            <p>コードの量は増えてもできることは増えてないという、効率の悪いことになるし。</p>
            <p>＊</p>
            <p>うむ。C++のインターフェースライブラリ「fg」、実装ライブラリ「sucrose」、ライブラリ利用環境「dropmaker」という3つのプロジェクトから成る構成にするかな。</p>
            <p>あと、ライブラリ利用デモ「fgdemos」の4つか。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/06 22:20</h2>
            <p>結局、C++のライブラリをメインにした方がいい気がしてきた。</p>
            <p>＊</p>
            <p>イベントハンドラの関係で、C言語のライブラリをメインにしているとラッパーライブラリがうまく作れないのだ。</p>
            <p>逆に、C++のライブラリをメインにして、C言語のそのラッパーライブラリにすればうまくいくんじゃないかなぁ、といったところ。</p>
            <p>そもそもC言語のライブラリをメインに持ってきたところで、それを直接使うわけでもないし。</p>
            <p>C言語を直接使ってゲーム作るのとかやりたくないし。</p>
            <p>しかし、その程度で大きく変更をかけるのは場当たりすぎる気がする。</p>
            <p>もうちょっとこう、他の言語との連携周りなのだから、その辺どのように対応するのかを考えてから処理したいところだが。</p>
            <p>現状ではどうあがいてもC/C++などで作られた、lib*.soとか*.dllとかのライブラリしか対応できないわけで。</p>
            <p>例えば.jarやら.pyやら.pl、.pmやらも使えるようにしてみたいところ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/03 21:52</h2>
            <p>ウィンドウ制御処理、大体はできたのだが。</p>
            <p>＊</p>
            <p>ウィンドウ内全てについて再描画処理をリクエストする処理についてはまだ。</p>
            <p>XGetGeometry()の処理が完了せず止まってしまうことがある。原因はまだ不明。</p>
            <p>おそらく、このへんも昔に通った道のはずなのだが。</p>
            <p>もしかしたら、xorg-serverのバージョンアップが影響しているかもしれないが、多分そんな大げさなことはないだろう。</p>
            <p>というか、この関数本当に必要だろうか。なんとなく必要な気がする、というだけで存在させている感は否めない。</p>
            <p>やりたいなら、ウィンドウサイズ変更イベントのイベントハンドラを設定しておいてウィンドウサイズを取得し、それを使ってウィンドウ内全てに再描画リクエストを投げてもいいのだ。</p>
            <p>ウィンドウの位置についても、どうもxlibではうまいこと制御できない感があるので、というか前にもこれは体験した気がするので、ウィンドウの位置は制御できないようにした。</p>
            <p>これと同じように、関数自体を消すという対応でいい気もする。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/02 23:25</h2>
            <p>イベント発生時のイベントハンドラ呼び出し処理を追加している。</p>
            <p>＊</p>
            <p>イベントハンドラの設定とかその辺については、ウィンドウ制御側からは触らんわけだし、イベント発生時の処理を書いた後でもいいかなって感じで。</p>
            <p>イベント発生時の処理はリセット前のプロジェクトとほぼ同じで大丈夫なので、さくっと片付けてしまいたいところ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/01 19:12</h2>
            <p>おかしいな、イベントハンドラの形式が古い。</p>
            <p>＊</p>
            <p>set形式は色々だめだと判断して、add/remove形式に変えたはずなのだけれど、その形式にしたソースが見つからない。</p>
            <p>そんなもんだから、今のAPIはset形式になってしまっている。</p>
            <p>直さないといかんなー</p>
            <p>＊</p>
            <p>ウィンドウ制御については、とりあえず表示と、イベント処理スレッドの起動までは作った。</p>
            <p>で、イベントハンドラの呼び出しとかが必要になってきた時点で、前述の問題に気が付いた感じ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/30 19:45</h2>
            <p>終了関数については、結局後回し。</p>
            <p>＊</p>
            <p>xlibを使ったウィンドウ制御について実装を始めている。</p>
            <p>リセット前のプロジェクトを参考にしているものの、前の物よりは分かりやすいものにしようと考えながら記述している。</p>
            <p>その中で、ラムダ関数への変数のムーブキャプチャを使ったのだが、なんかエラーが消えないと思ったら、どうやらconstでキャプチャされるらしい。</p>
            <p>参照キャプチャではそんなことはなかったようなのだが。ふしぎ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/29 20:40</h2>
            <p>ひとまず、初期化処理呼び出しの位置変更は完了した。</p>
            <p>＊</p>
            <p>しかし、終了処理についてはまだ考え中。</p>
            <p>初期化関数の引数に、関数ポインタの参照を渡してそれに終了関数のアドレスを設定するという方法はあまりよくない気がする。</p>
            <p>直感的でないというかなんというか、分かりにくいというか。</p>
            <p>そんな回りくどい方法を取るくらいなら、設定ファイルに初期化関数名と終了関数名のペアを書いておくとかの方がいい気がする。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/26 19:20</h2>
            <p>どうも暴走していたようだ。</p>
            <p>＊</p>
            <p>昨日書いたことはどうにも浅はかすぎる。終了処理の呼び出しは同じように書くべきではないと思った。</p>
            <p>初期化処理の呼び出しと同じように、終了関数を設定ファイルで指定することで、モジュールをアンロードする前に終了処理を呼び出す、というのは安直だが、安直すぎてだめだ。</p>
            <p>それだと、初期化処理が途中で失敗した場合、どの終了処理を呼び出すべきで、どの終了処理は呼び出すべきでないのか。</p>
            <p>こういうのはよく、終了処理は全て絶対に呼び出し、終了処理の中で、初期化してあるなら処理を行ない、初期化していないなら何もしない、と書くべきなどと言われるが、私はそういうのが嫌いなのだ。初期化してないなら終了処理は必要ないのだから、最初から呼び出さない方がすっきりする。</p>
            <p>例えば、初期化処理の引数として関数ポインタの参照を渡しておき、初期化処理が正常終了する場合に対応する終了関数のアドレスを設定する、などすればいい感じになりそう。</p>
            <p>＊</p>
            <p>しかしながら、現状では安直な方法ですら行なうのが困難な状況だ。</p>
            <p>モジュールのアンロード処理で、ロードしたモジュールを表現するvoid*しか情報をもらっていないため、どこかに終了処理の関数名を含めるとかいったことができないのだ。</p>
            <p>構成を間違えた感じがある。モジュールのロード、アンロード処理に、初期化、終了の処理を含めるべきではなかったのだ。</p>
            <p>単純に巻き戻してしまってもいい気がする。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/25 21:00</h2>
            <p>初期化処理できあがり。</p>
            <p>＊</p>
            <p>次は、初期化処理と共通の部分は共通化して終了処理の呼び出しを作成する。</p>
            <p>厳密には、現時点ではまだ必要ないと思われるが、ほぼ同じ処理なわけだし、ちょっとしたらすぐ必要になると思うし。</p>
            <p>作っておいて損ないだろう、といったところ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/24 23:36</h2>
            <p>初期化処理の追加、途中までできた。</p>
            <p>＊</p>
            <p>初期化処理を走らせるところはできたので、次は走らせる処理を指定するところ。</p>
            <p>それが出来たら、終了処理についても同じように追加する。</p>
            <p>しかし、ModuleInfoとModuleKeyを分けている意味がないような気がする。</p>
            <p>一緒にしちゃってもいいんじゃないかな。</p>
            <p>＊</p>
            <p>ビルドの仕組み、簡略化すべきかも。</p>
            <p>現状では、あるモジュールについて、configureする時に実装を指定することで、その実装を使ったモジュールをビルドするのだが、モジュールの名前を別にすることで、複数の実装を同時に存在できるようにしようかと。</p>
            <p>現状では、例えばウィンドウ管理のモジュールは、linux用のxlibを使った実装でも、windows用のwin32を使った実装でも、作られるモジュールの名前はlinuxならlibfg-window.so、windowsならfg-window.dllになる。</p>
            <p>でも、例えばxlibを使った実装ならfg-window-xlibとか、win32を使った実装ならfg-window-win32とかにすれば、実装が異なる複数のウィンドウ管理モジュールを共存させることができる。</p>
            <p>その環境はビルドできない実装の場合は、configureでビルドしないように指定すればいいのだし。</p>
            <p>この変更をすることで、多分ビルドの仕組みは今より簡単になるはずなのだ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/19 20:02</h2>
            <p>困った。</p>
            <p>＊</p>
            <p>初期化が必要なモジュールについての考慮が足りていなかった。</p>
            <p>今まで通り、各OSに用意されている機能を使ってもいい気がするが、あれはあまりよくない。</p>
            <p>初期化時に処理が失敗した場合にどうするとか、そういったことができない。多分。</p>
            <p>きちんと調べたわけではないのだが、少なくともwindowsでは関数が1つ固定、関数名すら固定だし、それを使うくらいならば自分で機能を作ってしまった方がいい気がする。</p>
            <p>今のところの考えでは、パッケージ設定に記述するモジュールの設定に、初期化関数を指定できる形にしようかと考えているがどうなんだろう。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/18 20:47</h2>
            <p>総ソースファイル行数が1000行ほど減った。</p>
            <p>＊</p>
            <p>今まで、共通化できそうだけどめんどうなので放置していた場所を、マクロで共通化した結果、そんな感じになった。</p>
            <p>これで、あとは実装部分をリセット前のプロジェクトから持ってくればウィンドウを扱えるようになるだろう。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/17 20:50</h2>
            <p>というわけで、ウィンドウの対応を始めた。</p>
            <p>＊</p>
            <p>リセットする前のプロジェクトからファイルを持ってきて、ちょっと修正を加えて使えるようにしたりなど。</p>
            <p>若干インターフェースやマクロの仕様が違うので、完全にそのまま使うわけにはいかない。</p>
            <p>一気にファイル数が増え、総ソースファイル数が300に迫る勢い。</p>
            <p>明日には300を越すだろう。</p>
            <p>しかし、メインウィンドウの生成はどこでやるべきか。</p>
            <p>コンテキストに参照を持たせることは決まっているが、コンテキスト生成処理に混ぜるか、生成後に参照をコンテキスト生成処理に渡すか。</p>
            <p>前者でいい気がするのだが、なんかしっくりこないような。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/16 19:08</h2>
            <p>とりあえず、コマンドライン引数対応は終えたのだが。</p>
            <p>＊</p>
            <p>この次、本当にパスの扱いについてやるべきだろうか。後回しでもいい気がしてきた。</p>
            <p>いい案がぱっと浮かばないし、なによりやる気があまりしないのだ。</p>
            <p>それよりも、リセットする前のプロジェクトには実装されていたウィンドウや入力機器、音声機器の管理機能をサクサクッと実装して、試しにゲームでも作ってみるべきな気がする。</p>
            <p>ゲームを作らんと、いつまで経っても話が進まんのだ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/12 20:23</h2>
            <p>どうにも作業速度が思うように上がらないと思ったら案の定だった。</p>
            <p>＊</p>
            <p>そんなわけでまだ出来上がっていないが今日は疲れた。</p>
            <p>このまま出来上がるまで続行するというのは昔はよくやっていた気もするが、これをするとその後一層気分がよくなくなるのだ。</p>
            <p>よくない連鎖は発生する前に止めるに限る。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/11 20:00</h2>
            <p>とりあえずコマンドライン引数対応を始めた。</p>
            <p>＊</p>
            <p>一応、リセットする前のプロジェクトでは実装されていた機能なので、大体はそこから持ってくればいいだけなのだが。</p>
            <p>その後の処理は完全に1から書くことになるわけで、出来上がるのは早くて明日だろうな。</p>
            <p>今日はこれ以上続けるとだらだらしちゃうからやめやめ。</p>
            <p>TODOコメントをいくつか、ヒントとして追加しておしまい。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/10 22:10</h2>
            <p>パスの扱いについてまだ考え中。</p>
            <p>＊</p>
            <p>今日はバグの修正やら細かい変更などをしていた。</p>
            <p>パスについては後回しにして、先にコマンドライン引数で起動するプログラムの指定をできるようにしてしまった方がいいかもしれない。</p>
            <p>実際に必要になる場面を先に作ってしまえばイメージしやすそうな気がする。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/09 19:40</h2>
            <p>静的リンクしていたライブラリを、モジュールとして動的リンクして扱うように修正した。</p>
            <p>＊</p>
            <p>当初の予定では、静的リンクしているライブラリ5つを全て動的リンクさせたかったのだが、よく考えたらそのうち4つはモジュール管理処理から使っているので分離できず、結局1つのライブラリしか取り外すことができなかった。</p>
            <p>しかしながら、そのおかげで奇妙な処理の仕方をしていた箇所を削除することができたし、成果は悪くない。イメージのサイズも小さくなったようだし。</p>
            <p>複数のライブラリを修正する予定だったのでマクロとかも作って修正しやすくしたのだが、結局1つのライブラリしか修正できなかったので、ちょっと大げさになってしまった感はある。</p>
            <p>とはいえ、今後別のライブラリをリンクさせる予定があるので、その時には役立つかも。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/08 19:26</h2>
            <p>プログラム起動前のモジュール読み込みについても、依存関係を解決した上で読み込むようにした。</p>
            <p>＊</p>
            <p>これにより、プログラム起動前に読み込むモジュールについても、別のモジュールに依存させることが可能になった。</p>
            <p>今までは対象のモジュールのみ読み込む形だったので、他のモジュールに依存させていると正しく動作しなかったが、それが解決された。</p>
            <p>現状では、プログラム起動前に読み込むモジュールは他のモジュールに依存できないのを前提とした書き方をしていたはずなので、その辺は修正していくべきだろうな。</p>
            <p>＊</p>
            <p>次はコマンドライン引数で起動するプログラムの指定をできるようにしたいところだが、これをするとなるとパスの扱いをきちんと考えんと。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/06 13:18</h2>
            <p>おとといバージョン上げて、昨日プログラム起動前に読み込むモジュールのどうのこうのの前準備をした。</p>
            <p>＊</p>
            <p>というのを昨日書けばよかったのに忘れていた。</p>
            <p>今日明日はあまり作業しないようにする。</p>
            <p>のんべんだらりとなってくると、余計にやる気が減退してしまってよくない。</p>
            <p>そんな感じで、土日やら祝日やら、あとは平日の夜とかも、意図的に作業しないようにしている。</p>
            <p>せいぜい、なんか思い付いたらメモしておく程度。</p>
            <p>その方が、作業中集中できるし気分的にもいい気がするのだ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/04 17:16</h2>
            <p>やることは色々思い付くが、ここらでバージョンを上げて区切っておくべきだろうか。</p>
            <p>＊</p>
            <p>依存解決ありのモジュールロード処理のプロトタイプは出来上がっているわけだし。</p>
            <p>今後、コマンドライン引数で起動するプログラムを指定したりとか、プログラム起動前に読み込むモジュールも依存解決ありの形にしたりだとか、その他諸々を予定している。</p>
            <p>後者の機能を実装するために、ファイルの配置を変えたりしていたが、そろそろバージョンを上げてネット上のリポジトリにpushしておくべきだろうな。</p>
            <p>調子が良さそうに思える時ほど、冷静にならねば無意識のうちに暴走、迷走して失敗するのだ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/03 19:59</h2>
            <p>あるモジュールが複数モジュールから依存されている場合に、無駄にメモリ食ったり無駄な処理したりしないように修正した。</p>
            <p>＊</p>
            <p>簡単なデモプログラムを作ってみて、問題なく動作するのを確認した。</p>
            <p>しかし、必要なモジュールを依存モジュールリストから外しておいて、動作に失敗するはずのプログラムが普通に動いた、というのが起きた時はびびった。</p>
            <p>原因を調べたら、プログラムを実行するコアプログラム側に、必要なモジュールの処理が含まれており、プログラムがコアプログラム側の処理を呼び出しているために、普通に動いているように見える、ということだった。</p>
            <p>しかしコアプログラムはシンボルを全くエクスポートしていないはずなのに、なぜプログラム側から呼び出せているのか謎だったが、コアプログラムのリンク時に-rdynamicオプションを指定しているのがまずかったらしい。</p>
            <p>このオプションを付けているとバックトレースの表示を詳しくできるため、デバックビルドのリンク時には付けていた。</p>
            <p>しかしこのオプションの機能は「生成したファイル内に動的リンク用のシンボルを残す」というものであるため、今回のような問題が発生してしまったようだ。</p>
            <p>で、バックトレースを見る機会とか今のところほぼないし、別にいいかということで問題のオプションを使わないことで対応した。</p>
            <p>そもそもgrep backtraceとかやっても1件もヒットしなかったし、この記述自体が以前に作っていたプログラムの名残だったと思われる。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/02 18:44</h2>
            <p>やたー動いたー。</p>
            <p>＊</p>
            <p>もうちょい処理を追加する必要があるが、とりあえず動作するのを確認できた。</p>
            <p>依存モジュールのロードを行ない、プログラムを起動させることに成功。</p>
            <p>依存モジュールの指定方法をもうちょい種類増やしたりだとか、そもそも今のインターフェースで他の言語のプログラムを扱えるのかなど問題は色々あるものの、とりあえず一段落した気がする。</p>
            <p>あるモジュールが複数のモジュールから依存されている場合の処理をまだ書いてないので、それは追加する必要がある。</p>
            <p>それにしたって、効率的な処理にならない、というだけであり、想定では問題なく動作するはずだが。</p>
            <p>その辺確認するためにも、デモプログラムをいくつか作ってみる必要がありそう。</p>
            <p>モジュールの依存関係が循環してしまっている場合、現時点では正しく動作しない。多分無限ループみたくなって、そのうちスタック食い潰して落ちる。</p>
            <p>そもそも循環した依存関係というのが、他の言語とかでも常に許容されるのか分からんし、動作するように対応するかどうかはびみょう。循環を検出して、起動失敗にしたりなど、なんらかの対策は必要だろうけど。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/01 15:36</h2>
            <p>もうめんどいから過去ログに分割しなくてもいいんじゃないかな。</p>
            <p>＊</p>
            <p>パッケージシステムの暫定的な根幹ができあがりそうな感じ。</p>
            <p>＊</p>
            <p>また今日も、私の頭の中から湧き出た何かを形にするべく、その正体不明の何かを解析する作業。</p>
            <p>妄想なんだろうけど、見てはいけない何かを見つめ続けてしまっている気がする。</p>
            <p>そのうちもっと頭おかしくなるのではないだろうか。</p>
            <p>＊</p>
            <p>ポケモンエメラルドで捕まえられるポケモン全部捕まえた。</p>
            <p>あとはルビーやらサファイアやらでしか出現しないポケモンを捕まえて送り込まねば、ホウエン図鑑を埋めることはできない。</p>
            <p>送り込むだけならそれぞれのカートリッジと、安価で購入したゲームキューブとポケモンボックスを持っているのでできるのだが、通信ケーブルがないため通信進化ができない。</p>
            <p>アドバンスのケーブル、通販だと中古でも新品並みの値段になってたりするから困る。新品が定価の2、3倍とか頭おかしいと思う。手を出しがたい。</p>
            <p>＊</p>
            <p>さて、こわいこわい言ってないで作業せんと。クトゥルフ神話じゃないんだから未知に対する恐怖なんてあるものか。</p>
        </div>
<!--過去ログ用
        <hr />
        <div>
            <p><a href="/">戻る</a></p>
        </div>
-->
<!-- ここから過去ログ時に削除 -->
        <hr />
        <div>
            <h2>過去ログ</h2>
            <p><a href="201405.html">201405</a></p>
            <p><a href="201404.html">201404</a></p>
            <p><a href="201402.html">201402</a></p>
            <p><a href="201401.html">201401</a></p>
            <p><a href="201312.html">201312</a></p>
            <p><a href="201311.html">201311</a></p>
            <p><a href="201310.html">201310</a></p>
            <p><a href="201309.html">201309</a></p>
            <p><a href="201308.html">201308</a></p>
            <p><a href="201307.html">201307</a></p>
            <p><a href="201306.html">201306</a></p>
        </div>
<!-- ここまで -->
        <div id="for-nostylesheet">
            <hr />
            <img src="images/uni.png" />
        </div>
    </body>
</html>
