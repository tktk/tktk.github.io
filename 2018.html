<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>tekuto.net</title>
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-LPVZW1087D"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-LPVZW1087D');
        </script>
    </head>
    <body>
        <div>
            <p><a href="/">戻る</a></p>
        </div>
        <hr />
        <div>
            <h2>2018/12/22 04:20</h2>
            <p>ボタン入力テスト、とりあえずできた。</p>
            <p>＊</p>
            <p>しかし、テストコードが妙に長くなってしまっている。</p>
            <p>設計を改善して機能の独立性を上げれば、もっと短くできるはずだ。</p>
            <p>テストコードがあればそういうところも見えて来るんだな。</p>
            <p>やはり自動テストは開発に必須だ。</p>
        </div>
        <hr />
        <div>
            <h2>2018/12/19 00:25</h2>
            <p>ようやっと画面のテストができるようになったかもしれない。</p>
            <p>＊</p>
            <p>brownsugarへの機能追加によって挙動を模倣し、fgへの関数追加でテストしたいデータを参照できるようになった、はず。</p>
            <p>fgに追加した関数はあからさまなテスト専用のデータ参照関数にはなってないはずなので、あまり不自然ではない、と思う。</p>
            <p>とりあえず、画面初期化時のテストはできた。</p>
            <p>ボタン入力後の反応テストについて、明日から試していく予定。</p>
        </div>
        <hr />
        <div>
            <h2>2018/12/08 04:15</h2>
            <p>brownsugarとかいうのを作り始めた。</p>
            <p>＊</p>
            <p>zarameを使ってテストを動かそうとしたがうまく行かず、色々めんどうになったのでテスト用のベースシステムライブラリを作ってしまうことにした。</p>
            <p>それがbrownsugar。</p>
            <p>いい名前が思い付かなかったので適当だ。</p>
            <p>＊</p>
            <p>基本はsucrose-testとかいう、sucroseのテスト用に用意したライブラリ。</p>
            <p>fg::BasesystemContextやfg::GameContextがないとテストできない機能のために、そのダミーを生成するために用意したライブラリだ。</p>
            <p>テストのテストというのも奇妙だったからか、ダミーとしての機能のテストをしていなかったため、それをきちんと追加する。</p>
            <p>処理内容は丸々コピーする形になると思うけど。</p>
            <p>とはいえ、そのままではkasuteraのテストに必要な機能が足りないので、その辺は順次足していく感じで。</p>
        </div>
        <hr />
        <div>
            <h2>2018/12/06 03:50</h2>
            <p>自動テストをできるようにしたい。</p>
            <p>＊</p>
            <p>fgを実装したライブラリを利用する、ゲーム側がまともにテストできていない状態で非常に困っている。</p>
            <p>きちんと作れているのか確証が得られないため、とても不安だ。</p>
            <p>＊</p>
            <p>画面単位であれば、テストは可能な作りになっているはずなのだ。</p>
            <p>問題は、ゲームコントローラの入力に依存している処理があるため、既存のベースシステムでは全自動のテストができない。</p>
            <p>あらゆるイベントを自由に生成できる環境を作れば、全自動でテストできるようになるかな。</p>
            <p>いや、今のところ任意に発生させるのが困難なのはコントローラ周りだけだし、その辺だけでいいのか？</p>
            <p>テストができない原因もそこだしな。</p>
            <p>＊</p>
            <p>いや待て、コントローラの接続とかは外部公開の関数にしてたな、と探してみたらあった。</p>
            <p>これ使えばzarameをそのまま使ってもテストできるかな。</p>
            <p>zarameはlinux上で動かすためにudev関係のライブラリとリンク、つまり環境依存してるから、その辺排除した別のものを作った方がいい気がするけど。</p>
            <p>後々、別のOS上でテスト実行したい、ってなった時大変だ。</p>
            <p>とりあえずzarameで試してみよう。</p>
        </div>
        <hr />
        <div>
            <h2>2018/12/04 01:50</h2>
            <p>fg::StatePopperに修正を入れるべきかも。</p>
            <p>＊</p>
            <p>1回だけポップができるもの、として用意したのだが、破棄時にポップされるという仕様がよくないようだ。</p>
            <p>破棄しようとすると絶対にポップされるため、ポップせずに破棄、ということができないのだ。</p>
            <p>よって、ポップしなくてもいい場合にもポップが行なわれてしまう。</p>
            <p>今の実装ではfg::StatePopperはfg::StateStackの参照をキャストしただけのものであってメモリを確保していないため、破棄せずにリリースすれば問題ない。</p>
            <p>しかし、運用を考えると逆の方がいいだろう。</p>
            <p>単純に破棄すると何も起こらず、明示的にポップの指示を出すことでポップが行なわれる、という形だ。</p>
            <p>そこにポップができるのは1回だけ、という制限を設けようとすると、メモリ確保は避けられないが仕方ないな。</p>
        </div>
        <hr />
        <div>
            <h2>2018/12/01 03:20</h2>
            <p>fg::StateStackに修正を入れた。</p>
            <p>＊</p>
            <p>fg::Stateの初期化をプッシュイベントで処理していたのをやめ、初期化関数を別に用意した。</p>
            <p>プッシュイベントは非同期に呼び出されるし、データを1つしか受け渡せなかったため、応用が効きにくかった。</p>
            <p>初期化関数はfg::Stateがプッシュされる前に同じスレッドから呼び出され、複数のデータを受け渡せるようにした。</p>
            <p>初期化時に渡すデータを変えることで、画面の挙動に変化を与える、ということがやりやすくなったと思う。</p>
            <p>画面のコードが固定的になりすぎて、実際の画面の数と完全に同数にコードが必要になりそうなのが気にかかっていたのだ。</p>
            <p>＊</p>
            <p>この修正で、プッシュイベントがポップやエンター、リーブと比べると明らかに異質な存在になっていたのも解消できた。</p>
            <p>テンプレートで実装したため、単体で呼び出させたくない関数もできてしまったが、そういう関数は関数名の末尾にアンダーバーを追加した。</p>
            <p>多少不自然な感じに見えるので、普通は呼び出さないことが伝わるかもしれない。</p>
        </div>
        <hr />
        <div>
            <h2>2018/11/23 05:00</h2>
            <p>fg::StateStackがいい感じ。</p>
            <p>＊</p>
            <p>想像以上にと言うか想定通りにと言うべきなのか、考えたことが実現できているように思う。</p>
            <p>単純な画面遷移はもちろん、画面内の状態遷移もfg::StateStackで表現できる。</p>
            <p>あるfg::StateStackのイベント関数から、別のfg::StateStackのイベント関数へのイベントの伝播もできる。</p>
            <p>名前空間を切り分けることで、現実的なレベルで大規模な開発もできそうだ。</p>
            <p>＊</p>
            <p>using namespaceとか、初めて実戦で使った。</p>
            <p>厳密に言えばユニークポインタで使ってるけど、あれはちょっと特殊な状況だし。</p>
            <p>きちんと生かせていそうなのは今回が初めてだ。</p>
            <p>＊</p>
            <p>欠点としては、自分で作ったものとはいえ自分自身あまり馴染みのない構成の記述を強いられているようで、すごい不安な気分になってくるというところか。</p>
            <p>自分の妄想を形にしただけ、と言っても過言ではないものなので仕方がないことではあるが。</p>
            <p>本当にこのままうまく行くのだろうか。</p>
            <p>＊</p>
            <p>例外対応は全くやってないわけだけど、きちんとやろうとすると大幅な修正が必要なのは確実なんだよなぁ。</p>
            <p>ネイティブコードである以上、単に例外処理を追加しただけではNULL参照でSEGVで死んでしまう。</p>
            <p>それを検知し、取り扱うためにはゲームの処理を別のプロセスで動かす、などするしかないだろう。</p>
            <p>chromeなんかではそういった処理がされているようだし、できなくはないはずだ。</p>
            <p>しかし自分でやったことはない。</p>
            <p>子プロセスから親プロセスにあるウィンドウにOpenGLで描画するとか、できればいいのだが。</p>
        </div>
        <hr />
        <div>
            <h2>2018/11/21 03:50</h2>
            <p>やれやれ、少し詰まってた。</p>
            <p>＊</p>
            <p>でもEventProcsをStateに変更するのは完了した。</p>
            <p>へびゲームやらも修正して、動作確認まで済ませた。</p>
            <p>他にも、後回しにしていた細かい修正を適用したりした。</p>
            <p>＊</p>
            <p>Stateにデータを持たせられるようにしたのは、想定よりもいい感じかもしれない。</p>
            <p>今まで、ゲームのデータはfg::GameContextに設定するデータに集約しなければならなかったが、その必要がなくなった。</p>
            <p>画面が共通のゲームデータから独立して、新しいものを追加しやすくなったように思う。</p>
            <p>＊</p>
            <p>他に今まで扱いにくかったのは、サブのfg::StateStack、元fg::EventProcsStackだな。</p>
            <p>1つの画面内における細かい遷移をうまく表現できるか、明日コントローラ設定画面で試してみる予定。</p>
            <p>＊</p>
            <p>Stateにデータを持たせられるようにした関係で、fg::StateStack破棄時に全てポップする、という処理はもう必要ないのかもしれない。</p>
            <p>それが必要だったのは、プッシュ時に確保していたデータをポップ時に解放していたからだし。</p>
            <p>今のところは、処理があってもなくても大して違いはないからいいけど、この処理は破棄処理中に例外が投げられる要因になっていて危険なので、不要であると確信が持てたら消そう。</p>
        </div>
        <hr />
        <div>
            <h2>2018/11/20 03:30</h2>
            <p>EventProcsの名前を変更する。</p>
            <p>＊</p>
            <p>Stateに変更する。</p>
            <p>元の名前は直接的すぎるし、なにより長くてよくなかった。</p>
            <p>遅くとも明日中には完了する予定。</p>
            <p>で、新たに機能を追加する。</p>
            <p>＊</p>
            <p>EventProcsは名前の通りイベント関数の集まりだったんだけど、そこにデータを確保する機能も付ける。</p>
            <p>今まででもPush時にデータを確保し、Pop時に確保したデータを破棄する、というようにして、イベント関数でのみ使うデータを扱っていたが、データ破棄のためにわざわざPopイベントの関数を作ったりするのがめんどうだったのだ。</p>
            <p>割と頻繁に必要になるし、だったら機能を追加して破棄くらいは自分でやらずとも自動でやってくれるようにしよう、というわけ。</p>
            <p>イベント関数群とデータ、合わせて「状態」と呼べそうなのでStateと名付けた。</p>
            <p>＊</p>
            <p>とはいえ、こんなことに何日も使いたくないので、さっさと終わらせてコントローラの扱いの続きに入りたい。</p>
        </div>
        <hr />
        <div>
            <h2>2018/11/15 02:55</h2>
            <p>とりあえず一通り対応。</p>
            <p>＊</p>
            <p>candymaker以外に、karameruやらzarameやらも対応して、cmsnakeも対応して動作確認もした。</p>
            <p>しかし、大まかにはいいのだが、関数名はどうにかする必要がありそうだ。</p>
            <p>生成関数の接頭辞全てがnewではよくない。</p>
            <p>頭にnewが付く生成関数は、nullを返すことがなく、異常時は常に例外を投げることで対応する形にしたい。</p>
            <p>つまり、頭にnewが付く生成関数の戻り値はnullのチェックをする必要がない、ということだ。</p>
            <p>それ以外に、異常時に例外を投げず、nullを返すこともある関数というのももちろんあるが、そっちは頭にnewを付けない形にしたい。</p>
            <p>そうしておけば、関数名で戻り値のチェックが必要なのかどうか判断できる。</p>
            <p>＊</p>
            <p>で、ひとまずkarameruの画像読み込み関数の接頭辞をnewからgenerateに変更した。</p>
            <p>fgの方も対応するべきだし、例外対応を考えると戻り値をboolからvoidにしていい関数もある。</p>
            <p>しかしこれは今やるべきなのかどうか。</p>
            <p>いや、ユニークポインタの変更と比べたら、ずっと楽な修正だからやってしまうべきか。</p>
        </div>
        <hr />
        <div>
            <h2>2018/11/14 04:15</h2>
            <p>ユニークポインタの扱いを改善した。</p>
            <p>＊</p>
            <p>本当ならkasuteraを進める予定だったんだけど、ちょっと及び腰になってしまったので。</p>
            <p>また、ユニークポインタの扱いは古いものと新しいものが混在する状態になってしまっており、後々のことを考えると先にどうにかしておくべきと思っていたのだ。</p>
            <p>＊</p>
            <p>それに付随して、ユニークポインタの定義を改善した。</p>
            <p>これにより、使い勝手がかなりよくなったように思う。</p>
            <p>今までは、ユニークポインタを扱うファイルではユニークポインタのヘッダファイルを最後にインクルードしないとコンパイルエラーが起きる可能性があったが、改善によりインクルードの必要がなくなった。</p>
            <p>これによりヘッダファイルのインクルード順を考慮しなくて済むようになった。</p>
            <p>fg、sucroseについては対応したが、candymakerについてはまだなので、明日やる予定。</p>
            <p>＊</p>
            <p>あまり足踏みしてないで、早くkasuteraを進めないと。</p>
        </div>
        <hr />
        <div>
            <h2>2018/11/09 02:55</h2>
            <p>生コントローライベントについて、zarameの方まで対応できた。</p>
            <p>＊</p>
            <p>が、動作確認はまだ。</p>
            <p>実際にコントローラを動かさないと確認できない気がするので、自動テストに書けないのがきびしいところ。</p>
            <p>明日へびゲームを新しい仕様に合わせて書き換えて確認する。</p>
        </div>
        <hr />
        <div>
            <h2>2018/11/08 00:25</h2>
            <p>改良しつつ生コントローライベントをアクションに変更完了。</p>
            <p>＊</p>
            <p>といっても、それらを扱う部分についてはまだ。</p>
            <p>なんだか既存の構成をざっと見た感じ、あまり頭のよくない構成になっている気がする。</p>
            <p>生コントローラと、その上に来るコントローラの扱いには関係があるからか、同じところで処理しようとしているように見える。</p>
            <p>関係性については正しいのだが、だからといって同じところで処理する、というのは間違ってる気がする。</p>
            <p>生コントローラの管理とそれを踏まえた上でのコントローラの管理は別々にした方がよさそう。</p>
            <p>大体、一緒にしてしまったら肥大化しすぎて手に負えなくなる。</p>
            <p>＊</p>
            <p>後々拡張すること前提の構成もあるようなので、そういった部分を省けばより単純な構成にできそうだ。</p>
            <p>明日中には、ゲーム側でイベントが受け取れるようにまで対応したいところ。</p>
        </div>
        <hr />
        <div>
            <h2>2018/11/07 01:45</h2>
            <p>メインウィンドウ描画イベント対応完了。</p>
            <p>＊</p>
            <p>古いfg-eventとfg-basesystemeventを削除して、新しいfg-eventのみに差し替えるのも済ませた。</p>
            <p>さすがにそれら残したまま対応するのは余計にめんどくさそうだったので。</p>
            <p>描画イベントの対応も、想定通りにできたと思う。</p>
            <p>コントローライベントに関しても、同じようにやれば問題なくできそう。</p>
            <p>＊</p>
            <p>新しく追加する型については、生成処理の書き方を多少変更している。</p>
            <p>例えば、後々例外対応することだし、ということでnewする時にstd::nothrowを付けて戻り値をnullチェックする、というのをやめたり。</p>
            <p>生成した型のユニークポインタを得るためにfg::unique( fg::newData() );みたいな書き方をしなくても、fg::newData();でユニークポインタが返るようにしたり。</p>
            <p>ほぼ確実にユニークポインタを使うのに、毎回前者のような書き方をするのは面倒だったのだ。</p>
            <p>それによって多少問題が起きているが、致命的ではないしそのうち対応する予定。</p>
        </div>
        <hr />
        <div>
            <h2>2018/11/06 00:10</h2>
            <p>先週中に片付けるつもりだったが、今日までかかった。</p>
            <p>＊</p>
            <p>というわけで、新しいfg::EventProcsStackはできた。</p>
            <p>fg::BasesystemEventProcsStackを排除した構成なので、ソースの量は1/3くらいになった。</p>
            <p>しかしまだ全部ができているわけではない。</p>
            <p>ベースシステムへの登録機能がまだ。</p>
            <p>＊</p>
            <p>登録処理の実装はベースシステム内だけど、それ以外の部分をどうするべきかがまとまっていない。</p>
            <p>具体的には、イベント関数呼び出しとイベントデータ。</p>
            <p>各ライブラリ内でいいか、と思ったら今度は別の問題が出てきた。</p>
            <p>コントローライベントは型の名前が重複してしまうのだ。</p>
            <p>コントローライベントはコントローラの接続・切断やボタン押下などで発生するが、実際に使う上ではどうせどっかのバッファにまとめてから使うわけだし、とそういった処理もライブラリ内で行なっている。</p>
            <p>ゲーム側から見た時にコントローライベントから得られるのは、直前までに溜め込まれた複数のイベント群となる。</p>
            <p>なので、fg-basesystemeventにfg::BasesystemRawControllerEvent、fg-controllerにfg::RawControllerEventが配置されており、前者の中に後者が複数含まれる形になっている。</p>
            <p>しかしこれだと、1つにまとめてBasesystemという文字を取り外すと名前が完全に一致してしまうのだ。</p>
            <p>＊</p>
            <p>よく考えたら後者、fg::RawControllerEventのEventというのは正しくないのではないだろうか。</p>
            <p>今の構成において、Eventというのはfg::EventProcsに設定し、呼び出されるものだ。</p>
            <p>そう考えると、fg::RawControllerEventはそれに当てはまらず、ふさわしくない。</p>
            <p>別の文字に置き換えた方がよさそうだ。</p>
            <p>で、考えたのはAction。</p>
            <p>ボタンアクション、コネクトアクション、アクシズアクション。</p>
            <p>正直イベントの方がしっくり来るが、変えなければならないのだから仕方がない。</p>
            <p>もっとふさわしいのを思い付けばそっちにするんだけど。</p>
            <p>＊</p>
            <p>コントローラの方をやる前に、まずウィンドウ描画の方をやってしまう方がいいかもしれないな。</p>
            <p>こっちはイベントデータから何か取り出すとかは今のところないし、コントローラの方よりずっとシンプルなのだ。</p>
            <p>ウィンドウ描画の方を先に作って実際に動かし、確証が得られればコントローラの方も取りかかりやすくなるし。</p>
        </div>
        <hr />
        <div>
            <h2>2018/10/26 21:50</h2>
            <p>fg::EventProcsManagerが余計かもしれない。</p>
            <p>＊</p>
            <p>fg::EventProcsManagerはfg::EventProcsStackへのプッシュ、ポップを行う型で、破棄時には生成時の要素数になるようにポップする機能があり、整合性を崩れにくくしている。</p>
            <p>が、その破棄時の動作が正常に動作していない。</p>
            <p>fg::EventProcsStackに追加されているイベント関数からfg::EventProcsManagerの破棄が行なわれるとデッドロックしてしまうのだ。</p>
            <p>＊</p>
            <p>根本の構成的には、ポップするだけであればポップのリクエストと処理は非同期に行なわれるため、イベント関数中でポップのリクエストがあったからと言ってデッドロックは起きない。</p>
            <p>しかしどうにもfg::EventProcsManagerの存在が邪魔なようだ。</p>
            <p>fg::EventProcsManagerは整合性を保つため、プッシュやポップ時に要素数を確認し、生成時の要素数未満におけるプッシュや、要素数未満になるようなポップは禁止している。</p>
            <p>要素数確認のためには排他ロックをかける必要があり、それが競合を起こしているのだ。</p>
            <p>と、思っていたのだけどデバッガを使って詳しく調べたらちょっと違った。</p>
            <p>破棄時の要素数を合わせるポップのリクエスト後に、その処理が完了するまで待機しているのが問題のようだ。</p>
            <p>イベント関数からの呼び出しで待機してしまうと、ポップ処理で行なうロックを保持したままになっているのでデッドロック。</p>
            <p>とにかく、現状ロックしすぎててよくない感じ。</p>
            <p>＊</p>
            <p>fg::EventProcsManager破棄時のポップリクエスト後、ポップ処理が完了するまで待機する、というのはベースシステム内のfg::EventProcsStackから破棄済みのゲームデータへの参照が起こらないようにする対処だったんだけど、やはりその場しのぎだったか。</p>
            <p>ゲームからなんの干渉もなく、ベースシステムからゲームへの参照が存在してしまっているのを、まずどうにかするべきなのだ。</p>
            <p>例えば、fg::EventProcsStackはゲーム内で生成し、それをベースシステムに登録する形にする、とか。</p>
            <p>当然、破棄もゲーム内で行なうので、ゲーム破棄後にベースシステムからゲームへの参照は起こらない。</p>
            <p>＊</p>
            <p>fg::EventProcsManagerの代替については、プッシュ時にポインタを返すようにし、それを破棄することでポップが行なわれる、というのを考えている。</p>
            <p>しかしそれだと、うっかり戻り値を拾い忘れたら大変な気がする。</p>
            <p>そんなこと言い出したら、今ある生成関数は全部そうなんだけど。</p>
            <p>つまり、その辺も対処が必要かも。</p>
            <p>生成関数はユニークポインタを返すようにして、戻り値を拾い忘れても自動で破棄されるようにする、とか。</p>
            <p>＊</p>
            <p>なかなかひどいけど、動かないことはないしなぁ。</p>
            <p>後回しでもいい気がする。</p>
            <p>あーあと、例外対応とログ出力もどうにかしたい。</p>
            <p>やるべきことは多いが、その全てを今やるわけにもいかない。</p>
            <p>コントローラ設定画面を作る上で直接関わってくるのは、やはりfg::EventProcs周りか。</p>
            <p>fg::EventProcsStackとfg::EventProcsManagerをペアで使えば、現状でもとりあえず動くものができるし、それでやろうかなぁ。</p>
            <p>＊</p>
            <p>いや、やはりfg::EventProcsManagerを除外した構成に変更するべきか。</p>
            <p>現状のfg::EventProcsManager破棄時の動作は、fg::EventProcsStack破棄時に行なうようにすればいい感じにまとまりそうなのだ。</p>
            <p>それに、ベースシステムにfg::EventProcsStackを登録する形にする際にも役立ちそうだ。</p>
            <p>登録型にできれば、fg::BasesystemEventProcsの排除ができるかもしれない。</p>
        </div>
        <hr />
        <div>
            <h2>2018/10/18 03:15</h2>
            <p>kasuteraの開発を進めようとして、ちょっと行き詰まっている。</p>
            <p>＊</p>
            <p>タイトルロゴのようなものを出した数秒後にメインメニュー画面に遷移する、という流れは問題なく書けた。</p>
            <p>タイトルロゴ画面とメインメニュー画面は別のソースファイルに分離できており、分かりやすい。</p>
            <p>問題はここからで、メインメニューを操作するためにはコントローラ設定が必要であり、その初回の処理をどう作ったものか。</p>
            <p>前に作った暫定的なものは画面が付いてないし、画像を扱えるようになったのでそれを利用した形にしたいが。</p>
            <p>＊</p>
            <p>で、その辺もやもやしててどうにも手を出しにくいので、tafの改修をしていた。</p>
            <p>今までは一応自動テストとかできてたけど、実際に使用する生成物やテストが混在しており、扱いにくかった。</p>
            <p>試運転するにも、モジュールのファイル1つ1つにシンボリックリンクを張らなければならかなったり面倒だった。</p>
            <p>そこで、テストとそれ以外の生成物を別のディレクトリに出力する形にして整理した。</p>
            <p>ただ、この形にするならコンパイラで生成するファイル以外にも、例えばパッケージファイルも生成物のディレクトリにコピーしたい。</p>
            <p>そういう機能は、既存のものをちょっと変えれば対応できそうだがまだないので、明日対応する。</p>
            <p>＊</p>
            <p>コントローラ設定画面はいまいちどうしたらいいか分からないと言っても、とりあえず作らないことにはどうしようもないことも確かなのだ。</p>
            <p>未知の領域なので、おおまかにどういったのを作りたいというのがあっても、それを最初から的確に作るのは難しい。</p>
            <p>とりあえずなんでもいいから作って、そこから目的の形に寄せていくしかない。</p>
        </div>
        <hr />
        <div>
            <h2>2018/10/12 01:20</h2>
            <p>PNG画像の対応完了。</p>
            <p>＊</p>
            <p>想定よりもフォーマットの数が多く苦戦したが、苦労の甲斐あっておそらく全てカバーできたはずだ。</p>
            <p>libpngにはインデックスカラーをRGBに変換する機能があったので、それを使ってインデックスカラーにも対応した。</p>
            <p>libpngもlibjpeg-turboと同じく、エラーの処理にsetjmp()を使う必要があるが、libjpeg-turboに比べればずっとましな気がする。</p>
            <p>何もしないとエラー時に勝手に終了してしまうのは同じだが、libpng自体がjmp_bufを使った構成になっていて、setjmp()を呼び出すだけでエラー時にlongjmp()で飛んでくるようになり、勝手に終了することはなくなる。</p>
            <p>png_structとpng_infoはそれぞれ別の関数で生成するのに、破棄は1つの関数で同時にするのがちょっと気持ち悪い、くらいか。</p>
            <p>＊</p>
            <p>JPEGとPNGに対応したので、karameruはこれでv1.0.0とした。</p>
            <p>画像を手軽に扱えるようになったので、これでkasuteraの開発に入れるかな。</p>
        </div>
        <hr />
        <div>
            <h2>2018/10/11 02:10</h2>
            <p>JPEG画像の対応完了。</p>
            <p>＊</p>
            <p>JPEG描画テストの、ライブラリを直接叩いてJPEG画像を読み込んでいた部分を差し替えたら70行ほど減っていい感じ。</p>
            <p>その上、グレースケールにも対応。</p>
            <p>ビルドしなおすことなく、読み込むファイルを変えるだけでカラーとグレースケールとも描画できることを確認した。</p>
            <p>カラーとグレースケールではフォーマットが違うが、fg::GLPictureの機能でそれに対応できていていい感じだ。</p>
            <p>＊</p>
            <p>今回libjpeg-turboを使用したが、なかなか動作が気持ち悪くていやな感じ。</p>
            <p>インターフェースがlibjpegのものを踏襲していると思われる？から仕方ないんだろうか。</p>
            <p>エラー時、何も対応しなければexit()で勝手に終了してしまったり。</p>
            <p>対応しようとするとlongjmp()を使ってエラー関数から元の関数までジャンプしなければならなかったり。</p>
            <p>その対応をするためのテスト用データとして、正常系で使っていたJPEGファイルを真っ二つにしたものを用意したのだが、なぜかそれを使ってもエラー扱いにならなかったり。</p>
            <p>その不正データはどこで不正と判断すればいいのかと色々いじくった結果、警告が発生するのでその回数をチェックすればいい、というのは分かったが、いじくってる過程でエラーメッセージ出力用関数を自前のものに変更していたら、警告回数が増えなくなっててチェックに使えなくなっていたり。</p>
            <p>ちなみに、何も対応しないとエラー時に勝手にexit()する挙動については、JPEGではないデータを読ませることで起こせる。</p>
            <p>その程度で死なないでほしいんだが。</p>
            <p>＊</p>
            <p>明日はPNGの対応を追加する予定。</p>
            <p>JPEGとの違いは、とりあえずはアルファ値か。</p>
            <p>あとはインデックスカラーというのもあるけど、こっちはひとまず後回しにする。</p>
            <p>まだ扱い方を知らないので、やりようがないのだ。</p>
            <p>インデックスカラー自体は、メモリ使用量削減とかパレット変更による色変えとか、ゲームに向いた特性を持っているので扱えるようになりたいところだ。</p>
            <p>＊</p>
            <p>この前の休みに、tafにPSPで動作するプログラムやプラグインのビルドルールを追加した。</p>
            <p>といっても、自動テストも作ってないしEBOOT.PBPは1プロジェクトにつき1つしか作れないし、リビルドには1回クリーンしなきゃならないなどなど、問題だらけで突貫工事もいいとこだが。</p>
            <p>ひどい状態だが、とりあえずビルドしたものが動くのを確認できたし、makeとかいうクソビルドツールを使わずにプラグインを作れるようになったわけで、空いた時間に色々いじっている。</p>
            <p>RemoteJoyLiteのソースらしきものをどこからか落としてきて持っているので、それを見ながらUSBの扱い方を調べているのだが、やはりというかなかなかひどいソースだ。</p>
            <p>特に意味もないのに配列でデータを持っているなんてのはまだましだが、初期化時に一時的にしか使わないデータがなぜかグローバルに置かれてるのはちょっとなぁ。</p>
            <p>USBの停止？関数はあってもどこからも呼び出されてなかったりもする。</p>
            <p>C言語だから仕方ない、というのもあるのだろうが。</p>
        </div>
        <hr />
        <div>
            <h2>2018/10/09 22:35</h2>
            <p>画像データを扱うためにfg::GLPictureを追加した。</p>
            <p>＊</p>
            <p>汎用的なものにしようかとも考えていたが、まずOpenGL以外では使わないだろうし、OpenGLに特化したものにすることにした。</p>
            <p>画像だからfg::GLImageの方がいいかと思ったが、OpenGLの関数にglImageなんたらというものがあったし、混同しないようにOpenGLの関数には存在しない単語を選んだ。</p>
            <p>＊</p>
            <p>JPEG画像の読み込み処理はちょっと前に書いたし、先に作ろう。</p>
            <p>その次にPNG画像読み込み処理を作る予定。</p>
            <p>とりあえずはその2つがあればどうにかなるだろう。</p>
            <p>むしろPNGだけでいいのでは、という気もするが。</p>
        </div>
        <hr />
        <div>
            <h2>2018/10/06 02:10</h2>
            <p>管理画面の名前はkasuteraとした。</p>
            <p>＊</p>
            <p>画像読み込みライブラリの名前はkarameru。</p>
            <p>名前は決まったが、具体的に読み込んだ画像データをどのように型で扱うのかが定まっていない。</p>
            <p>どうしたものか。</p>
            <p>＊</p>
            <p>画像を読み込む前に、パッケージのリソースにアクセスするためのインターフェースを復旧した。</p>
            <p>復旧した上で、今までよりもアクセスしやすい形に関数を追加した。</p>
            <p>これで画像ファイルの読み込みもやりやすくなった。</p>
            <p>いよいよ画像データの扱いについてまとめなくては。</p>
            <p>＊</p>
            <p>どうにも体調が優れない。</p>
            <p>季節の変わり目のせいだろうか。</p>
            <p>気温の変化が激しくて困る。</p>
            <p>土日はまた暑いらしいし。</p>
        </div>
        <hr />
        <div>
            <h2>2018/09/29 04:20</h2>
            <p>sucroseのベースシステムをzarameとして分離完了。</p>
            <p>＊</p>
            <p>これでベースシステムの内容を詰めやすくなった気はする。</p>
            <p>他のモジュール、例えば画像を扱うものとかを使いやすくなったし。</p>
            <p>しかしそれは今やることではないだろう。</p>
            <p>＊</p>
            <p>というわけで次はどうしよう。</p>
            <p>コントローラの扱いとかも確かに重要なんだが、それよりもメインメニュー画面というかランチャーというか、導入済みのゲームの起動、管理とか、コントローラの管理とか、そういった機能にアクセスするためのものを作るべきではないか。</p>
            <p>なんというか、それがないと始まらん気がするし。</p>
            <p>そろそろその辺りに手を出してもいいくらいには、機能も整ってきたように思う。</p>
            <p>まず名前を考えないといけないな。</p>
        </div>
        <hr />
        <div>
            <h2>2018/09/27 04:15</h2>
            <p>fg::BasesystemEventProcsManagerで発生していた問題を修正した。</p>
            <p>＊</p>
            <p>で、次に何をやるというか、そもそも何のためにCoreManagerとか作ったんだっけ、というのが朧げだったので過去の記事見たら書いてあった。</p>
            <p>zarame…そんなのもあったな…。</p>
            <p>ゲームから別のゲームを起動する機能については後回しでいい。</p>
            <p>ベースシステムの独立に当たり、気掛かりなのはbasesystemeventか。</p>
            <p>ベースシステムから分離はさせたものの、ベースシステムとの繋がりが強すぎる。</p>
            <p>できることならfg::BasesystemEventProcsとか作らず、全部fg::EventProcsで済ませたいが、それでうまくいきそうな案が出てこない。</p>
            <p>それができれば、fg::BasesystemEventProcs前提の構成になってるfg::EventProcsの実装をもっと単純にできるのだが。</p>
            <p>＊</p>
            <p>とりあえずは、sucroseからベースシステムをzarameとして別のプロジェクトに分離するか。</p>
        </div>
        <hr />
        <div>
            <h2>2018/09/26 03:20</h2>
            <p>candymaker::CoreManagerの追加完了。</p>
            <p>＊</p>
            <p>ゲームの稼働を確認し、余分な関数の削除、その代替機能の追加、不要になったファイルの削除まで完了し、バージョンも確定させた。</p>
            <p>しかしながら、sucroseで一部テストが通ってない部分がある。</p>
            <p>ゲームの稼働で問題は起きてないとはいえ、少なくも1つはNULLポインタの参照なので解決しておきたい。</p>
        </div>
        <hr />
        <div>
            <h2>2018/09/22 04:10</h2>
            <p>想像よりも大幅に時間がかかっているが、終わりは見えてきた。</p>
            <p>＊</p>
            <p>残件は余計に追加してしまった関数の削除、その部分の代替機能の追加、不要になるファイルの削除、か？</p>
            <p>来週中にはゲームが稼働できることを確認したい。</p>
            <p>で、不要なファイルを削除してバージョンを確定させたい。</p>
        </div>
        <hr />
        <div>
            <h2>2018/09/07 00:35</h2>
            <p>明日一杯使っても難しいかもしれない。</p>
            <p>＊</p>
            <p>やる気がびみょうというのも大きいけど、sucroseのベースシステムに内包する要素を全て修正する必要があるのがきつい。</p>
            <p>1つ1つ地道に修正していくしかないが、構成が変化しているため単純な修正で対応できるのかどうか。</p>
            <p>想定では、今までfg::BasesystemContextの参照を引数に含んでいた関数を、fg::GameContextの参照を引数に含むものも用意することで対応できそうな気がするが。</p>
            <p>＊</p>
            <p>今までfg::BasesystemContextの参照を用いていたところを、sucrose::Basesystemの参照に変更する。</p>
            <p>sucrose::Basesystemの参照はfg::BasesystemContextかfg::GameContextから取得できるので、両方用意しておけば問題ない、といった具合。</p>
            <p>しかしfg::BasesystemContextの参照を用いる関数は、fgに追加するべきか、sucrose内の仕様に留めるべきか。</p>
            <p>現状ではどちらでもよい、と言わざるを得ないな。</p>
            <p>ゲーム側から使用することはまずないことを考えると、sucrose内の仕様に留めておくべきかもしれない。</p>
        </div>
        <hr />
        <div>
            <h2>2018/09/06 00:15</h2>
            <p>candymakerの処理を、candymaker::CoreManagerを使ったものに切り替えた。</p>
            <p>＊</p>
            <p>これがきちんと動作するか確認するためには、sucroseのベースシステムを新しい仕様に対応させる必要がある。</p>
            <p>起動するゲームについても同様だ。</p>
            <p>とはいえ、ベースシステム内の処理内容は基本的にいじくる必要はないし、明日中、ないしは今週中に対応して確認したいところ。</p>
            <p>確認が取れたら、古い仕様や間違って追加してしまった機能の削除だ。</p>
        </div>
        <hr />
        <div>
            <h2>2018/09/01 00:10</h2>
            <p>よくない感じがする。</p>
            <p>＊</p>
            <p>fg::BasesystemContextの参照を用いて行なっていた操作について、対応できるようにしていたが、対応を間違えた感触がある。</p>
            <p>fg::BasesystemContextの初期化時に関数ポインタを設定し、fg::GameContextの参照を経由して設定した関数を呼び出す、という仕組みにしているが、fg::GameContextの参照を経由する必要があるのかどうか。</p>
            <p>そもそも、fg::BasesystemContextやfg::GameContext自体に機能を追加するというのが間違っている気がする。</p>
            <p>そういったものに対する操作というのは、厳密にはそれ自体ではなく、それらが抱えているデータにアクセスできればいいのだ。</p>
            <p>実際、そういった方法で動作している機能もある。</p>
            <p>分離しにくいから、というだけでfg::BasesystemContext自体に機能を置いてしまっていたのが否めない。</p>
            <p>＊</p>
            <p>なので、fg::GameContextやfg::BasesystemContextからは、データの取得だけできる形に変更し、抱えてるデータを扱う処理はcandymakerに完全に含めない形にするべきだろう。</p>
        </div>
        <hr />
        <div>
            <h2>2018/08/29 00:10</h2>
            <p>先週末までに起動処理作り切りたかったけど、無理だった。</p>
            <p>＊</p>
            <p>で、今日出来上がった。</p>
            <p>モジュールもベースシステムもゲームも、設定可能な関数は初期化関数のみになり、いい感じ。</p>
            <p>ただ、fg::GameContextを作った関係で、今までfg::BasesystemContextの参照に対して行なっていた操作の一部は、fg::GameContextからfg::BasesystemContextを参照しないと動作できなくなってしまっている。</p>
            <p>その辺り作っていかないと。</p>
            <p>でもまぁ、fg::BasesystemContextの初期化時に関数ポインタを設定できるようにして、fg::GameContextからその関数にアクセスすればできると思うし、難しくないはずだ。</p>
        </div>
        <hr />
        <div>
            <h2>2018/07/25 02:30</h2>
            <p>やっとcandymaker::ModuleManagerができた。</p>
            <p>＊</p>
            <p>モジュールのロード以外に、モジュールの不要判定、不要になったモジュールのアンロードやロード中のエラー対応など、必要になる機能を色々と追加した。</p>
            <p>ただ、今のままでは複数のモジュールの生成・破棄処理のペアリングがされていないので、その対応のためにもう1つ型を作るべきかもしれない。</p>
            <p>そこまで済めば、ベースシステムの対応に入れるか。</p>
            <p>＊</p>
            <p>candymaker::BasesystemInfoは必要ないかもしれない。</p>
            <p>単に、それに含める予定だったものを、ベースシステム生成時に引数として渡す。</p>
            <p>まとめて扱う意味があまりなさそうなのだ。</p>
            <p>今回作ったcandymaker::ModuleManagerでロードするモジュールの情報はcandymaker::ModuleInfoという型にまとめたが、それは一度に複数のモジュールをロードするために、モジュールの情報をまとめる必要があったからだし。</p>
        </div>
        <hr />
        <div>
            <h2>2018/07/07 01:50</h2>
            <p>ようやくどうにかなるかもしれない。</p>
            <p>＊</p>
            <p>目的、つまり関数の動作と、そのために必要なもの、つまり関数の引数を、もっと明確にするだけでよかったのだ。</p>
            <p>ベースシステムの起動という目的を達成するためには、ベースシステムを構成するモジュールのロードと、イニシャライザの実行が必要だ。</p>
            <p>なら、引数はロードするモジュール群の情報と、イニシャライザのシンボル名だ。</p>
            <p>それらをまとめて、candymaker::BasesystemInfoとしよう。</p>
            <p>candymaker::BasesystemInfoは、少なくとも初回の起動においては、ショートカットファイルを解析して生成する。</p>
            <p>その過程で、パッケージ情報ファイルや設定ファイルを読むことになるだろう。</p>
            <p>＊</p>
            <p>いままでの構成では、モジュールのロードは外部で済ませており、ベースシステムの起動処理はイニシャライザの実行だけだったが、これはよくない。</p>
            <p>モジュールのロードは必要に応じて行なわれるべきものであり、それを目的の外でやってしまうのは、なんのためにモジュールのロードが必要だったのか、という関連付けを薄くしてしまう。</p>
            <p>そうなると、後から見返した時に処理の意図が読みにくくなる。</p>
            <p>＊</p>
            <p>その辺の意味では、現状のモジュールロード周りもよくないな。</p>
            <p>パッケージ設定ファイルを解析したものをそのまま渡したりしている。</p>
            <p>具体的に何が必要なのか、引数を明確にするべきだな。</p>
            <p>新しく作る方には、candymaker::ModuleInfoとかいう型でも作って、そこに必要な情報をまとめるか。</p>
        </div>
        <hr />
        <div>
            <h2>2018/06/30 04:15</h2>
            <p>とりあえずパスについては完了。</p>
            <p>＊</p>
            <p>今までは○○Refという型名だったが、○○Pathに変更にした。</p>
            <p>また、dataelementからデータを取り出し生成する形だったものをやめた。</p>
            <p>その辺の処理はファイル解析側にまとめることにした。</p>
            <p>＊</p>
            <p>ショートカットファイルの読み込みと解析をするためには、あとはファイル読み込み処理の移行が必要なぐらいか。</p>
            <p>dataelementについては、ひとまず今存在するものをそのまま使う。</p>
        </div>
        <hr />
        <div>
            <h2>2018/06/28 01:10</h2>
            <p>まだかなりぼんやりしている。</p>
            <p>＊</p>
            <p>アイデアは出てくるのだが、まとまりはいまいちだ。</p>
            <p>fgのインターフェースのうち、candymakerで実装するべきものはfg-coreにまとめるとよさそう。</p>
            <p>現時点で対象となっているのは、fg-dataelementとfg-module。</p>
            <p>新たに追加するfg::GameContextとfg::BasesystemContextも含まれる。</p>
            <p>＊</p>
            <p>パッケージマネージャが必要と言ったが、実際にはもっと広い範囲をカバーしないとだめだ。</p>
            <p>具体的には、稼働しているベースシステムやゲームも含む、ということだ。</p>
            <p>candymaker内のfg-coreと関わりが深くなりそうだし、candymaker::CoreManagerという名前にしようかと考えている。</p>
            <p>candymakerの起動と同時に生成し、破棄と同時に終了する。</p>
            <p>今の仕様ではコマンドライン引数を元にベースシステムやゲームを起動する、という形だが、将来的にはコマンドライン引数が渡されなかった場合はデフォルトのベースシステムやゲームを起動するようなこともさせたい。</p>
            <p>＊</p>
            <p>fg::BasesystemContextがありなら、fg::ModuleContextもありだろう。</p>
            <p>これまたすでにその名前の型はあるのだが。</p>
            <p>現時点ではモジュールの初期化と終了で2つの関数が必要だけど、fg::GameContextに倣う形にすることで初期化関数1つだけで済む形にする。</p>
            <p>そのようにしたら、ゲーム、ベースシステム、モジュールの各初期化関数は、固定のシンボル名じゃなくていい気がするな。</p>
            <p>過去にそうしていたように、設定ファイルにシンボル名を記述する形にしたい。</p>
            <p>＊</p>
            <p>とりあえず、candymaker::CoreManagerを作っていこうと思う。</p>
            <p>ベースシステムやゲームの生成に必要なので、これを作らないことにはどうしようもない。</p>
            <p>モジュールの読み込み処理などの既存の記述は使うが、ファイルの位置を変更する予定。</p>
            <p>その過程で、型の名前とか変えたりするかもしれない。</p>
        </div>
        <hr />
        <div>
            <h2>2018/06/27 11:05</h2>
            <p>fg::GameContextと同じように、fg::BasesystemContextも用意するべきか。</p>
            <p>＊</p>
            <p>その名前の型はすでにあるんだけど、それとは違う。</p>
            <p>すでにあるfg::BasesystemContextはベースシステム本体を表している。</p>
            <p>今回考えたfg::BasesystemContextは、ベースシステムのデータを管理するための型だ。</p>
            <p>fg::BasesystemContextの実装はcandymaker内に用意し、ベースシステム本体はfg::BasesystemContext内のデータ領域内、という形になるわけだ。</p>
            <p>これがあることで、今はベースシステムの生成と破棄、2つの関数をdlsym()で取得しているが、それが初期化関数の1つで済むようになる。</p>
            <p>＊</p>
            <p>などということを考えたが、いい加減妄想膨らませるだけでなく作業をしたいところだ。</p>
            <p>どこから手を付けるべきか、難しい。</p>
            <p>大きく分けて、ベースシステム起動処理と、ゲーム起動処理を修正する必要がある。</p>
            <p>ベースシステム起動処理の変更は、ゲーム起動処理にも影響を及ぼす。</p>
            <p>しかし、ベースシステム起動処理の変更の影響を、古いゲーム起動処理に適用するのはいらない手間な気がする。</p>
            <p>そう考えると、まずゲーム起動処理を修正するか。</p>
        </div>
        <hr />
        <div>
            <h2>2018/06/27 00:50</h2>
            <p>パッケージマネージャーだな。</p>
            <p>＊</p>
            <p>ベースシステムからの、必須機能以外の独立はすでに済ませた。</p>
            <p>ゲーム起動インターフェースをfgに追加するに当たり、イメージがぼんやりとしていてまとまらず、手を出せないでいた。</p>
            <p>モジュールの管理機能をベースシステム内に配置するわけだし、ベースシステムの関数としてゲーム起動関数を用意しようかと考えていたが、それは変だ。</p>
            <p>それだとベースシステム内にゲーム起動機能が存在することになる。</p>
            <p>モジュールの管理機能自体はベースシステムの外に用意し、ベースシステム内には参照だけ配置するのだから、ならゲーム起動関数もベースシステムの外にあるべきだ。</p>
            <p>で、ゲームを起動するに当たっては、設定ファイルも読める必要がある。</p>
            <p>単に読むだけでなく、どの設定ファイルによってどのモジュールを読み込んだかなど、管理機能もあった方がいい。</p>
            <p>＊</p>
            <p>できればsucrose内に配置したいところだが、candymaker内になりそうな気がする。</p>
        </div>
        <hr />
        <div>
            <h2>2018/06/21 03:30</h2>
            <p>とりあえずタスク処理について独立させた。</p>
            <p>＊</p>
            <p>次はベースシステムのイベント処理だ。</p>
            <p>しかし、構成を何も変えず独立させたので、いまいち作りがよくないように見える。</p>
            <p>後々、その辺変えるべきか。</p>
        </div>
        <hr />
        <div>
            <h2>2018/06/20 01:30</h2>
            <p>ベースシステムの生成はいいが、ゲームの起動処理をどうするかよく考えるべきだな。</p>
            <p>＊</p>
            <p>少なくとも、現在の構成ではゲーム中から別のゲームを起動する、ということができない。</p>
            <p>それをするには、ゲーム側でパッケージや設定ファイルを読める必要があるわけだが、それがないからだ。</p>
            <p>つまりfgにそれらのインターフェースを追加する必要があるわけか。</p>
            <p>かなり大変そうだし、後回しにしたいなぁ。</p>
            <p>＊</p>
            <p>zarameを進めたかったが、そう考えると無理だな。</p>
            <p>ベースシステムに必須ではない機能を別のモジュールに分ける、の方が先か。</p>
        </div>
        <hr />
        <div>
            <h2>2018/06/19 01:20</h2>
            <p>sucroseのベースシステムを独立させたもの、これをzarameとする。</p>
            <p>＊</p>
            <p>プロジェクト名も決まったことだし、今日中に準備を済ませて明日から本気出す。</p>
        </div>
        <hr />
        <div>
            <h2>2018/06/16 00:40</h2>
            <p>最近、気温の変化が激しすぎるためか体調が優れない。</p>
            <p>＊</p>
            <p>そのせいもあり、やる気もうまく上がらない。</p>
            <p>来週もこうだと困るなぁ。</p>
            <p>せめてどこから手を付けるかだけは、今のうちにきちんと決めておこう。</p>
        </div>
        <hr />
        <div>
            <h2>2018/06/14 01:40</h2>
            <p>fg::GameContextを作るべきか。</p>
            <p>＊</p>
            <p>少なくとも今の設計では、ゲームから別のゲームを呼び出す、というのが困難に思える。</p>
            <p>別のゲームを呼び出し、終えたら元のゲームに戻る、というような動作をするためには、元のゲームの状態を保持しておく必要がある。</p>
            <p>今のところ何が必要なのかまだもやもやしているが、少なくともfg::EventProcsManagerは持っておく必要があるな。</p>
            <p>正確にはfg::BasesystemEventProcsManagerか。</p>
            <p>あとはゲームのデータも、今はcandymakerの関数内ローカル変数に1つだけだが、fg::GameContext内に持たせるべきだろうな。</p>
            <p>そうなると、ゲームの初期化や終了関数の構成も変わってくる。</p>
            <p>とりあえず、fg::BasesystemContextと似た機能を持った型は必要だろうが、それをゲーム側から直接参照できる必要はない気がする。</p>
            <p>fg::GameContextの参照を引数に持つ初期化関数だけでいい感じか。</p>
            <p>現状、終了関数とかfg::GameDataのdeleteしかしてないし、おまじないじみたコードが減るのはいいことだ。</p>
            <p>その代わり、ベースシステム側は機能が増える。</p>
            <p>fg::BasesystemContextの参照を引数にfg::GameContextを生成する関数は必要になるだろうし。</p>
            <p>＊</p>
            <p>ベースシステム本体の独立と合わせて、その辺も改良していきたいところだ。</p>
        </div>
        <hr />
        <div>
            <h2>2018/06/13 01:10</h2>
            <p>ベースシステム本体はsucroseから切り離すべきかもしれないなぁ。</p>
            <p>＊</p>
            <p>そこ以外は、完全にただのライブラリなのだ。</p>
            <p>しかしベースシステムは画面の表示などのために画像や音声などのリソースも必要になる。</p>
            <p>そういったものが純粋なライブラリ内に混在してるのは違和感がある。</p>
            <p>現状のベースシステムには、タスクやイベントの管理などがまとめられてしまっているので、それらを独立させ、ベースシステムはそれらを外部から利用する形にした方がいいかも。</p>
            <p>＊</p>
            <p>今想定している作りとしては、以下のような感じ。</p>
            <p>・基本インターフェース定義（fg）</p>
            <p>・基本インターフェースを持つライブラリ（sucrose）</p>
            <p>・基本インターフェースを持つベースシステム</p>
            <p>・基本インターフェースを持つゲーム</p>
            <p>・基本インターフェースを持ったベースシステム上でゲームを動かすプログラム（candymaker）</p>
            <p>ベースシステムやゲームは、sucrose以外にも画像や音声の処理を行なうライブラリも利用する形になる。</p>
            <p>そっちはそっちで、基本インターフェースからは外れるライブラリを用意する。</p>
            <p>ベースシステムも、インターフェースが異なるだけでどちらかと言えばゲームに近いのだ。</p>
            <p>だからゲームと同じように独立させるべきだと思う。</p>
            <p>＊</p>
            <p>しかしながら、ベースシステム側では必要でも、ゲーム側では必要ないインターフェースも多くある。</p>
            <p>ベースシステムは基本インターフェースにだけ依存させるのではなく、ライブラリに依存させた方がいいかも。</p>
        </div>
        <hr />
        <div>
            <h2>2018/06/07 03:25</h2>
            <p>とりあえず、あとはサンプラのリソース管理だけ。</p>
            <p>＊</p>
            <p>可能な部分は、より機能を簡単にしたバインダーも作るけど。</p>
            <p>この次何を進めるべきか、考えておかないといけないな。</p>
            <p>OpenGLのバージョンの管理というか、特定のバージョンで扱うと決めたら、そのバージョンには存在しない関数は呼び出そうとしてもコンパイルエラーになるとか、そういった機能も追加したいが、それは緊急でもないし。</p>
        </div>
        <hr />
        <div>
            <h2>2018/06/05 20:20</h2>
            <p>…自分で作った方が早いかもしれない。</p>
            <p>＊</p>
            <p>livedoorブログやらBloggerやらで、今のこのサイトみたくスタイルシートとかまるで使わんシンプルな表示にしようとしても、テーマいじくるのが非常にめんどくさい。</p>
            <p>ブログ自体にどういった機能があるのか、何ができて何ができないのかについてもいまいち分かりづらい。</p>
            <p>スタイルシートを全く使わんようにすると、コメントとかその辺の機能に支障が出るようだし。</p>
            <p>デフォルトのテーマのまま使えばいいんだが、気が乗らない。</p>
            <p>で、既存のよくあるシステムとは一線を画したシステムを作ってみるのもいいかなーという気もしてきている。</p>
            <p>やるんなら休日だけど。</p>
            <p>＊</p>
            <p>平日の作業とは関係ないことに時間を使いすぎた。</p>
            <p>VAOやらシェーダやらのリソース管理のための型を追加するとしよう。</p>
        </div>
        <hr />
        <div>
            <h2>2018/06/05 17:00</h2>
            <p>VAO便利だな。</p>
            <p>＊</p>
            <p>VAOを使わない場合、VBOやIBOを1つずつバインドしたりする必要がある。</p>
            <p>VAOを使えば、それらは事前にしておき、描画時にはVAOをバインドするだけで済む。</p>
            <p>気掛かりなのは、VAOにIBOを含められるのかどうか、という点だ。</p>
            <p>個人の解説ページでは、含められると書いてあるところもあれば含められないと書いてあるところもある。</p>
            <p>実際に試し、可能であることは確認したのだが、本当に正しく機能を扱えているのかどうかはあまり自信がない。</p>
            <p>もしかしたら、含められないというのは古いバージョンの話で、新しいバージョンでは含められるようになった、ということかもしれない。</p>
            <p>あるいは、全く別の機能で実現できている可能性もないではないだろう。</p>
            <p>公式の情報が欲しいところだ。</p>
            <p>＊</p>
            <p>OpenGLのリソースについて、バインド状態をRAIIで管理するのは困難を極めるのではないかと思えてきている。</p>
            <p>テクスチャのバインドについては前に書いた通りだが、バッファのバインドの方はきっと問題ないだろうと思っていた。</p>
            <p>が、VAOを使う場合、VAOにIBOの設定を登録するには、VAOをバインドした後にIBOをバインドし、IBOのバインドを解除せずにVAOのバインドを解除する必要がある。</p>
            <p>VAOのバインドを解除した後にIBOのバインドを解除する、というのは違和感がある。</p>
            <p>VAOをバインド中にバインドしたIBOとは別のもののバインドを解除してしまう、つまり整合性が取れてないように思うのだ。</p>
            <p>VAOに対してはIBOはバインドしっぱなしにする必要があり、あえて解除するというのであれば、別のIBOに変更する時とか、VAOを破棄する前とかそのくらいだろう。</p>
            <p>バインダなんていうのは、きちんとやろうとすると複雑になりすぎるので、作らない方がいいかもしれない。</p>
            <p>＊</p>
            <p>いい加減、ブログを借りようかと考えている。</p>
            <p>月や年ごとにページ切り分けるのが面倒になって、3、4年ほどの内容が1つにまとまってしまったが、HTMLの行数にして5000行以上あり、vimで編集しているとちょっともたつくことがある。</p>
            <p>文字に様々な装飾を施すだの、リンクを張ったりなどということはほぼしないため、タグ直打ちでもそれほど作業負荷は高くないのだが。</p>
            <p>昔であれば、じゃあそういうシステムを自分で作ろう、とかとち狂ったことを考えるのだろうが、今はもうそんな無駄なことはしたくない。</p>
            <p>きちんと作るとなると手間がかかりすぎるし、その手間をかけてやっとできる、というよりそれよりもよいシステムが借りられるなら、それを使えばいいのだ。</p>
            <p>ライブドアとかそのへんのブログを借りてみようかなぁ。</p>
        </div>
        <hr />
        <div>
            <h2>2018/06/04 01:20</h2>
            <p>PSPのプラグインを作りたくて、色々いじくっていた。</p>
            <p>＊</p>
            <p>完全に趣味なので平日はやらない。</p>
            <p>外部コントローラでPSPを操作できるようにしたいのだ。</p>
            <p>そのような機能を持ったプラグインはすでに存在するが、raspberrypiにPSPとUSBコントローラをつないで操作する、という条件下だとうまく動くものはなかった。</p>
            <p>で、あるかも分からないものを探すよりも自分で作った方が早い、ということだ。</p>
            <p>幸い、PSPの開発環境についてはプラグインを探す過程でソースからビルドしたりすることもあったのですでにある。</p>
            <p>が、1から作ったことはなかったので、今日はHello, world!!と画面に表示するプログラムを作り、いじくったりしていた。</p>
            <p>＊</p>
            <p>ネット上に転がっているサンプルソースは、スレッド処理のくせに排他制御していない無茶したソースだったり、色々試して分かったがそもそもスレッド作る必要なかったりと色々ひどかった。</p>
            <p>ゲーム終了のコールバック関数を呼び出すためのスレッドとか、作る必要はない。</p>
            <p>main()でコールバック関数を登録し、sceKernelWaitSemaCB()で待機すればいい。</p>
            <p>コールバック関数内でsceKernelWaitSemaCB()の待機に使っているセマフォを操作してやれば完璧。</p>
            <p>第一、スレッドで待機してるサンプルソースではsceKernelSleepThreadCB()で待機してるけど、それを起こす処理やスレッドの終了、破棄といった処理が全く書かれていないのだが大丈夫なのだろうか。</p>
            <p>パソコンのデスクトップOSみたく、PSPのそれもプログラム終了でそれに関連したリソースは全て破棄してくれるようなきちんとしたものなのだろうか。</p>
            <p>正直に言えばパソコンのデスクトップOSについてもその辺は伝聞なので、具体的にどうなってるのとか全然知らないんだけど。</p>
            <p>＊</p>
            <p>C++でも書けるようなので、std::unique_ptrを使ってスマートにリソース管理したプログラムを作ろうと思う。</p>
        </div>
        <hr />
        <div>
            <h2>2018/06/02 19:50</h2>
            <p>昨日は朝までがんばって、プログラマブルシェーダを使った描画テストを作っていた。</p>
            <p>＊</p>
            <p>がんばっただけあって、なかなかの成果が得られた。</p>
            <p>一番のやらかしは、uniform変数の位置取得関数を間違えたこと。</p>
            <p>in変数と同じようにglGetAttribLocation()で取得しようとして、うまくいかんなーってのを30分くらいずっとやってた。</p>
            <p>uniform変数に対してはglGetUniformLocation()を使わないとだめ。</p>
            <p>当たり前と言われればそれまでなんだが。</p>
            <p>＊</p>
            <p>テクスチャバインダは役に立たない、というより設計がOpenGLの仕様と噛み合ってないようだ。</p>
            <p>3Dはまだあまり詳しくないので、マルチテクスチャとか知らなかったのだ。</p>
            <p>glActiveTexture()でアクティブにしたテクスチャユニットに対し、glBindTexture()でテクスチャをバインドする。</p>
            <p>それにより、複数のテクスチャをかけ合わせた描画ができる。</p>
            <p>そんなものの存在を知らなかったので、私が作ったテクスチャバインダは同時に1つのテクスチャしかバインドできない。</p>
            <p>＊</p>
            <p>私の作ったバインダというのは、用が済んでもバインドされっぱなしなのは気分が悪い、というのを解消するために作った。</p>
            <p>破棄時に、初期値にバインドし直してバインド状態を解除するのだ。</p>
            <p>リソースの生成・破棄と違い、そんなに神経質になることはないとは思う。</p>
            <p>しかしながら、バグの温床になりそうな気がするのも確か。</p>
            <p>形を変えて使いたい気持ちはある。</p>
            <p>ちなみに、現在の実装ではバインダを生成・破棄すると見せかけて、生成時にはバインド成功時に引数で渡したコンテキストの参照をキャストして返すだけ、破棄時にはコンテキストの参照にキャストし直してバインドを解除するだけであり、newやらdeleteやらはしていない。</p>
            <p>テクスチャユニットを考慮した実装にするとなると、コンテキスト以外にテクスチャユニットについての情報を格納する必要があるから、どこかにその領域を確保する必要があるなぁ。</p>
            <p>＊</p>
            <p>シェーダとはまた別に、思い付いて試した結果、ウィンドウとOpenGLコンテキストの関係も見直した方がいいかもしれない。</p>
            <p>1つのウィンドウと2つのOpenGLコンテキストを用意し、片方のOpenGLコンテキストで描画後、もう片方に切り替えて描画、そして表示、という処理を試したところうまくいった。</p>
            <p>後の方の描画処理で透過処理を試してもうまくいく。</p>
            <p>今まであまり考えたことがなかったのだが、描画データはウィンドウ側が持っているんだな。</p>
            <p>当たり前と言えば当たり前なんだけど。</p>
            <p>ゲーム側で描画したゲーム画面の上に、管理側が管理情報を上書きして表示、というようなことをする場合、それぞれOpenGLコンテキストを別々に持っていた方がうまく行く気がする。</p>
            <p>1つしかない場合、ゲーム側が関知しないところで管理側に違うテクスチャをバインドされて、ゲームの表示がおかしくなった、とかそんな感じのことが簡単に起こりそうだ。</p>
            <p>現状では、OpenGLの描画をスレッドで行なうためのfg::GLTaskというものがあるが、これはウィンドウとOpenGLコンテキストを1対1で扱っている。</p>
            <p>複数のコンテキストを使い分けるようなやり方をするのは困難だ。</p>
            <p>最終的にバッファをスワップするのに使うコンテキストは固定で構わないと思うし、その辺りの作りは現状のままでいいだろう。</p>
            <p>ただ、描画処理の引数でカレントコンテキストの参照を渡しているのは間違いだな。</p>
            <p>渡すのはせいぜいウィンドウの参照…と思ったが、コンテキストのメンバにウィンドウの参照があるから、カレントコンテキストの設定にウィンドウの参照はいらないんだった。</p>
            <p>現状ではカレントコンテキストを生成→カレントコンテキストの参照を描画処理に渡して描画→バッファをスワップ、としているが、描画処理→カレントコンテキストを生成→バッファをスワップとすべきか。</p>
            <p>＊</p>
            <p>最後の件に関しては、早急に対応するべきだろうな。</p>
            <p>管理側のOpenGLコンテキストをゲーム側から参照できるようにする必要がなくなるということなので、その辺りにも修正が必要になりそう。</p>
        </div>
        <hr />
        <div>
            <h2>2018/06/01 03:40</h2>
            <p>バッファの管理できた。</p>
            <p>＊</p>
            <p>JPEG描画テストで使ったところ、ソースが100行ほど増えたが仕方がない。</p>
            <p>元のソース、バッファのバインド解除どころか破棄もやってない手抜き具合だったし。</p>
            <p>むしろその辺きちんと加えても100行程度の増加で済んだことを評価したい。</p>
            <p>＊</p>
            <p>とりあえずここで一旦バージョンを確定させて、次はプログラマブルシェーダとか用いたOpenGL3以降の書き方でJPEG描画テストプログラムを作る。</p>
            <p>それでどういった要素が必要なのか把握してから、管理機能の追加をしていこう。</p>
            <p>＊</p>
            <p>ちなみにテクスチャやらバッファやらの管理を作ったと言ったが、完全に網羅できているわけではない。</p>
            <p>バインダは機能が限定的だ。</p>
            <p>テクスチャはGL_TEXTURE_2Dのみ、バッファはGL_ARRAY_BUFFERとGL_ELEMENT_BUFFERの2つだけ。</p>
            <p>今のところ必要だったのはそれらだけだったので仕方がない。</p>
            <p>最終的には全て対応するべきだと思うが、既存のものを参考にすればぱっと作れるはずだ。</p>
        </div>
        <hr />
        <div>
            <h2>2018/05/31 03:30</h2>
            <p>OpenGL2でも、VBOは扱えるんだな。</p>
            <p>＊</p>
            <p>JPEG描画テストの描画をVBOで行なうように変更し、バッファの管理についてはほぼテクスチャの管理と同様の構成で作れるのは把握した。</p>
            <p>明日中に作ってしまいたいところ。</p>
            <p>それが済んだら、JPEG描画テストプロジェクトをコピーして、OpenGL3を使った描画のテストプロジェクトを作ろう。</p>
        </div>
        <hr />
        <div>
            <h2>2018/05/30 04:10</h2>
            <p>テクスチャバインダ完成。</p>
            <p>＊</p>
            <p>作った処理を使ってJPEG描画テストを修正したら、ソースが100行ほど少なくなった。</p>
            <p>大体どのような構成で機能を作ればいいか分かってきたし、OpenGL3で使うバッファやら、サンプラ？やらも追加していくとしよう。</p>
        </div>
        <hr />
        <div>
            <h2>2018/05/25 02:30</h2>
            <p>テクスチャの件についてはなんとかなった。</p>
            <p>＊</p>
            <p>一度作ったテクスチャを削除した場合、glGetTexImage()でデータが取得できないのを利用することで、テクスチャの破棄についてのテストを書くことができた。</p>
            <p>しかし、windowsでも同じような挙動をしたのには参った。</p>
            <p>まさか、あんなくそみたいな動作が仕様通りだとでも言うのか。</p>
            <p>＊</p>
            <p>とにかく、テクスチャの生成と削除の管理はできた。</p>
            <p>次はテクスチャのバインドの管理かな。</p>
            <p>テクスチャ管理と関係を持たせたいところではあるのだが、なかなか難しそうな気がする。</p>
            <p>バインドというのは資源でなく状態だし、どちらかと言えばfg::GLTexturesよりfg::GLCurrentContextに近くなる気がするな。</p>
            <p>しかし、fg::GLCurrentContextはスレッドに紐付くが、バインドの状態はfg::GLContextに紐付く。</p>
            <p>多少めんどそうな気がするが、イメージはできたかもしれない。</p>
        </div>
        <hr />
        <div>
            <h2>2018/05/23 03:10</h2>
            <p>OpenGL、つらい。</p>
            <p>＊</p>
            <p>いや、実際には実装のmesaがつらいのかもしれない。</p>
            <p>テクスチャの生成と破棄を管理する型を作ろうとしているのだが、テクスチャがきちんと破棄されたか知る方法がないように思える。</p>
            <p>glDeleteTextures()が実行されれば破棄されると思うかもしれないが、なぜかOpenGLコンテキストをglXMakeCurrent()でカレントに設定していなくても成功してしまう。</p>
            <p>ならばと直後にglGetError()を呼び出しても、得られるのはGL_NO_ERROR。</p>
            <p>これは仕様ではテクスチャ数にマイナスを指定した場合にGL_INVALID_VALUEになる、としかないので仕方ないのだろう。</p>
            <p>だったら、glDeleteTextures()で破棄したテクスチャ番号をglBindTexture()すれば、無効なテクスチャ番号ならGL_INVALID_VALUEになるはず、と思ったがやはりGL_NO_ERROR。</p>
            <p>であればその破棄されたテクスチャ番号に対し、glTexImage2D()でデータを流し込んだり、glTexParameter()でパラメータを設定したりすればさすがにSEGVとか起きるだろう、と思ってもそんなことは起きない。</p>
            <p>エラーなど起きなくても設定対象は存在していないのだし、設定したものをglGetTexImage()やglGetTexParameter()で取得すれば設定したものとは違う値が取れるか、とも思ったけど問題なく（？）取れる。</p>
            <p>そもそもglGenTextures()しなくてもテクスチャを扱えてしまう。</p>
            <p>もはやお手上げである。</p>
            <p>さすがにこれがOpenGLの仕様とは思いたくないなぁ。</p>
            <p>＊</p>
            <p>明日、windowsの方でも試してみようと思う。</p>
        </div>
        <hr />
        <div>
            <h2>2018/05/16 21:20</h2>
            <p>大体検証できた。</p>
            <p>＊</p>
            <p>eglに関しては、glxと同じようにeglMakeCurrent()でウィンドウに当たる部分をnullにしても正常に動作した。</p>
            <p>wglについては作業中にOSが死んだため途中までしか検証できず、wglMakeCurrent()の動作については確認できなかったが、それ以外の部分で発見があった。</p>
            <p>wglの場合、OpenGLコンテキストに当たるものを生成する際にウィンドウに当たるものが必要になるのだ。</p>
            <p>glxやeglはウィンドウとOpenGLコンテキストの間に直接的な関係性はなく、glXMakeCurrent()やeglMakeCurrent()で結び付けられることによって機能するようになる。</p>
            <p>eglについてはきちんと確認したわけではないので、憶測だが。</p>
            <p>ともかく、wglにおいてはOpenGLコンテキストを生成するためにはウィンドウが必須であり、他のもので代用してコンテキストを生成し、makeCurrent()で結び付ける、というような処理をしても描画ができなかった。</p>
            <p>前々から関数の構成に疑問があったが、やはりウィンドウとOpenGLコンテキストは1対1で考えるべきものなんだろうな。</p>
            <p>＊</p>
            <p>fg::GLContextのメンバに、fg::Windowの参照を持たせる形にするべきか。</p>
            <p>それでfg::GLCurrentの生成をfg::GLContextの参照のみで行なうようにすれば、目的のインターフェースにした上で未定義かもしれない動作をさせることもしなくて済む。</p>
        </div>
        <hr />
        <div>
            <h2>2018/05/16 02:00</h2>
            <p>fg::GLCurrentの仕様を考え直すべきかもしれない。</p>
            <p>＊</p>
            <p>疑問に思って試したのだが、描画関係の処理を行なわなければ、glXMakeCurrent()の引数XWindowにNoneを設定しても問題なく動くことを確認した。</p>
            <p>が、これは仕様で定義されている動作なのかどうか怪しいところだ。</p>
            <p>とはいえ、同じ動きがwglMakeCurrent()やその他でも可能なら、自分で生成するfg::GLCurrentの引数からはfg::Windowの参照を外してもいいかもしれない。</p>
            <p>そのように仕様を変えられれば、今考えているOpenGLに関係した機能の実現がやりやすくなるのだ。</p>
            <p>というわけで、画像の扱いの前に、その辺をどうにかしてみようかと思う。</p>
            <p>明日はwindowsでOpenGL描画処理を書いて、wglMakeCurrent()について検証してみるかな。</p>
            <p>いや、OpenGLES用のeglとかいうのもあるのか。</p>
            <p>こっちはlinuxでできるし、こっちを先にやるか。</p>
        </div>
        <hr />
        <div>
            <h2>2018/05/15 03:00</h2>
            <p>OpenGL3の機能を試す前に、メインウィンドウへのアクセス方法を修正した。</p>
            <p>＊</p>
            <p>今まではfg::Windowの参照を取得するfg::getWindow()という関数だけがあり、メインウィンドウへの再描画要求はそれで取得した参照に対して行なっていた。</p>
            <p>しかし、その仕様ではメインウィンドウに対応したfg::GLContextにはアクセスできず、描画タイミング以外でfg::GLCurrentを生成できない。</p>
            <p>それにより、メインウィンドウに対するOpenGL関数の呼び出しが描画時以外にできなくて不便だった。</p>
            <p>初回だけ行なうような処理を書くのが面倒なので、JPEG画像の描画テストでは描画時にglEnable()の呼び出しやテクスチャの生成など、最初に1回だけ処理すればいいようなことも毎回処理しているのが気にかかっていた。</p>
            <p>＊</p>
            <p>単にどこでもfg::GLCurrentを生成できるようにするなら、fg::getWindow()みたくfg::GLContextの参照を取得するような関数を用意すればいいが、それはあまりに安直だ。</p>
            <p>現在の実装では、fg::GLContextの参照に対しては何もできない。</p>
            <p>fg::GLCurrentを生成するための引数に使うことしかできないのだ。</p>
            <p>だったら、fg::GLCurrentを直接生成した方が早い。</p>
            <p>ということで、fg::BasesystemContextの参照を引数に、メインウィンドウに対応したfg::GLCurrentを生成する関数、fg::newGLCurrentForMainWindow()を用意した。</p>
            <p>それに合わせて、fg::BasesystemContextの参照を引数に、メインウィンドウに対して再描画要求を行なう関数、fg::repaintMainWindow()も用意した。</p>
            <p>＊</p>
            <p>逆に、fg::getWindow()は削除した。</p>
            <p>現時点でもメインウィンドウに対する再描画を行なうためにしか使えないし、そのために参照にアクセスするのはオーバースペックというものだ。</p>
            <p>参照にアクセスできてしまうと仮に今後、fg::Windowの参照に対してできることが増えた場合、その全ての機能がメインウィンドウにも使えるようになってしまう。</p>
            <p>メインウィンドウに対しては、使える機能を制限したいと前から考えていたので、ちょうどいい感じに仕上げられたと言える。</p>
        </div>
        <hr />
        <div>
            <h2>2018/05/12 04:00</h2>
            <p>candymakerはモジュールが多かったので、他のも合わせて1日はちょっときつかった。</p>
            <p>＊</p>
            <p>それでもcandymakerもfgも、sucroseもcmsnakeも全て書き換えることができたし、仮にまだ書き換えてないものがあってもそれほど苦労せずに書き換えられるだろう。</p>
            <p>というわけで次に進む。</p>
            <p>画像の対応かな。</p>
            <p>どう対応するべきか。</p>
            <p>取り込んだ画像を特定の扱いやすいフォーマットにするのはいいが、画像取り込み部分はどうしよう。</p>
            <p>fgにはインターフェースを用意せず、fgが用意するのは取り込んだ後についてのみにするか。</p>
            <p>テクスチャの扱いはOpenGL3から変わっているらしい話も聞くので、その辺試すのも必要かな。</p>
        </div>
        <hr />
        <div>
            <h2>2018/05/10 02:30</h2>
            <p>ゴールデンウィークはゆったりしてた。</p>
            <p>＊</p>
            <p>さて、tafはひとまず完成。</p>
            <p>fgとsucroseはtafを利用した形にビルドルールを書き直した。</p>
            <p>結果、非常にコンパクトになって見やすくなったと思う。</p>
            <p>しかしながら、pythonの仕様上間違った書き方しているのに見かけ上はビルドが通っているが、実際には失敗している、というような現象が起きやすくなったかもしれない。</p>
            <p>＊</p>
            <p>candymakerやその他のプロジェクトも明日中には書き換えて、次に進もう。</p>
        </div>
        <hr />
        <div>
            <h2>2018/04/27 03:10</h2>
            <p>記述方式についてはいい感じになった。</p>
            <p>＊</p>
            <p>あとは、既存と同様に実装していこう。</p>
            <p>機能改良もしたいところだが、具体的にどう変えるかが決まっていない以上どうしようもない。</p>
            <p>というか、これ以上は時間がもったいない。</p>
            <p>今週中に作り切って、来週前半には既存プロジェクトのビルドルールを一新したい。</p>
        </div>
        <hr />
        <div>
            <h2>2018/04/26 04:20</h2>
            <p>ちくしょう厄介だなぁ。</p>
            <p>＊</p>
            <p>コンセプト上、モジュールに配置した変数に直接代入するような記述ばかりになるのだが、記述方法と参照の仕方のバランスを取るのが難しい。</p>
            <p>同じ名前で参照しているはずなのに、代入前の値が取れてしまったりする場合があるのだ。</p>
            <p>色々と調べていて、おそらく変数に対応するアドレスを決定するタイミングが問題なんだろうな、というのは把握できた。</p>
            <p>明日には、納得のいく記述形式にできそう。</p>
        </div>
        <hr />
        <div>
            <h2>2018/04/21 03:00</h2>
            <p>根幹は仕上がったように思う。</p>
            <p>＊</p>
            <p>しかしながら、既存のものとは構成が大きく異なるために、これでいいのかどうか不安が残っている。</p>
            <p>まぁ、今のところは想定からずれてもいないし、このままC++用のツールも作っていこう。</p>
        </div>
        <hr />
        <div>
            <h2>2018/04/17 02:25</h2>
            <p>fgbuilder（仮称）はtafという名前に決定。</p>
            <p>＊</p>
            <p>先週からwscriptの書き方を見直し、どのようにまとめるかを考えていた。</p>
            <p>今まで無駄にロジック組んでたところが、実はもっと単純に書けることを知って驚いたりなどしていた。</p>
            <p>色々考えた結果、tafのモジュールをインポートし、変数に必要なデータをセットだけで、ビルドルールになるようなものを作ってみようと思う。</p>
            <p>＊</p>
            <p>本当にその通りにできるのか、怪しいところではあるが。</p>
        </div>
        <hr />
        <div>
            <h2>2018/04/12 02:05</h2>
            <p>JPEG画像を読み込んで表示するテストプログラム、案外簡単にできた。</p>
            <p>＊</p>
            <p>というわけで、ビルドライブラリの方に取りかかろう。</p>
            <p>fgbuilderとかそんな感じの名前で作ってみるかな。</p>
        </div>
        <hr />
        <div>
            <h2>2018/04/11 03:00</h2>
            <p>今日から画像読み込みテストを作り始めている。</p>
            <p>＊</p>
            <p>ビルドルールの件については、ビルドライブラリのロード方法をどうしようか考え中。</p>
            <p>PYTHONPATHの指定か、importlibの使用か。</p>
            <p>前者の場合、exportとかあまり使いたくないので、waf実行時常にPYTHONPATH=と付ける必要があってびみょう。</p>
            <p>後者の場合、configure時にだけビルドライブラリのパスを指定すればよいのはいいが、各プロジェクトのビルドルールが多少複雑になってしまう気がする。</p>
            <p>どっちもどっちだなぁ。</p>
        </div>
        <hr />
        <div>
            <h2>2018/04/07 04:30</h2>
            <p>もうちょい。</p>
            <p>＊</p>
            <p>完全に新しい処理の追加はもう必要ないはず。</p>
            <p>既存の処理に似たものを追加して、おそらく問題なく通るであろう自動テストを追加し、動作を確認すれば完了か。</p>
        </div>
        <hr />
        <div>
            <h2>2018/04/06 03:25</h2>
            <p>おおむね想定通りに進んでいるが、問題も少し。</p>
            <p>＊</p>
            <p>fg::EventProcsStackの方は大体できた。</p>
            <p>記述がいい加減な感は否めないが、処理の流れ自体は間違っていないはずだ。</p>
            <p>あとは、不要になる古い機能を除去してしまえば問題ない。</p>
            <p>問題はfg::BasesystemEventProcsStackの方だ。</p>
            <p>やっつけで無理して実装したツケが、ここに来て回ってきた。</p>
            <p>テクニカルな処理をやめ、潔く無難な処理に変更するべきかもしれない。</p>
            <p>しかし、そのためにはfgに存在しないインターフェースを新設しなければならない。</p>
            <p>そのような事をすると、sucroseのfg::BasesystemEventProcsStackがsucroseのfg::EventProcsStackを使わなければ動作しなくなるので、あまりやりたくはないのだが。</p>
        </div>
        <hr />
        <div>
            <h2>2018/04/05 01:50</h2>
            <p>少しぼんやりしてしまった。</p>
            <p>＊</p>
            <p>イベント処理周りを見直していたが、今のままではよくないかもしれない。</p>
            <p>何がよくないかと言えば、イベント関数群をpush/popした時に呼ぶ関数の呼び出しタイミングだ。</p>
            <p>＊</p>
            <p>イベント関数群を切り替えることで、ウィンドウ描画時やコントローラ操作時などで呼び出される関数を一度に変更できるようにし、それで画面遷移を表現できるようにしている。</p>
            <p>そして、切り替えるタイミングで呼び出すイベント関数も設定できるようにしていて、切り替えた後で使用するデータの生成や、切り替え終わった後に不要になるデータの破棄などをできるようにしている。</p>
            <p>しかし、イベント関数群を切り替えた時点ですでに切り替え後のデータが必要になるにも関わらず、現状では切り替え→イベント関数呼び出し、の順になってしまっている。</p>
            <p>切り替え前に切り替え時のイベント関数を呼び出さなければ、切り替え後に必要となるデータの準備などできない。</p>
            <p>その辺、修正する必要があるな。</p>
            <p>そもそも切り替え時に呼び出すイベント関数の構成も少し思うところがあるし、それと合わせて修正しよう。</p>
            <p>＊</p>
            <p>画像読み込み処理を試してみたいところだが、新しいプロジェクトというか、リポジトリを作るのがめんどくさい。</p>
            <p>何が悪いのかは大体分かっている。</p>
            <p>ビルドツールにwafを使っているが、ビルドルールを書きやすくするために自分で作ったファイルをいちいちコピーしているのが気にかかっているのだ。</p>
            <p>できることなら、それ自体を1つのライブラリにまとめてしまいたい。</p>
            <p>イベント処理周りの修正を終えたら、画像読み込み/表示をするプログラムを作る前にその辺りをどうにかしてみよう。</p>
        </div>
        <hr />
        <div>
            <h2>2018/04/04 03:30</h2>
            <p>sucroseのv0.33.0完成。</p>
            <p>＊</p>
            <p>不要になった処理をばっさりカットしてすっきりした。</p>
            <p>へびゲームに、fgの仕様変更を適用して、きちんと動作することも確認済み。</p>
            <p>そして、fg::GameDataからfg::BasesystemContextの参照を排除できた。</p>
            <p>明日には、コントローラ設定についても対応してみよう。</p>
            <p>ここまで来ると、いよいよ画像ファイルの読み込みとかもどうにかしないと見た目がよくない気がする。</p>
        </div>
        <hr />
        <div>
            <h2>2018/03/31 04:20</h2>
            <p>ウィンドウと、そのイベント処理を別々の型でやるようにしたバージョンを作った。</p>
            <p>＊</p>
            <p>来週の頭に、fg::BasesystemContext内のfg::Windowをこっちに置き換えてみよう。</p>
            <p>いや、他の古い方を使っている部分を新しい方に置き換える方が先か。</p>
            <p>ともかく、新しい方を用いる処理の追加、古い方の削除、スレッド周りの古い処理の削除、と問題が出なければそんな感じの流れか？</p>
            <p>その辺が全部済んだらバージョンを確定させよう。</p>
        </div>
        <hr />
        <div>
            <h2>2018/03/30 02:55</h2>
            <p>一応、完成はした。</p>
            <p>＊</p>
            <p>しかし現状、これを既存のものと置き換えることは不可能だ。</p>
            <p>これは新たに作ったものが悪いのではなく、既存の構成の仕様がよくないことが影響している。</p>
            <p>というか既存の構成、ゲーム側でOpenGLを使って描画するウィンドウ作れないじゃないか。</p>
            <p>この問題を解決するには、ウィンドウの生成とイベント処理の開始タイミングをずらす必要がある。</p>
            <p>そうしなければ、ウィンドウを生成し、イベント処理を開始するまでの間にOpenGLの準備をすることができない。</p>
            <p>＊</p>
            <p>次のバージョンで追加して、置き換えられるようにしよう。</p>
        </div>
        <hr />
        <div>
            <h2>2018/03/29 03:35</h2>
            <p>あともうちょい、だと思う。</p>
            <p>＊</p>
            <p>ミューテックスと実行中のタスクデータをスレッド処理側のみに置く構成への変更は、これまで書いた処理の配置変更とそんなに多くない処理の追加でスレッド処理側はできた、はず。</p>
            <p>残るはタスク管理側だが、こちらについてはほぼもしくは全て、スレッド処理側の関数を呼び出すのみのラッパーのような構成になるので、すぐ済むと思う。</p>
            <p>タスク関数内からの、実行中のタスクの再起動処理も、タスク管理側の関数を呼び出すだけだし簡単だ。</p>
            <p>明日中には完成すると思う。</p>
            <p>別の問題が浮上しなければ。</p>
        </div>
        <hr />
        <div>
            <h2>2018/03/28 01:30</h2>
            <p>うまくいかない。</p>
            <p>＊</p>
            <p>もっと構成を単純にすれば、うまくいくかも。</p>
            <p>しかし、それをするにはかなり大掛かりな変更が必要になる。</p>
            <p>というより、1から作った方が早いかもしれない。</p>
            <p>今週中にはどうにかしたいところ。</p>
        </div>
        <hr />
        <div>
            <h2>2018/03/27 03:05</h2>
            <p>一応は完成、だがバグがある。</p>
            <p>＊</p>
            <p>キャンセル周りが不完全だ。</p>
            <p>キャンセル時にスレッドの再起動処理もしている関係か、デッドロックを起こしているようだ。</p>
            <p>明日中に解決したい。</p>
        </div>
        <hr />
        <div>
            <h2>2018/03/24 03:30</h2>
            <p>スレッド周りの改修はほとんどできた。</p>
            <p>＊</p>
            <p>21日の分はちょっと勘違いしていた。</p>
            <p>スレッド処理側はより単純になるはずだったのだ。</p>
            <p>それで、結果的に既存のものよりコンパクトになった。</p>
            <p>その代わり、起動管理側は既存のものより規模が大きくなった。</p>
            <p>＊</p>
            <p>後は、実行中のタスクの再実行と、起動管理部分のリファクタリングくらいか。</p>
            <p>来週の頭には仕上げたい。</p>
        </div>
        <hr />
        <div>
            <h2>2018/03/21 03:10</h2>
            <p>スレッド周りの改修を進めている。</p>
            <p>＊</p>
            <p>とりあえず、スレッド処理側の処理はほぼできた。</p>
            <p>とはいえ、ここまでは既存の処理をちょっと変えただけだから、比較的簡単にできた。</p>
            <p>ここから先は、新しい構成を構築する必要がある。</p>
            <p>なかなか骨が折れそうだ。</p>
        </div>
        <hr />
        <div>
            <h2>2018/03/13 03:45</h2>
            <p>とりあえず、へびゲームとコントローラ設定について対応した。</p>
            <p>＊</p>
            <p>書き換え程度ではあまり実感できなかったような感触だが、それでも従来よりましになったな、という気はする。</p>
            <p>fg::GameData内にfg::BasesystemContextの参照を含めなくてよさそうな感じになったのは大きい。</p>
            <p>とはいえ、含めなくてよい、ではなくよさそう、であり、他の部分にも修正を行なわないとまだ含めなくてはいけない状況にもなる。</p>
            <p>具体的に言えばスレッド周りだ。</p>
            <p>やはり、早いところ修正が必要だな。</p>
        </div>
        <hr />
        <div>
            <h2>2018/03/09 21:15</h2>
            <p>fg::EventProcsViewer追加完了。</p>
            <p>＊</p>
            <p>実際にはfg::EventProcsStackを見ているし、fg::EventProcsStackViewerの方が合ってるかなとも思ったが、冗長な気がしたのでこれでいいことにした。</p>
            <p>これでイベント周りの修正は完了した。</p>
            <p>来週の頭に、過去に作ったプログラムに修正を適用して使い勝手を確認してみよう。</p>
        </div>
        <hr />
        <div>
            <h2>2018/03/08 22:30</h2>
            <p>fg::Event追加完了。</p>
            <p>＊</p>
            <p>次はfg::EventProcsStackViewer、と仮称しているものの追加だ。</p>
            <p>＊</p>
            <p>現在の仕様では、fg::EventProcsCallerを生成するためにはfg::EventProcsStackの参照が必要だ。</p>
            <p>fg::BasesystemEventProcsStackに設定している関数を呼び出すために、fg::BasesystemContextからfg::BasesystemEventProcsStack内にある、fg::EventProcsStackの参照を取得できる。</p>
            <p>そこまではいいのだが、fg::EventProcsStack自体を参照すると、fg::EventProcsManagerを介してfg::EventProcsをプッシュしたりポップしたり、という操作も可能になってしまう。</p>
            <p>fg::BasesystemEventProcsStackは、fg::BasesystemEventProcsをプッシュ、あるいはポップするためのものであり、それより機能が少ないfg::EventProcsをプッシュしたりすると、予期しない動作になるのは目に見えている。</p>
            <p>＊</p>
            <p>そこで、プッシュ/ポップはfg::EventProcsManagerを介して行ない、関数の呼び出しはfg::EventProcsStackViewerを介して行なう、という風に分けようと考えている。</p>
            <p>fg::EventProcsStackViewerはfg::EventProcsStackから取得できるようにする。</p>
            <p>fg::BasesystemContextから取得できるのも、fg::EventProcsStackViewerの参照にすれば、関数の呼び出しは可能なままで、fg::BasesystemEventProcsStackに対するfg::EventProcsのプッシュ/ポップは不可能にできる。</p>
            <p>＊</p>
            <p>それを完了しても、既知の問題はもう1つある。</p>
            <p>が、そっちは今の仕様では解決が難しい気がする。</p>
            <p>特定状況下でfg::EventProcsCallerを生成するとデッドロックがかかってしまう、という問題だ。</p>
            <p>もっと言うなら、fg::BasesystemEventProcsStackのプッシュイベント関数内で、といったところか。</p>
            <p>詳しく確認はしていないのだが、fg::EventProcsCallerの生成時にはfg::BasesystemEventProcsStackのスレッド処理を待機する処理が入っているため、おそらくその関係だと思う。</p>
            <p>fg::Eventを追加した時に、fg::Eventからfg::EventProcsCallerの参照を取得できるようにしたため、それを利用することで回避はできるのだが、問題のタイミングでfg::EventProcsCallerが生成可能なことは変わっていない。</p>
            <p>できることなら、問題の起きる記述はできないようにしたいところなのだが。</p>
        </div>
        <hr />
        <div>
            <h2>2018/03/08 04:10</h2>
            <p>またしても想像よりも時間がかかりそうだ。</p>
            <p>＊</p>
            <p>fg::Eventを追加するに当たり、既存部分への変更も多く必要になっている。</p>
            <p>とはいえ、明日丸1日がんばればどうにかなるかもしれないが。</p>
            <p>遅くとも今週中には片付けてしまいたい。</p>
            <p>＊</p>
            <p>まぁ、実現は可能そうだし、ユーザーデータを持たないイベント関数内でユーザーデータにアクセスしようとするような記述は、コンパイル段階で弾かれるなど、想定よりももっと便利になりそうだし、いい感じだ。</p>
        </div>
        <hr />
        <div>
            <h2>2018/03/07 03:30</h2>
            <p>想像よりずっと時間がかかってしまった。</p>
            <p>＊</p>
            <p>既存のものを維持したまま、それを差し替えるものを追加するのはやはり手間がかかってよくない。</p>
            <p>できる限り、そういうことをしないで済ませたいものだ。</p>
            <p>＊</p>
            <p>そんなわけで、fg::EventPropertiesをfg::EventProcsという型に差し替えた。</p>
            <p>一区切りついたので0.29.0としたが、まだ終わりではない。</p>
            <p>0.29.0は差し替えのみで、ここからより使いやすくするために追加を行なっていく。</p>
            <p>＊</p>
            <p>手始めに、と言っても今のところ予定している追加は2つだが、統合されたイベント型を追加する。</p>
            <p>現状の仕様ではイベント型は完全に別々であり、イベント型共通の機能というのを用意したくても、各イベント型に関数を追加する、という方法でしか実現できない。</p>
            <p>そこで、fg::Eventというテンプレート型を用意する。</p>
            <p>各イベント型へのアクセスや、イベント型共通の機能の使用はfg::Eventから行なう形にする。</p>
            <p>この形式に変更することで、記述が簡略になる部分もあるはずだ。</p>
        </div>
        <hr />
        <div>
            <h2>2018/01/20 02:40</h2>
            <p>物は試し、と画像ファイルを読み込み、表示するだけのモジュールを作ろうとしていた。</p>
            <p>＊</p>
            <p>しかし、どうにもfg::EventPropertiesが使いづらく、どうにかならないかと考えていたら、改訂案を思い付いてしまった。</p>
            <p>イベント関数と、イベント関数で利用するデータを別々にして考えているからいけないのだ。</p>
            <p>2つを合わせて考えれば、いい感じにできそう。</p>
            <p>タスク周りのと違って、こちらはインターフェースも大きく変わるし、変える前のものは使い物にならないと言える。</p>
            <p>こっちは画像ファイル読み込みの前に片付けてしまおう。</p>
        </div>
        <hr />
        <div>
            <h2>2018/01/17 01:10</h2>
            <p>タスク周りの改訂案を思い付いてしまった。</p>
            <p>＊</p>
            <p>考え方は変わらないけど、構成はかなり大きく変わるしすぐにはやりたくないな。</p>
            <p>しかし、今の構成より無駄が減りそうなので、そのうちやりたい。</p>
        </div>
        <hr />
        <div>
            <h2>2018/01/11 02:40</h2>
            <p>暫定的な基本コントローラ設定画面を作れた。</p>
            <p>＊</p>
            <p>コントローラのボタン入力により、基本メニューボタン、スタートボタン、セレクトボタンの割り当てをファイルに出力できるようになった。</p>
            <p>画面、といっても描画処理がまだついてないけど。</p>
            <p>現時点では画像ファイルを読み込む機能などもないので、きちんとした画面描画をするのは難しい。</p>
            <p>他にも色々問題はあるが。</p>
            <p>＊</p>
            <p>で、この後は実際にゲームで使うコントローラ設定画面を、と行きたいところだがそれは難しいだろうな。</p>
            <p>なんせ、まだどのような仕様にするか固まってない。</p>
            <p>なので別のところ、例えば前述の画像ファイルの扱いなどを進めようかと。</p>
            <p>今まであまり積極的にやった記憶がないが、避けては通れないしいい機会だろう。</p>
        </div>
        <hr />
        <div>
            <p><a href="/">戻る</a></p>
        </div>
    </body>
</html>
