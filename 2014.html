<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>tekuto.net</title>
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-LPVZW1087D"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-LPVZW1087D');
        </script>
    </head>
    <body>
        <div>
            <p><a href="/">戻る</a></p>
        </div>
        <hr />
        <div>
            <h2>2014/11/26 19:15</h2>
            <p>難航していたが、ようやくまとまってきた感ある。</p>
            <p>＊</p>
            <p>今までのファイル構成は、dropmakerのホームディレクトリ直下にベース設定ファイル、パッケージディレクトリ、ゲームディレクトリがあった。</p>
            <p>セーブデータディレクトリなんかも置く予定だったけど、まだそれが必要になる段階まで到達していない。</p>
            <p>実際には、ベース設定ファイル以外のディレクトリはベース設定ファイル内で指定した位置なので、ホームディレクトリの下に置く必要はないが。</p>
            <p>それはともかく、パッケージディレクトリにはゲーム本体、プログラムやら、画像とか音楽とかのリソースやらが配置される。</p>
            <p>一旦配置されたら、削除されるまで変更がかかることは基本的にない。</p>
            <p>ゲームディレクトリには、ゲームパッケージを起動するための情報を記述した設定ファイルを置く。起動するパッケージ名やらモジュール名やらゲーム名やら。パッケージがなんらかのインターフェースを使用する場合、その実装モジュールの指定もする。</p>
            <p>プレステで例えれば、パッケージディレクトリはCD、ゲームディレクトリ（とセーブデータディレクトリ）はメモリーカードである。</p>
            <p>＊</p>
            <p>今回の構成変更で、とりあえずゲームディレクトリは無くした、というより分割した。</p>
            <p>その前に、モジュールの扱いを変えたのを説明するべきか。</p>
            <p>今までは、モジュールはゲームディレクトリの設定ファイルでインターフェースとの関連付けを行っていた。</p>
            <p>今回の変更で、その関連付けはやめた。</p>
            <p>その代わり、パッケージディレクトリの設定ファイルに、各モジュールが実装しているインターフェースを記述しておく形にした。</p>
            <p>ゲームディレクトリの設定ファイルでは、使用を許可するモジュールのリストアップのみ行う。</p>
            <p>あるインターフェースの使用が要求された場合、使用が許可されているモジュールの中から、そのインターフェースが実装されているモジュールを検索し、使用する。</p>
            <p>もし該当するモジュールが2つ以上ある場合には、衝突が発生しているので要求は失敗となる。</p>
            <p>該当するモジュールが存在しない場合には、インターフェースを定義するパッケージが提供するダミーモジュールを使用する。</p>
            <p>ダミーモジュールを使うことで、例えばネットとの通信モジュールを使用するゲームであっても、ユーザー側でその機能を無効化する、ということも可能になる。</p>
            <p>とはいえ、ゲーム側がネットとの通信ができないなら動作しないようにしたりしていれば、そもそもゲーム自体できなくなってしまうわけだが、それはまた別の問題だ。</p>
            <p>＊</p>
            <p>で、ゲームディレクトリをコンフィグディレクトリとショートカットディレクトリの2つのディレクトリに分けた。</p>
            <p>コンフィグディレクトリでは、パッケージディレクトリとセーブディレクトリとの関連付けや、前述の使用を許可するモジュールのリストアップなどを行う。</p>
            <p>パッケージが他のパッケージに依存する場合、対象のパッケージについての設定が書かれたファイルの指定などもできる。</p>
            <p>ショートカットディレクトリでは、起動に関する設定をまとめる。</p>
            <p>起動するゲームの指定、メインウィンドウのサイズの指定など。</p>
            <p>＊</p>
            <p>まとめると、</p>
            <p>パッケージディレクトリにゲーム本体をつっこみ、</p>
            <p>コンフィグディレクトリにパッケージの設定をつっこみ、</p>
            <p>ショートカットディレクトリにゲーム起動時の設定をつっこむ、といった具合か。</p>
            <p>あと、セーブデータディレクトリにゲームのセーブデータをつっこむ。</p>
            <p>＊</p>
            <p>一部の設定ファイルについては、拡張子が一致していれば複数のファイルに分割することも許可する予定。具体的にはベース設定とパッケージ設定。</p>
            <p>コンフィグディレクトリに配置する設定ファイルについても複数のファイルに分割できるようにしたいが、いい案が浮かばない。</p>
            <p>前述のファイル分割は、見やすさ、扱いやすさの向上などが目的だが、こちらは違う。</p>
            <p>パッケージとセーブデータの関連付けと、使用許可モジュールリストを別ファイルに分けることで、例えば使用するモジュールはそのままに別のセーブデータを使いたいとか、同じセーブデータを使うけど使用するモジュールは変えたいとか、そんな感じだ。</p>
            <p>ならばその2つの設定を別のディレクトリに分けてしまえば、と思わないでもないが、そこまですることだろうか。少なくともパッケージとセーブデータの関連付けの方はデータ量が少なすぎる。</p>
            <p>細切れになるばかりで扱いにくくなりそう。</p>
            <p>その辺は後々対応することにしようかしら。そのくらいなら、全体的に修正をかけなければならない、というレベルのものでもないだろうし。</p>
            <p>＊</p>
            <p>ともかく、現時点ではファイルとディレクトリの構成を考えただけであり、実際にそれを運用するためのプログラムは存在していない。</p>
            <p>今までのdropmakerは断片的にしか役に立たないだろうし、1から作っていくとしよう。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/22 00:14</h2>
            <p>色々考えていたが、dropmakerはまた作り直した方がいいかもしらんね。</p>
            <p>＊</p>
            <p>どうにもモジュールの管理周りがうすらぼんやりとしてよくない。</p>
            <p>指定したモジュールから関数のアドレスを取得する関数を、全てのロード済みモジュールから関数のアドレスを探して取得する関数に変えようとするだけでもなんかうまくいかない。</p>
            <p>うまくいかないというより、変更が大きくなりすぎるというか、1から作り直した方が早そうというか。</p>
            <p>この際、ディレクトリや設定ファイルの構成らへんから練り直すべきかもしれない。</p>
            <p>現状では、直接起動するパッケージ以外はセーブデータを持てないし。</p>
            <p>依存モジュールの解決も、今は単純な構成だからましだけど、ちょっと複雑な構成になるとすぐだめになりそう。</p>
            <p>＊</p>
            <p>大まかな構成はテキストに書き出したので、土日に実際にディレクトリや設定ファイルを並べてみるつもり。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/18 00:40</h2>
            <p>日をまたいでしまった。</p>
            <p>＊</p>
            <p>次の日のやる気に影響するかもしれないので、こんな時間まで作業するべきではない。</p>
            <p>さて、fg::Windowからfg::Screenを分離した。</p>
            <p>デモを使って正常に動作することも確認済み。</p>
            <p>ここまでは大したことはない。ファイルの移動と記述の置換、それと多少の修正でできた。</p>
            <p>ここからが本番。メインウィンドウの生成と、それをゲーム側から触れるようにする。</p>
            <p>＊</p>
            <p>sucrose-screen-*モジュールを追加したので、パッケージ設定ファイルに記述を追加していて思ったが、もうちょっと要素を追加した方がよさそうだな。</p>
            <p>そのモジュールがなんのインターフェースの実装なのかを示す情報が現時点では存在しない。</p>
            <p>今のところはモジュール名を同じにすることでそのインターフェースの実装モジュール、ということにしているが、それだと実装が複数存在する場合に対応できない。</p>
            <p>そこで、モジュールの設定ツリーになんのインターフェースの実装なのかを示す要素を追加してみようか、などと考えている。</p>
            <p>そこまで優先度が高いわけではないので、後々実装する予定。</p>
            <p>あるいはもっといい設計が思い浮かぶかもしれないし。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/14 12:40</h2>
            <p>ウィンドウを2つの型に分離することを検討している。</p>
            <p>＊</p>
            <p>OpenGLコンテキストの扱い方については昨日の調査で大体把握できたので、以降はメインウィンドウをどのように実装するか考えていた。</p>
            <p>しかし、どうにもうまくまとまらない。</p>
            <p>今のところ、ウィンドウはfg::Windowという型で表現しているが、これを直接使うと色々問題がある。</p>
            <p>例えば、fg::Windowはfg::close()を使えばウィンドウクローズ、fg::resize()という関数を使えばリサイズなどの要求が行なえるが、メインウィンドウに関してはこれらは必要ないように思う。</p>
            <p>また、fg::free()を使えばウィンドウの破棄ができてしまう。</p>
            <p>破棄はメインウィンドウを生成、制御するゲーム起動側でやるので、ゲーム側ではできないようにしたい。</p>
            <p>他にも色々あるが、要はウィンドウを表現するという意味ではfg::Windowでいいのだが、その機能などがメインウィンドウと合致しない、といった感じだ。</p>
            <p>＊</p>
            <p>ぱっと思い付いた対応として、例えばfg::MainWindowという型を作り、内部的にfg::Windowを持たせ、fg::MainWindowにはfg::Windowの持つ関数のうち一部だけを用意すればいいのではと考えた。</p>
            <p>しかしこれはあまりいい対応ではない。</p>
            <p>簡単に言えば面倒なのである。fg::MainWindowの内部にfg::Windowを持たせ、fg::Windowと似たような関数を用意するということは、fg::Windowに新たに関数を増やし、それがfg::MainWindowでも使えるようにすべき関数である場合、fg::MainWindowにも同じように関数を増やさなければならない。</p>
            <p>当たり前ではあるが、こういうのは忘れてしまう可能性があるし、またfg::MainWindowの方の関数はfg::Windowの同じ関数を呼び出すラッパー程度の関数になるとはいえ、記述ミスによるバグを抱えてしまう可能性もある。</p>
            <p>＊</p>
            <p>そこで考えたのが、ウィンドウを2つの型に分離する、という方法だ。</p>
            <p>今はウィンドウを表現する型はfg::Windowのみだが、これとは別に表示領域を表現する型を用意する。</p>
            <p>仮にfg::Screenということにするが、fg::Screenは自発的に生成、破棄することができない。</p>
            <p>再描画やリサイズなどのイベントについてはイベントハンドラを設定できるようにするが、リサイズリクエストはできないようにする。</p>
            <p>例えば、fg::Windowの内部的にfg::Screenを持たせる、という感じにする。</p>
            <p>fg::Windowを生成すれば、それに対応したfg::Screenも同時に作られる、ということだ。</p>
            <p>それで、fg::Windowの関数としてfg::getScreen()とかいう関数を用意して、fg::Screenの参照を取得できるようにする。</p>
            <p>メインウィンドウについては、ゲーム側からはfg::Screenの参照のみを扱えるようにする。</p>
            <p>fg::Screenの参照だけ、つまりメインウィンドウの表示領域だけなら、破棄もできないし勝手なクローズやサイズ変更の要求もできない。</p>
            <p>おまけに、ラッピングした型でもないのでラッパー関数を作る必要などもない。</p>
            <p>＊</p>
            <p>うまくいきそうな気はしている。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/13 16:00</h2>
            <p>OpenGLのコンテキストについて色々試したので、整理しておこう。</p>
            <p>＊</p>
            <p>ある1つのウィンドウを、複数のスレッドのカレントコンテキストに設定することは可能。</p>
            <p>ある1つのOpenGLコンテキストを、複数のスレッドのカレントコンテキストに設定することは不可能。</p>
            <p>やろうとすると、glXMakeCurrent()を呼び出すタイミングでセグメント例外が発生する。</p>
            <p>一度、スレッドのカレントコンテキストを別のOpenGLコンテキストに変えるなりすれば、別のスレッドのカレントコンテキストに設定することはできる。</p>
            <p>しかしその場合、別のスレッドのカレントコンテキストに設定する前に行なわれ、まだ画面に表示されていない描画処理は無かったことになる。</p>
            <p>なので、一度カレントコンテキストに設定したOpenGLコンテキストを、別のスレッドのカレントコンテキストに移すとかいうのは、あまり意味がないように感じる。</p>
            <p>少なくとも、ゲーム起動側がメインウィンドウに描画を行なうためのOpenGLコンテキストを、ゲーム側から参照できるようにする必要性は、ほぼないことが確認できたと言っていいだろう。</p>
            <p>OpenGLコンテキストを複数のスレッドで使えないので、複数のウィンドウに対して1つのOpenGLコンテキストを割り当てる、とかいう構成も当然無理。</p>
            <p>＊</p>
            <p>今の構成は、fg::GLContextを生成し、その参照とfg::Windowの参照を使ってfg::GLCurrentを生成、それを使ってOpenGLの関数を呼び出す、といった具合。</p>
            <p>別のスレッドのカレントコンテキストに設定し直す意味があまりないということは、fg::GLCurrentなんて作らず、fg::GLContextの生成時にOpenGLコンテキストの生成とカレントコンテキストの設定を行ない、破棄時にカレントコンテキストからの設定解除とOpenGLコンテキストの破棄をやってしまえばいいのでは、ともちょっと思ったけど、それもまたちょっと違うんだろうな。</p>
            <p>例えばテクスチャの情報などはOpenGLコンテキストに関連付けられるだろうし、ウィンドウを一度破棄してもう一度ウィンドウを作り、以前と同じような表示をしたい場合、その度にOpenGLコンテキストの生成を行なっていたのでは再度テクスチャの情報なども作り直さなくてはならない。</p>
            <p>OpenGLコンテキストの生成・破棄とカレントコンテキストの設定・設定解除を分離しておけば、その辺うまく使い回せそうな気がする。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/12 23:00</h2>
            <p>今まで中途半端に作っていたデモをきちんと整えるなど。</p>
            <p>＊</p>
            <p>メインウィンドウ、どうやって実装しようか考え中。</p>
            <p>実質的に、ウィンドウのイベントは再描画要求以外触れないようにしたいところ。</p>
            <p>加えて、必要に応じてゲーム起動側、つまりメインウィンドウを生成した側でも画面に描画を行なえるようにしたい。</p>
            <p>それはつまり、ゲーム起動側にメインウィンドウで使用するOpenGLのコンテキストを持たせるわけで。</p>
            <p>それがカレントコンテキストになっているスレッドも持たせる必要があるわけで。</p>
            <p>描画することを考えなければカレントコンテキストの件は無視できるので、とりあえずそれでやってみようかなぁ。</p>
            <p>1つのウィンドウを、複数のスレッドでカレントコンテキストにする、とかってできるのかなぁ。</p>
            <p>今まで試したことがないから、明日試してみようかな。</p>
            <p>その結果次第では、OpenGLコンテキストはゲーム側から参照できるようにしなくても済むかも。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/11 19:45</h2>
            <p>昨日書いた通り、OpenGLの関数を使えるようにした。</p>
            <p>＊</p>
            <p>ほとんど前のプロジェクトで書いたものを流用しただけだが、やはり少し手を加えなければ使える状態にはならなかった。</p>
            <p>しかし、OpenGLの関数や定数は数が多いため、一気にファイルの総行数が1万行ほど増えてしまった。</p>
            <p>定数が書かれたファイルでおよそ5500行、関数が書かれたファイルでおよそ3500行あり、これだけで9000行に達するので仕方ないが。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/10 19:50</h2>
            <p>垂直同期については対応した。</p>
            <p>＊</p>
            <p>あとはOpenGLの関数だが、前のプロジェクトで書いたものを流用すれば明日にも完了できる気がする。</p>
            <p>垂直同期の対応についても、基本的には前のプロジェクトのものを流用したわけだが。</p>
            <p>しかしながら、xlibのDisplayをグローバルでなくしたなど、構成を変えているために修正は必要だったが。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/07 20:20</h2>
            <p>OpenGLの対応の残件は、OpenGLの関数を使えるようにするのと、垂直同期対応。</p>
            <p>＊</p>
            <p>今日かコンテキストをカレントに設定する処理を作っていた。</p>
            <p>それに付随して、バッファの切り替え処理も対応した。</p>
            <p>現時点ではglClear()とか使えないので、バッファを切り替えてもゴミデータが表示されてしまうだけだが。</p>
            <p>これであとは、OpenGLの関数を使えるようになれば描画ができるようになる。</p>
            <p>＊</p>
            <p>OpenGLの残件を対応したら、メインウィンドウ機能を対応したいところだ。</p>
            <p>ゲームの実行前に自動的に作られ、ゲーム側に渡されるサイズ変更不可、移動検知不可のウィンドウ。</p>
            <p>事前に設定することでサイズを変更できたり、フルスクリーンで実行できたりなどというのを考えているのだが。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/06 19:15</h2>
            <p>昨日のは勘違いだった。</p>
            <p>＊</p>
            <p>見るデータが間違ってて、実際にはおそらく問題なかった。</p>
            <p>なんであんな勘違いをしたのか。</p>
            <p>あの勘違いをしたやつは直ちに名乗り出ろ。</p>
            <p>＊</p>
            <p>OpenGLの対応を進めている途中で、試しに動かしてみてどうしてもOpenGLの関数を呼び出すところでこけてしまう問題が起きていた。</p>
            <p>1時間程度試行錯誤して、valgrindを使って実行するとこけた気がするのを思い出して、valgrindを使わずに実行したらすんなり動いてがっくりした。</p>
            <p>無駄に疲れた。</p>
            <p>もうこんなことはしたくないものだが、忘れた頃にまたやりそう。</p>
        </div>
        <hr />
        <div>
            <h2>2014/11/05 19:50</h2>
            <p>排他処理、スレッドや、ウィンドウについてはとりあえず出来上がっている。</p>
            <p>＊</p>
            <p>今はOpenGLの対応を進めている。</p>
            <p>その途中で、スレッドのライブラリにwaitやnotifyを行なうためのインターフェースを追加したり、その実装を作ったりもした。</p>
            <p>とにかく画面に描画をできるようにしたいところ。</p>
            <p>＊</p>
            <p>valgrind使っててなんかおかしいと思ったら、dlopen()したライブラリがdlclose()されてなかった。</p>
            <p>なんかdlclose()にnullが渡されてるから、クローズされないし失敗もしない。</p>
            <p>ていうかNewModuleの型がおかしい。</p>
            <p>なんでこんな型になっているのか。</p>
            <p>この処理を書いたやつは直ちに名乗り出ろ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/30 20:35</h2>
            <p>イベントハンドラの対応、一応できた。</p>
            <p>＊</p>
            <p>しかし、排他処理のインターフェースを作っていなかったため、まだ実用的でない。</p>
            <p>ロックしてないから、データがおかしくなるかもしれない。</p>
            <p>やはりスレッドのインターフェースも作るべきだろうか。</p>
            <p>ロック関係をそこに含めるか。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/29 19:35</h2>
            <p>まためんどくなってた。</p>
            <p>＊</p>
            <p>sucrose-windowを作成中。あとはイベントハンドラの対応のみ。</p>
            <p>色々考えて、また少しイベントハンドラの扱いを変えた。</p>
            <p>イベントハンドラ部分については、ウィンドウシステムの実装とは無関係だと思ったので、sucrose-window-commonというライブラリに分離させた。</p>
            <p>linux用の、xlibを使う実装はsucrose-window-xlibとして作成してある。</p>
            <p>で、イベントハンドラ部分をあまりめんどくなさそうな感じに設計を変えたので、明日ぐらいには作り終えられるのではと考えている。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/20 19:25</h2>
            <p>順調、と言いたいがやはりスローペースな気がする。</p>
            <p>＊</p>
            <p>とりあえず、sucrose-jsonは使えるようにした。</p>
            <p>あとはsucrose-mainを使えるようにすれば、dropmakerを動かせるが。</p>
            <p>しかし、シンボルの取得とかは処理を書き直さねばならないだろう。</p>
            <p>CからC++にした影響だ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/17 21:20</h2>
            <p>よくよく考えたら、イベントハンドラでつまづいただけだったなぁ。</p>
            <p>＊</p>
            <p>なので、dropmakerに関しては、ほとんどそのままソースを持ってくればいいか、という気分になっている。</p>
            <p>細かく修正を入れようとして時間食うよりずっといい。</p>
            <p>昨日加えた修正の件も考えて、持ってきたソースの中の不要になるconst_castを消していっているのだが、参照系のクラスは全部2種類用意するべきかもしれないなぁ。</p>
            <p>というのも、fg::JsonObjectPairsで似たような状態が発生しているのだ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/16 21:00</h2>
            <p>体調がびみょう。</p>
            <p>＊</p>
            <p>このところ、そのせいか分からんがびみょうに思考がまとまりにくいし、集中もできてないような。</p>
            <p>そんな感じで進みも悪い。</p>
            <p>＊</p>
            <p>文字列参照型を2種類にした。</p>
            <p>std::basic_stringみたいな位置付けのやつだが、std::basic_stringと違い、自身では文字列の領域を保持したりせず、他のところに配置されている文字列を参照する型なのだが。</p>
            <p>今までの構成だとコンストラクタがchar *なので、const char *を入れようとするとconst_castしなければならなくてめんどすぎる。</p>
            <p>なので、コンストラクタにconst char *をつっこむのと、char *をつっこむやつの2種類の型を作ることにした。</p>
            <p>後者の型を前者の型の子クラスにしたので、わざわざオーバーロードした関数を用意しなくても済むし。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/14 21:30</h2>
            <p>10日に書き忘れた。</p>
            <p>＊</p>
            <p>gitのログ見てみたらなんかおかしいな。何回sucrose-commonの生成ルールを追加してるんだ。</p>
            <p>直すのもめんどくさいが。</p>
            <p>＊</p>
            <p>とりあえず、sucrose-commonとsucrose-strconv-iconvを作った。</p>
            <p>前のプロジェクトではstrconvは一度に1種類しかビルドできなかったが、今のプロジェクトでは複数の実装を一緒にビルドできるようにしてあるため、名前を変えた。iconvを使っているので末尾にiconvと足してある。</p>
            <p>commonとstrconvを作ったので、コマンドライン引数を処理するだけのプログラムがビルドできるようになった。</p>
            <p>が、リンクする静的ライブラリ名をハードコーディングしているので、それはどうにかするべきだな。</p>
            <p>必要に応じてコマンドライン引数から指定できるようにしたいが、どうやって処理するべきか。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/09 21:11</h2>
            <p>前のプロジェクトからソースをどんどん持ってきている。</p>
            <p>＊</p>
            <p>2種類のライブラリを生成する件についてはどうにかなった。</p>
            <p>違うプロジェクト間で、wscriptを同一にしなければならないという決まりがあるでもなし、プロジェクト毎に不要なものは削除し、必要なものは追加して対応することにした。</p>
            <p>早いところ、今までに作った部分は移行してしまって、新機能を作成していきたいところ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/08 20:10</h2>
            <p>ビルドの簡略化はできた。</p>
            <p>＊</p>
            <p>とりあえず前のプロジェクトからソースファイルをそのまま持ってきて、fg-commonの生成がきちんとできるのは確認した。</p>
            <p>正確には、fgppからソースを持ってきたのでFGPPをFGに、fgppをfgに置換したりはしたが。</p>
            <p>あれ、よく考えたらあるライブラリについて、静的ライブラリと動的ライブラリの2種類作るのはできなくないか？</p>
            <p>どうしよう。ぱっと思い付く修正案はあるものの、それでいいのかどうか。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/07 22:55</h2>
            <p>早速、作り直し中。</p>
            <p>＊</p>
            <p>ビルドの簡略化を行なっているが、想定よりちょっとめんどかった。</p>
            <p>あるパッケージに存在するモジュールの一覧を取得する処理が、そう簡単にはいかなかった。</p>
            <p>dir()はロード済みのモジュールしか取得できないし。</p>
            <p>調べたら、ModuleScannerというのを使えばいいというのは分かったので、それを使ってコマンドラインオプションを作るところまではやった。</p>
            <p>次は、そのコマンドラインオプションを使用した際に、対象のモジュールのビルドを実行する処理を作る。</p>
            <p>うまくいけば、新たにモジュールのビルドルールを追加しても、他のところにその処理を呼び出す処理を追加しなくても済む。</p>
            <p>configure時にコマンドラインオプションを追加するだけで、そのビルドルールでモジュールが生成されるようになる。</p>
            <p>また、コマンドラインオプションで指定しなければ、モジュールをビルドしないようにもできる。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/06 22:56</h2>
            <p>って、いかん。何また難しくしようとしてるんだ。</p>
            <p>＊</p>
            <p>まずはC/C++だけ、もしくはC++だけ扱うのでもいいじゃないか。</p>
            <p>まだ一つも完成させてすらいないのに、最初から事を大きくしすぎだ。</p>
            <p>JavaとかPythonとかPerlとか、まだ必要な場面ではないのだ。</p>
            <p>＊</p>
            <p>また迷走して時間ばかりかけてしまうところだった。</p>
            <p>メインのライブラリはどうしよう。また作り直すべきだろうか。</p>
            <p>今度は本格的に処理は丸々使えるが、今のプロジェクトに修正を加える形でもいい気がする。</p>
            <p>しかし、この機会にビルドの仕組みの簡略化もしてしまいたいし。</p>
            <p>それをする場合、やはり作り直すべきな気がする。</p>
            <p>というか、インターフェースライブラリはそのままでいいな。</p>
            <p>いや、ビルドの仕組みの簡略化はインターフェースライブラリもやるけど、それは修正を加える形でいいだろう。</p>
            <p>この際だから、Cのラッパーライブラリも作らず、完全にC++だけの構成にしてしまってもいいかもしれない。</p>
            <p>ラッパーというか、他の言語に同じインターフェースがあると、一方に修正を加えたらそちらにも同じ加えたくなるし。</p>
            <p>コードの量は増えてもできることは増えてないという、効率の悪いことになるし。</p>
            <p>＊</p>
            <p>うむ。C++のインターフェースライブラリ「fg」、実装ライブラリ「sucrose」、ライブラリ利用環境「dropmaker」という3つのプロジェクトから成る構成にするかな。</p>
            <p>あと、ライブラリ利用デモ「fgdemos」の4つか。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/06 22:20</h2>
            <p>結局、C++のライブラリをメインにした方がいい気がしてきた。</p>
            <p>＊</p>
            <p>イベントハンドラの関係で、C言語のライブラリをメインにしているとラッパーライブラリがうまく作れないのだ。</p>
            <p>逆に、C++のライブラリをメインにして、C言語のそのラッパーライブラリにすればうまくいくんじゃないかなぁ、といったところ。</p>
            <p>そもそもC言語のライブラリをメインに持ってきたところで、それを直接使うわけでもないし。</p>
            <p>C言語を直接使ってゲーム作るのとかやりたくないし。</p>
            <p>しかし、その程度で大きく変更をかけるのは場当たりすぎる気がする。</p>
            <p>もうちょっとこう、他の言語との連携周りなのだから、その辺どのように対応するのかを考えてから処理したいところだが。</p>
            <p>現状ではどうあがいてもC/C++などで作られた、lib*.soとか*.dllとかのライブラリしか対応できないわけで。</p>
            <p>例えば.jarやら.pyやら.pl、.pmやらも使えるようにしてみたいところ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/03 21:52</h2>
            <p>ウィンドウ制御処理、大体はできたのだが。</p>
            <p>＊</p>
            <p>ウィンドウ内全てについて再描画処理をリクエストする処理についてはまだ。</p>
            <p>XGetGeometry()の処理が完了せず止まってしまうことがある。原因はまだ不明。</p>
            <p>おそらく、このへんも昔に通った道のはずなのだが。</p>
            <p>もしかしたら、xorg-serverのバージョンアップが影響しているかもしれないが、多分そんな大げさなことはないだろう。</p>
            <p>というか、この関数本当に必要だろうか。なんとなく必要な気がする、というだけで存在させている感は否めない。</p>
            <p>やりたいなら、ウィンドウサイズ変更イベントのイベントハンドラを設定しておいてウィンドウサイズを取得し、それを使ってウィンドウ内全てに再描画リクエストを投げてもいいのだ。</p>
            <p>ウィンドウの位置についても、どうもxlibではうまいこと制御できない感があるので、というか前にもこれは体験した気がするので、ウィンドウの位置は制御できないようにした。</p>
            <p>これと同じように、関数自体を消すという対応でいい気もする。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/02 23:25</h2>
            <p>イベント発生時のイベントハンドラ呼び出し処理を追加している。</p>
            <p>＊</p>
            <p>イベントハンドラの設定とかその辺については、ウィンドウ制御側からは触らんわけだし、イベント発生時の処理を書いた後でもいいかなって感じで。</p>
            <p>イベント発生時の処理はリセット前のプロジェクトとほぼ同じで大丈夫なので、さくっと片付けてしまいたいところ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/10/01 19:12</h2>
            <p>おかしいな、イベントハンドラの形式が古い。</p>
            <p>＊</p>
            <p>set形式は色々だめだと判断して、add/remove形式に変えたはずなのだけれど、その形式にしたソースが見つからない。</p>
            <p>そんなもんだから、今のAPIはset形式になってしまっている。</p>
            <p>直さないといかんなー</p>
            <p>＊</p>
            <p>ウィンドウ制御については、とりあえず表示と、イベント処理スレッドの起動までは作った。</p>
            <p>で、イベントハンドラの呼び出しとかが必要になってきた時点で、前述の問題に気が付いた感じ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/30 19:45</h2>
            <p>終了関数については、結局後回し。</p>
            <p>＊</p>
            <p>xlibを使ったウィンドウ制御について実装を始めている。</p>
            <p>リセット前のプロジェクトを参考にしているものの、前の物よりは分かりやすいものにしようと考えながら記述している。</p>
            <p>その中で、ラムダ関数への変数のムーブキャプチャを使ったのだが、なんかエラーが消えないと思ったら、どうやらconstでキャプチャされるらしい。</p>
            <p>参照キャプチャではそんなことはなかったようなのだが。ふしぎ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/29 20:40</h2>
            <p>ひとまず、初期化処理呼び出しの位置変更は完了した。</p>
            <p>＊</p>
            <p>しかし、終了処理についてはまだ考え中。</p>
            <p>初期化関数の引数に、関数ポインタの参照を渡してそれに終了関数のアドレスを設定するという方法はあまりよくない気がする。</p>
            <p>直感的でないというかなんというか、分かりにくいというか。</p>
            <p>そんな回りくどい方法を取るくらいなら、設定ファイルに初期化関数名と終了関数名のペアを書いておくとかの方がいい気がする。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/26 19:20</h2>
            <p>どうも暴走していたようだ。</p>
            <p>＊</p>
            <p>昨日書いたことはどうにも浅はかすぎる。終了処理の呼び出しは同じように書くべきではないと思った。</p>
            <p>初期化処理の呼び出しと同じように、終了関数を設定ファイルで指定することで、モジュールをアンロードする前に終了処理を呼び出す、というのは安直だが、安直すぎてだめだ。</p>
            <p>それだと、初期化処理が途中で失敗した場合、どの終了処理を呼び出すべきで、どの終了処理は呼び出すべきでないのか。</p>
            <p>こういうのはよく、終了処理は全て絶対に呼び出し、終了処理の中で、初期化してあるなら処理を行ない、初期化していないなら何もしない、と書くべきなどと言われるが、私はそういうのが嫌いなのだ。初期化してないなら終了処理は必要ないのだから、最初から呼び出さない方がすっきりする。</p>
            <p>例えば、初期化処理の引数として関数ポインタの参照を渡しておき、初期化処理が正常終了する場合に対応する終了関数のアドレスを設定する、などすればいい感じになりそう。</p>
            <p>＊</p>
            <p>しかしながら、現状では安直な方法ですら行なうのが困難な状況だ。</p>
            <p>モジュールのアンロード処理で、ロードしたモジュールを表現するvoid*しか情報をもらっていないため、どこかに終了処理の関数名を含めるとかいったことができないのだ。</p>
            <p>構成を間違えた感じがある。モジュールのロード、アンロード処理に、初期化、終了の処理を含めるべきではなかったのだ。</p>
            <p>単純に巻き戻してしまってもいい気がする。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/25 21:00</h2>
            <p>初期化処理できあがり。</p>
            <p>＊</p>
            <p>次は、初期化処理と共通の部分は共通化して終了処理の呼び出しを作成する。</p>
            <p>厳密には、現時点ではまだ必要ないと思われるが、ほぼ同じ処理なわけだし、ちょっとしたらすぐ必要になると思うし。</p>
            <p>作っておいて損ないだろう、といったところ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/24 23:36</h2>
            <p>初期化処理の追加、途中までできた。</p>
            <p>＊</p>
            <p>初期化処理を走らせるところはできたので、次は走らせる処理を指定するところ。</p>
            <p>それが出来たら、終了処理についても同じように追加する。</p>
            <p>しかし、ModuleInfoとModuleKeyを分けている意味がないような気がする。</p>
            <p>一緒にしちゃってもいいんじゃないかな。</p>
            <p>＊</p>
            <p>ビルドの仕組み、簡略化すべきかも。</p>
            <p>現状では、あるモジュールについて、configureする時に実装を指定することで、その実装を使ったモジュールをビルドするのだが、モジュールの名前を別にすることで、複数の実装を同時に存在できるようにしようかと。</p>
            <p>現状では、例えばウィンドウ管理のモジュールは、linux用のxlibを使った実装でも、windows用のwin32を使った実装でも、作られるモジュールの名前はlinuxならlibfg-window.so、windowsならfg-window.dllになる。</p>
            <p>でも、例えばxlibを使った実装ならfg-window-xlibとか、win32を使った実装ならfg-window-win32とかにすれば、実装が異なる複数のウィンドウ管理モジュールを共存させることができる。</p>
            <p>その環境はビルドできない実装の場合は、configureでビルドしないように指定すればいいのだし。</p>
            <p>この変更をすることで、多分ビルドの仕組みは今より簡単になるはずなのだ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/19 20:02</h2>
            <p>困った。</p>
            <p>＊</p>
            <p>初期化が必要なモジュールについての考慮が足りていなかった。</p>
            <p>今まで通り、各OSに用意されている機能を使ってもいい気がするが、あれはあまりよくない。</p>
            <p>初期化時に処理が失敗した場合にどうするとか、そういったことができない。多分。</p>
            <p>きちんと調べたわけではないのだが、少なくともwindowsでは関数が1つ固定、関数名すら固定だし、それを使うくらいならば自分で機能を作ってしまった方がいい気がする。</p>
            <p>今のところの考えでは、パッケージ設定に記述するモジュールの設定に、初期化関数を指定できる形にしようかと考えているがどうなんだろう。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/18 20:47</h2>
            <p>総ソースファイル行数が1000行ほど減った。</p>
            <p>＊</p>
            <p>今まで、共通化できそうだけどめんどうなので放置していた場所を、マクロで共通化した結果、そんな感じになった。</p>
            <p>これで、あとは実装部分をリセット前のプロジェクトから持ってくればウィンドウを扱えるようになるだろう。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/17 20:50</h2>
            <p>というわけで、ウィンドウの対応を始めた。</p>
            <p>＊</p>
            <p>リセットする前のプロジェクトからファイルを持ってきて、ちょっと修正を加えて使えるようにしたりなど。</p>
            <p>若干インターフェースやマクロの仕様が違うので、完全にそのまま使うわけにはいかない。</p>
            <p>一気にファイル数が増え、総ソースファイル数が300に迫る勢い。</p>
            <p>明日には300を越すだろう。</p>
            <p>しかし、メインウィンドウの生成はどこでやるべきか。</p>
            <p>コンテキストに参照を持たせることは決まっているが、コンテキスト生成処理に混ぜるか、生成後に参照をコンテキスト生成処理に渡すか。</p>
            <p>前者でいい気がするのだが、なんかしっくりこないような。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/16 19:08</h2>
            <p>とりあえず、コマンドライン引数対応は終えたのだが。</p>
            <p>＊</p>
            <p>この次、本当にパスの扱いについてやるべきだろうか。後回しでもいい気がしてきた。</p>
            <p>いい案がぱっと浮かばないし、なによりやる気があまりしないのだ。</p>
            <p>それよりも、リセットする前のプロジェクトには実装されていたウィンドウや入力機器、音声機器の管理機能をサクサクッと実装して、試しにゲームでも作ってみるべきな気がする。</p>
            <p>ゲームを作らんと、いつまで経っても話が進まんのだ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/12 20:23</h2>
            <p>どうにも作業速度が思うように上がらないと思ったら案の定だった。</p>
            <p>＊</p>
            <p>そんなわけでまだ出来上がっていないが今日は疲れた。</p>
            <p>このまま出来上がるまで続行するというのは昔はよくやっていた気もするが、これをするとその後一層気分がよくなくなるのだ。</p>
            <p>よくない連鎖は発生する前に止めるに限る。</p>
        </div>
        <hr />
        <div>
            <h2>2014/09/11 20:00</h2>
            <p>とりあえずコマンドライン引数対応を始めた。</p>
            <p>＊</p>
            <p>一応、リセットする前のプロジェクトでは実装されていた機能なので、大体はそこから持ってくればいいだけなのだが。</p>
            <p>その後の処理は完全に1から書くことになるわけで、出来上がるのは早くて明日だろうな。</p>
            <p>今日はこれ以上続けるとだらだらしちゃうからやめやめ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/05/30 21:58</h2>
            <p>ちょうど1ヶ月開けてしまった。でも過去ログ見る限り、3月丸々書いてなかったみたいだしまぁいいかなって</p>
            <p>＊</p>
            <p>前の記事にミニチュアを作るとかどうとか書いてるな。作った作った。</p>
            <p>とりあえず限定的なJSONパーサを作った。扱える要素はオブジェクトとリストと文字列のみ。</p>
            <p>で、それを使ってJSONぽい形式の設定ファイルを読み込んで解析し、必要なデータ抽出して、みたいな処理も作った。</p>
            <p>一応、ゲームの起動処理を書けたのだが、勢いで書いたため今整えてるところ。</p>
            <p>書けたと言っても、想定している機能を全て実装できているわけではない。</p>
            <p>今の状態ではまだ使い物にならない。ローダの分離もしてないし。とりあえずCの関数を呼び出せるってだけ。</p>
            <p>手を加えたいところだが、滅茶苦茶な書き方をしたため修正や機能追加など、手を加えることが非常に困難ぽい。</p>
            <p>なので、処理を複数のソースファイルに分けたり、などということをやっている。</p>
            <p>それが済んだら、次は依存関係の実装かな。</p>
            <p>ローダの分離は一番最後でいい気がする。それとも最初にやるべきなのだろうか。でもテンション上がらないだろうし。</p>
        </div>
        <hr />
        <div>
            <h2>2014/04/30 03:47</h2>
            <p>ミニチュアを作るべきだと思った。</p>
            <p>＊</p>
            <p>肝心なところがまだもやついている。しかし、これは実際にやってみればぱっと解決する気がする。</p>
            <p>なので、まずは簡易的なミニチュアで表現し、色々試してみることにする。</p>
            <p>最初から実際のコードでやってみようとするから、躊躇したり混乱したりしてしまうのだ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/04/24 01:37</h2>
            <p>想定していた設計ではどうもうまくできそうにない。</p>
            <p>＊</p>
            <p>今まで作っていた部分については、土台として問題なく使えると思うし、前に作っていた部分についても、大体そのまま使えそうなイメージはある。</p>
            <p>しかし、その中間に作るものが、どうもだめだ。</p>
            <p>根本的な思想からしてだめだった感が否めない。</p>
            <p>どう実装するかについても考慮しつつ、きちんと考え直す必要がありそうだ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/04/18 17:50</h2>
            <p>wafの挙動で納得できなかった点が解決した。</p>
            <p>＊</p>
            <p>python3でwafを動かしビルドすると、変更点が無い場合でもコンパイルやリンクが走るのがなぜなのか分からなかった。python2で動かすと再現しないこともあって奇妙だった。</p>
            <p>今日、それとは別件でwscriptを修正していたら、偶然原因が判明した。</p>
            <p>どうも、python3とpython2で、セットの挙動が違うらしい。</p>
            <p>セットに文字列をつっこむ場合、同じ順序で同じデータをつっこんでも、python2の場合は常に同じ順序になるが、python3の場合は順序が変わっていることが多い。</p>
            <p>セットの性質を考えればpython3の挙動でも全然問題ないのだが、ソースファイルをセットに詰めて渡していたため、python3で動かした場合に毎回ソースファイルの順序が変わってしまい、同じコマンドだと判断されず、コンパイルやリンクが走ってしまっていたようだ。</p>
            <p>そこで、セットではなくリストに詰める形にしたところ、問題は解決した。</p>
            <p>ideoneに検証用コードを上げてリンクを張っておこうとしたのだが、なぜかideoneのpython3では再現しなかった。実装が違うのかしら。</p>
            <p>＊</p>
            <p>結局、また作り直している。どうも私の作り方は変な気がする。なんか知らんが変なところから作り始めている気がする。</p>
            <p>今回はちゃんと、先頭から順々に作っていっている。はず。呼び出す処理自体はこれまでに作った処理を大体そのまま使っている。</p>
            <p>ベースディレクトリが書かれているファイルのパスを生成し、ベースディレクトリを読み出し、まで書いた。</p>
            <p>次はベースディレクトリに配置されているコアライブラリのロード、実行。コアライブラリにはJSONパーサのようなものを搭載し、JSONで書かれた設定ファイルを読み込み、ローダライブラリをロードし、うんぬんかんぬん、のような予定。</p>
        </div>
        <hr />
        <div>
            <h2>2014/04/03 22:50</h2>
            <p>dlopen()とLoadLibrary()らへんの違いを確認した。</p>
            <p>＊</p>
            <p>結論から言うと、実現は容易いが少しめんどうだ。</p>
            <p>linuxの共有ライブラリは、ビルド時に依存する共有ライブラリをリンクしなくてもビルドできる。</p>
            <p>一方、windowsの動的ライブラリは、ビルド時に依存する動的ライブラリをリンクしなければビルドできない。</p>
            <p>linuxにおいて、dlopen()を使って共有ライブラリを実行中にロードする場合、対象のライブラリが依存している共有ライブラリはLD_LIBRARY_PATHの環境変数が示すパスに存在していなければならない。</p>
            <p>windowsにおいて、LoadLibrary()を使って動的ライブラリを実行中にロードする場合、対象のライブラリが依存している動的ライブラリはどこかに存在していなければならない、ということはない。</p>
            <p>＊</p>
            <p>今作っている複数のライブラリの中には、作っている別のライブラリに依存しているものも多いが、このライブラリはLD_LIBRARY_PATHなどの環境変数が示す場所に置いておくつもりはない。</p>
            <p>なので、linux用にビルドする場合には、依存ライブラリを指定せずにビルドし、実行中に自分でライブラリの依存関係を解決し、ロードする必要がある。</p>
            <p>ビルド時に依存ライブラリを指定してしまうと、ロード時にこけてしまう。</p>
            <p>windows用にビルドする場合は、実行中については同様だが、ビルド時には指定しないとこけてしまうため、依存ライブラリを指定しなければならない。</p>
            <p>＊</p>
            <p>私が作っているライブラリの生成時にだけ影響するというのならいいのだが、ここで言うライブラリというのは、ゲーム自体のプログラムも含まれる。</p>
            <p>つまり、ライブラリを利用する側の、存在するかもしれない私以外の開発者にも、そのようなルールを強いなければならないわけだ。なかなか心苦しいものがある。</p>
            <p>どうしようもないことではあるのだが。</p>
        </div>
        <hr />
        <div>
            <h2>2014/04/03 04:15</h2>
            <p>前の日記から1ヶ月ほど空いてしまった。</p>
            <p>＊</p>
            <p>えらくローペースながら、進んではいる。コマンドライン引数の処理をして、その引数を元にゲームを起動しようとするところまで書けた。</p>
            <p>しかしこの部分については、後々変更することになりそうだ。今の状態は、あくまで一時的なもの。</p>
            <p>ゲームをロードする仕組みらへんについても大体考えがまとまってきたし、悪くはない感じ。</p>
            <p>ただちょっとやる気が出にくいのと体調がよくなりにくいのが気になるところ。</p>
        </div>
        <hr />
        <div>
            <h2>2014/02/10 16:20</h2>
            <p>また最初から作り直した方がいいのではないかという気持ち。</p>
            <p>＊</p>
            <p>とりあえず、fg4cppの位置付け、これ完全にミスってる気がする。</p>
            <p>fgppのインターフェースを全てC++のインライン関数にして、コード上ではfgppのインターフェースを使いつつも、実際にはfg用のプログラムができあがる、というものなんだけど。</p>
            <p>現実にはそううまくいっていない。fgでは関数ポインタにしているが、fgppでは関数オブジェクトになっているところとか、ラッピングがうまくいっていないのだ。</p>
            <p>全てインライン関数で済ましたいのだけれど、そういう関数ポインタ周りの部分には、fg4cppでインターフェースを定義し、ライブラリの方でfg4cppに対応するためのインターフェースを実装しないと使えない、といった感じだ。</p>
            <p>fg4cppを、内部的にはfgの関数を呼び出すfgppの実装の一つ、という位置付けにした方がラッパーとしてきちんとできそう。</p>
            <p>＊</p>
            <p>文字列の扱いについても、失敗してる感がすごい。</p>
            <p>文字列型は、fgにはFgString等の宣言だけで、定義は実装するライブラリに記述、という形を取っているけど、定義もfgに定めておくべきかも。</p>
            <p>定義を書いていないせいで、生成方法も実装するライブラリに関数として実装する必要があるが、その関数からログを出力したくても、ログのライブラリが文字列生成・破棄関数を使用することになるので、循環参照になってしまうため出力できないのだ。</p>
            <p>そもそも文字列型なんていうのはそう複雑であったりとか、環境によって実装がまちまちなんてものではない。</p>
            <p>文字型の配列というだけだ。加えて、長さが分かって各要素へのランダムアクセスができればそれでいい、という程度のもののはず。</p>
            <p>その型に対して、例えば文字コード変換とか複雑なことをすることはあっても、型自体は単純なはずなのだ。</p>
            <p>などなど色々言ったが、早い話が文字列型を定義してないせいで、他のライブラリに依存させたくないログのライブラリが文字列ライブラリに依存する結果になってしまっている、それはやだなぁ、ということ。</p>
            <p>＊</p>
            <p>文字列型とかいう基本データ型に修正を加えるとなると影響範囲すごいしクソめんどくさそうなので、そんくらいなら1から作るべきかなーとか。バグ作り込んでしまいそうだし。</p>
        </div>
        <hr />
        <div>
            <h2>2014/01/23 14:16</h2>
            <p>イベントハンドラは基本的に複数設定できるようにするべきかもしれない。</p>
            <p>＊</p>
            <p>現在の状態では、イベントハンドラは1つしか付けられないようになっている。</p>
            <p>理由としては、簡単に言えばめんどかったからである。</p>
            <p>1つであれば、イベントハンドラが設定されているかいないか、しかない。</p>
            <p>イベントハンドラを解除する、という処理をするなら、設定されているものがあればそれを削除すればいいだけの話だ。</p>
            <p>これが複数となるとそうはいかない。どのイベントハンドラを削除するのか、とかいう話になってくる。</p>
            <p>そうなると、イベントハンドラに結び付く情報がどうとかいう話になってきて、なかなかめんどくさい。</p>
            <p>＊</p>
            <p>その辺の理由から、1つだけ付けられる形にしてきたわけだけど、1つしか付けられないとなると、複数の箇所からイベントハンドラを設定するような感じになってくると、非常に使いにくくなる。</p>
            <p>イベントハンドラを設定する、とはつまり、既存の設定を上書きしてしまうことになるわけだ。これはよくない。上書きされた側は、意図せずイベントハンドラの設定が解除されることになる。</p>
            <p>これで問題が発生しないとはとても考えられない。</p>
            <p>＊</p>
            <p>とかいうのが、ログ関係のイベントをどうするかとか、ライブラリの依存関係がどうとか考えていたら出てきた。</p>
            <p>ログライブラリは、出力するために文字コード変換が必要になるので文字列ライブラリに依存しているんだけど、それではよくないと思ったのだ。</p>
            <p>それをすると、文字列ライブラリがログライブラリに依存できず（循環参照になるため）、文字列ライブラリからログの出力ができなくなるのだ。</p>
            <p>そこで、ログライブラリは文字列ライブラリに依存させず、ログライブラリと文字列ライブラリの双方に依存する、ログ出力ライブラリというのを用意することを考えた。</p>
            <p>ログライブラリはログを受け取るインターフェースと、ログを受け取った時にイベントハンドラを呼び出すだけにして、ログの文字列変換などは行なわない。ただの橋渡しだ。</p>
            <p>ログ出力ライブラリはログライブラリにイベントハンドラを設定して、ログ発生時のイベントを受け取り、ログを文字コード変換し出力する。</p>
            <p>そこまで考えたのはいいのだが、ログのイベントハンドラが1つしか設定できないと、ログ出力だけで占有する形になってしまう。</p>
            <p>私の想定では、ログをファイルに出力しつつ、エラーログが発生した際には画面にアラートを出したりとか、そういうことをしたいのだ。そして、アラートを出すのはログ出力ライブラリの役割ではない。</p>
            <p>＊</p>
            <p>とまぁそんな感じで、イベントハンドラは1つしか設定できないようにするべきではないなぁ、という結論に至ったわけだ。</p>
            <p>なんかどんどん、JavaのAWTみたいな感じになっていく気がするが気のせいだろう。</p>
        </div>
        <hr />
        <div>
            <h2>2014/01/23 05:50</h2>
            <p>ログ出力のインターフェースはできた。</p>
            <p>＊</p>
            <p>printf()で標準出力に出力するだけのしょうもない仮実装も作った。</p>
            <p>ログを出力したら、それを別のところでイベントとして受け取り、イベントハンドラを呼び出す、とかもやりたいのだけれど、具体的にどういうインターフェースにするのかが定まっていない。</p>
            <p>なのでその辺はまだできない感じかな。</p>
            <p>とりあえずは、今までに作った箇所でログ出力が必要なところに記述を追加するとしよう。</p>
        </div>
        <hr />
        <div>
            <h2>2014/01/20 14:47</h2>
            <p>ビルド時に、バックエンドライブラリを指定できるように修正した。</p>
            <p>＊</p>
            <p>というのをやってから、またやる気減退していたがまたがんばる。</p>
            <p>設定ファイルのフォーマット定義、読み取り処理とか、C以外のプログラムの起動とか、その辺の対応をしたくはあるのだが、まだもやもやしていたために手を出せなかった。</p>
            <p>それらを作るために、まずはロガーを作ることにした。</p>
            <p>＊</p>
            <p>ロガーは、異常系にユーザが対応するための重要な要素になる。</p>
            <p>異常系に対応するための要素と言えば、例えばステータスコードのリターンとか、例外のスローとかあるけど、今回の場合どちらも不適格だと思う。</p>
            <p>基本的に、何か問題が発生したとして、自動的に何かをしなければならない、ということがないのだ。</p>
            <p>ステータスコードを返したり、例外を送出したりというのは、プログラム内でどういう問題が発生したのか判別し、発生した問題への対処を自動的に行なうためのものだ。</p>
            <p>逆に言えば、その場でプログラム内で問題に対処する必要がないのなら、成功ならtrue、失敗ならfalseで構わないと思う。</p>
            <p>ただ、それだけでは発生した問題の種類も分からず、ユーザが対応することもできない。</p>
            <p>そこでロガーというわけだ。問題が発生した時点で、それがどういう問題なのかをログとして出力する。</p>
            <p>処理の結果としては、失敗しました、エラーログを参照してください、のようなものだけ表示する。</p>
            <p>その時に、ログを参照すれば問題の原因を特定でき、対応が可能、という感じだ。</p>
            <p>＊</p>
            <p>ログ出力はほぼ全てのライブラリが利用するはずなので、できるだけ早い段階で、インターフェースだけでも定義しておくべきだろう。他のライブラリのインターフェースにも影響するからだ。</p>
            <p>そんな感じで、次はロガー対応。</p>
        </div>
        <hr />
        <div>
            <h2>2014/01/09 15:55</h2>
            <p>年末年始はのんびりしてたけど、数日前からちょびちょび再開している。</p>
            <p>＊</p>
            <p>とりあえずは、インターフェースはそのままに、実装の気になるところを修正していた。</p>
            <p>ダミー関数の定義自動生成もやっつけたし、他にも色々修正した。</p>
            <p>今まで作ったところで修正するべきところはまだあると思うが、前のプロジェクトで作った機能についてもどんどん追加していきたいところ。</p>
            <p>ひとまず、bitbucketの課題リストにつっこむところから始めるべきか。</p>
            <p>新しいプロジェクトにしてから、まだ課題リスト使ってなかったしな。</p>
        </div>
        <hr />
        <div>
            <p><a href="/">戻る</a></p>
        </div>
    </body>
</html>
