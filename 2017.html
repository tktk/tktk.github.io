<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>tekuto.net</title>
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-23511137-1"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'UA-23511137-1');
        </script>
    </head>
    <body>
        <div>
            <p><a href="/">戻る</a></p>
        </div>
        <hr />
        <div>
            <h2>2017/12/29 03:25</h2>
            <p>いらなくなった型の削除まで完了した。</p>
            <p>＊</p>
            <p>コントローラの処理の改訂版は気合で仕上げた。</p>
            <p>まだ使ってないので明日試したいところだが、色々とやることあるしなぁ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/12/15 02:25</h2>
            <p>コントローラ関係の新しいイベント型は一通り作り終わった。</p>
            <p>＊</p>
            <p>あとはバッファ型を作り、それを利用する形にsucrose::ControllerManagerに修正を加えればいい。</p>
            <p>それで、いらなくなる型とかを消せば完了だな。</p>
        </div>
        <hr />
        <div>
            <h2>2017/12/12 01:00</h2>
            <p>コントローラの処理、扱いにくいなぁ。</p>
            <p>＊</p>
            <p>ボタンとか軸とか、それらをバラバラに扱ってるのが悪い気がする。</p>
            <p>確かにコントローラの見た目からしてそれらは別々なわけだけど、実際の扱いではそれらがどの順で使われたかとかが重要なことが多い。</p>
            <p>現状の機能でそれをやろうとすると、入力を一旦全てバッファにつっこみ、それを参照して処理するスレッドに渡す、みたいな処理をしなければならない。</p>
            <p>そのバッファにつっこむところまではsucrose側で処理して、バッファを参照して処理する部分だけゲーム側でやらせればよさそう。</p>
            <p>＊</p>
            <p>明日からその方針で進めていこう。</p>
            <p>年内にはコントローラの扱いを確立させたいところだが、間に合うかな。</p>
        </div>
        <hr />
        <div>
            <h2>2017/11/07 02:10</h2>
            <p>想像以上に整えることができた気がする。</p>
            <p>＊</p>
            <p>いくつかの画面を遷移してから、1つずつ戻すのはもちろん、特定のポイントまで一気に戻したりもできる。</p>
            <p>とりあえず、この構成でコントローラ設定画面を作ってみようかな。</p>
        </div>
        <hr />
        <div>
            <h2>2017/10/30 23:40</h2>
            <p>やはりだめだな。</p>
            <p>＊</p>
            <p>色々と試行錯誤してみたが、大きく変更を加える必要がある、というのが結論。</p>
            <p>データ型の構成や処理の流れからして変える必要がある。</p>
        </div>
        <hr />
        <div>
            <h2>2017/10/28 02:20</h2>
            <p>想像以上に複雑になってしまった。</p>
            <p>＊</p>
            <p>正直、これでいいのかあまり確信がない。</p>
            <p>来週の頭に見直してから確定しようと思う。</p>
        </div>
        <hr />
        <div>
            <h2>2017/10/27 03:05</h2>
            <p>ロック処理にミスがあった。</p>
            <p>＊</p>
            <p>ミューテックスを2つにしないとうまくいかない気がする。</p>
            <p>関数内でロックとその解除を行なうロック処理って、自動テストでテストできるんだろうか。</p>
        </div>
        <hr />
        <div>
            <h2>2017/10/25 01:50</h2>
            <p>fg::BasesystemEventPropertiesManagerを追加して、不要になった型や関数の削除も完了。</p>
            <p>＊</p>
            <p>ここに来て、ゲーム初期化時にスレッドプールを稼働させていないことが悪影響を及ぼしている。</p>
            <p>しかし、テストの都合上fg::BasesystemContext生成完了時点ではスレッドプールを稼働させてない方がやりやすいんだよなぁ。</p>
            <p>まぁ、それ以外に理由がないならfg::BasesystemContext生成時にスレッドプールを稼働させるべきだろうな。</p>
        </div>
        <hr />
        <div>
            <h2>2017/10/18 01:00</h2>
            <p>既存のfg::EventPropertiesManagerはfg::EventPropertiesStackに変更した。</p>
            <p>＊</p>
            <p>で、新たにfg::EventPropertiesManagerを追加した。</p>
            <p>fg::EventPropertiesManagerを介してfg::EventPropertiesStackに対してpush()、pop()を行なう。</p>
            <p>fg::EventPropertiesManagerを生成した時より浅い階層へのpop()はできないようになっている。</p>
            <p>また、fg::EventPropertiesManagerを破棄する時、生成した時の階層までpop()するようになっている。</p>
            <p>自発的なpop()は必要ないかとも思ったけど、そうなるとfg::EventPropertiesManagerを生成しまくることになりそうだし、まぁいいかなって感じで。</p>
            <p>＊</p>
            <p>明日からはfg::BasesystemEventPropertiesManagerを追加していく。</p>
            <p>インタフェースを少し変えて、fg::BasesystemEventPropertiesStackは最終的にsucrose内に内包し、インターフェースからは削除しようと思っている。</p>
            <p>ゲーム側から見せる必要がなくなりそうなので。</p>
        </div>
        <hr />
        <div>
            <h2>2017/10/13 19:05</h2>
            <p>機能の追加漏れがあった。</p>
            <p>＊</p>
            <p>その部分について、昨日追加を行ない、0.23.1とした。</p>
            <p>＊</p>
            <p>処理自体はこれで問題ないと思う。</p>
            <p>問題はインターフェースだな。</p>
            <p>1本のスタックの中身を、push()とpop()だけ管理するのは厳しいものがあると思う。</p>
            <p>容易く整合性が崩れそうだ。</p>
            <p>生成時にpush()し、破棄時にpop()するRAIのようなものを考えているけど、それでいいのかどうか。</p>
        </div>
        <hr />
        <div>
            <h2>2017/10/12 03:45</h2>
            <p>fg::BasesystemEventPropertiesManager出来上がった。</p>
            <p>＊</p>
            <p>テストの記述をちょっと修正したら、0.23.0を確定しよう。</p>
        </div>
        <hr />
        <div>
            <h2>2017/10/07 04:25</h2>
            <p>詰まる箇所もあったが、fg::BasesystemEventPropertiesManagerのpush()、pop()まで完了。</p>
            <p>＊</p>
            <p>fg::BasesystemEventPropertiesManager関連の残件は、push時、pop時、変更時のイベント関数対応と、fg::BasesystemContextからのpushとpop実行くらいか。</p>
            <p>来週の頭には全て完了したいところ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/10/04 22:35</h2>
            <p>fg::EventPropertiesは出来上がった感じ。</p>
            <p>＊</p>
            <p>勢いで作ったところがあり、なかなかひどい作りだったのをどうにかした。</p>
            <p>これでいよいよfg::BasesystemEventPropertiesManagerの方に取り掛かることができる。</p>
            <p>しかし、今の状態でもfg::EventPropertiesの作りはびみょうな気がするな。</p>
            <p>fg::BasesystemEventPropertiesManagerの修正、かなりトリッキーなことになりそう。</p>
        </div>
        <hr />
        <div>
            <h2>2017/09/30 03:50</h2>
            <p>push()とpop()は追加できた。</p>
            <p>＊</p>
            <p>fg::BasesystemEventPropertiesManagerの修正はまだ。</p>
            <p>その辺りを対応するためには、fg::EventPropertiesに機能を追加する必要があるな。</p>
        </div>
        <hr />
        <div>
            <h2>2017/09/29 04:10</h2>
            <p>fg::EventPropertiesManagerの中身を修正中。</p>
            <p>＊</p>
            <p>push()については、1種類でいいと思った。</p>
            <p>2種類目は、fg::EventPropertiesに機能を追加する形にしようと思う。</p>
            <p>明日中に片付けられればいいが、そこまで気力が続くかどうか。</p>
        </div>
        <hr />
        <div>
            <h2>2017/09/27 04:00</h2>
            <p>作りが甘かったかもしれない。</p>
            <p>＊</p>
            <p>現状のBasesystemEventPropertiesTaskによるEventProperties更新は、言ってみればgotoのようなものだ。</p>
            <p>規模の大きい物を作る場合には混乱の元になるかもしれない。</p>
            <p>関数呼び出しのような、スタック形式にするべきか。</p>
            <p>その形にすれば、リソースの生成、破棄タイミングも明確になるかも。</p>
            <p>というのも、今その辺でちょっと困っている。</p>
            <p>EventProperties更新するのはいいが、更新されたイベントから参照するリソースの生成、破棄タイミングはどうしよう、と。</p>
            <p>＊</p>
            <p>さて、現状からの修正を考えるとどうなるかな。</p>
            <p>Readerはそのままでいいけど、Writerはだめだな。</p>
            <p>Writerは削除して、Managerにpush()、pop()を付ける。</p>
            <p>push()はEventPropertiesのみと、それに加えてリソースの生成、破棄を目的とした関数の参照2つと、そのリソースを配置する場所の参照も持つ2種類を用意する。</p>
            <p>＊</p>
            <p>しかし、fg::EventPropertiesって必要かな。</p>
            <p>fg::BasesystemEventPropertiesだけでいい気がする。</p>
        </div>
        <hr />
        <div>
            <h2>2017/09/23 04:00</h2>
            <p>fgへの関数追加まで完了。</p>
            <p>＊</p>
            <p>あとは実際にそれを使用するように記述を修正するだけ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/09/22 00:40</h2>
            <p>やる気がやばいけど、画面遷移確認まで完了。</p>
            <p>＊</p>
            <p>画面遷移処理は全く同じ記述にしかならなさそうなので、fgに関数を追加することにする。</p>
            <p>OpenGLのタスク生成と同じような感じだし、明日中には仕上げたい。</p>
            <p>それを使用して画面遷移処理を書き換えたら、中身を作り始められるかな。</p>
        </div>
        <hr />
        <div>
            <h2>2017/09/09 03:30</h2>
            <p>fg::BasesystemEventPropertiesに関係する型を追加している。</p>
            <p>＊</p>
            <p>現状では自分でロックかけたり解除したりができないので、ロック中に他の処理もやっておく、ということができない。</p>
            <p>それを改善するために、ロックに関する型を追加しようかと。</p>
            <p>＊</p>
            <p>それができたら、簡単な画面遷移を作る。</p>
        </div>
        <hr />
        <div>
            <h2>2017/09/06 00:15</h2>
            <p>今の構成で進めてみることにした。</p>
            <p>＊</p>
            <p>正直、違和感を感じた部分の構成は変わってないんだけど。</p>
            <p>慣れてなかっただけかもしれないし、いい解決方法が思い付かないし。</p>
            <p>＊</p>
            <p>ひとまず、コントローラ設定画面について、新しい仕様に合わせる修正をした。</p>
            <p>合わせる、といっても起動できるようにしただけなので、もっと今の構成に合わせた記述に直す。</p>
            <p>それから、画面遷移についての処理を入れてみよう。</p>
        </div>
        <hr />
        <div>
            <h2>2017/09/02 02:45</h2>
            <p>ゲームの関数変更完了。</p>
            <p>＊</p>
            <p>へびゲームにも修正を加えて、きちんと動くことを確認した。</p>
            <p>しかし現状の構成ではよくない。</p>
            <p>イベント処理関数からゲームデータを参照するのがちょっとめんどくさい。</p>
            <p>どうにかするべきとは思うんだけど、どうするかがまだもやっとしているな。</p>
        </div>
        <hr />
        <div>
            <h2>2017/08/31 01:10</h2>
            <p>fg::EventPropertiesをfg::EventProcsに変更するの、いらなかったかも。</p>
            <p>＊</p>
            <p>そう思ったので、とりあえず変更したブランチは残しておいて、別のブランチを作ってそっちをいじっている。</p>
            <p>というわけでfg::GameDataの追加をやっている。</p>
            <p>fgには追加したし、久々にcandymaker自体をいじくる必要があるな。</p>
        </div>
        <hr />
        <div>
            <h2>2017/08/30 00:00</h2>
            <p>fg::EventPropertiesをfg::EventProcsに変更した。</p>
            <p>＊</p>
            <p>明日はイベント処理関数の型を以前の状態に戻すところから始める。</p>
        </div>
        <hr />
        <div>
            <h2>2017/08/28 23:50</h2>
            <p>コントローラ設定画面に手を付けようとしたが、思うように書けない。</p>
            <p>＊</p>
            <p>ちょっと構成見誤ったか。</p>
            <p>書いていて違和感を感じる箇所がところどころにある。</p>
            <p>＊</p>
            <p>fg::EventPropertiesは少し間違いだったように思う。</p>
            <p>主に名前が。</p>
            <p>そんな汎用的に使うものではなく、イベント処理関数だけつっこんどけばそれでいい関数な気がする。</p>
            <p>fg::EventProcsにするべきだったな。</p>
            <p>よって、読み込み専用のこれをイベント処理関数の引数にするのも違和感ある。</p>
            <p>イベント処理関数の参照なんて、普通はイベント処理関数内で必要にならないだろ。</p>
            <p>前の構成に戻すべき。</p>
            <p>＊</p>
            <p>あとは、ゲームの関数も変更するべきだな。</p>
            <p>現状ではfg::BasesystemContextとfg::BasesystemArgsをまとめた、fg::BasesystemDataの参照を引数に、色々やってからboolを返す関数だけど、fg::BasesystemArgsはもはや必要なくなってきた。</p>
            <p>ゲームデータの設定処理しかできないし。</p>
            <p>それなら、fg::BasesystemArgsとfg::BasesystemDataは削除し、引数としてfg::BasesystemContextの参照を受け取り、ゲームデータを生成して返す、とした方がいいだろう。</p>
            <p>もちろん、ゲームデータの破棄関数も必要になるけど。</p>
            <p>＊</p>
            <p>とりあえず名前変更からかな。</p>
            <p>次にイベント処理関数の引数を元に戻す、といきたいけどゲームデータ型にしたいところもあるし、それを追加した後か？</p>
            <p>となると、ゲームの関数変更を先にやるべきだな。</p>
            <p>ゲームの関数変更は大きい変更だけど、他とは独立してる感じだし最初にやってしまっても構わない気がする。</p>
            <p>＊</p>
            <p>その前に、ひとまず今の状態でバージョンを確定させておこう。</p>
        </div>
        <hr />
        <div>
            <h2>2017/08/26 03:45</h2>
            <p>へびゲームをfgの仕様変更に合わせる形で修正完了。</p>
            <p>＊</p>
            <p>コントローラ操作の部分に関しては、まだ存在しないため書いていないが。</p>
            <p>コードの量はほとんど変化しなかったな。</p>
            <p>新しい仕様の要素で相殺された感じか。</p>
            <p>＊</p>
            <p>問題なく動くことは確認できた。</p>
            <p>次回からはコントローラ設定画面を使って、画面遷移処理を書いてみたりなどしてみるか。</p>
        </div>
        <hr />
        <div>
            <h2>2017/08/25 03:30</h2>
            <p>OpenGLによる描画イベント、できた気がする。</p>
            <p>＊</p>
            <p>明日、へびゲームとかそこらを新しいインターフェースに合わせた書き方に修正して確認しよう。</p>
            <p>想定通りなら、より短いコードで同じ処理ができるようになっているはずだ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/08/23 01:15</h2>
            <p>これで元からある機能の実装は完了できたか。</p>
            <p>＊</p>
            <p>あとはOpenGLによる描画イベントを実装すればいい。</p>
            <p>これは新しい機能になるが、大体は既に作ってある機能の組み合わせでいけるだろう。</p>
        </div>
        <hr />
        <div>
            <h2>2017/08/19 03:10</h2>
            <p>fg::BasesystemEventPropertiesを作っている。</p>
            <p>＊</p>
            <p>あとは、内容更新のためのsucrose::BasesystemEventPropertiesManagerを作り、それをfg::BasesystemContext内につっこめば出来上がり、かな。</p>
            <p>ここまでやって、ようやく画面遷移などがやりやすくなるはず。</p>
            <p>早くコントローラ設定画面を作りたい。</p>
        </div>
        <hr />
        <div>
            <h2>2017/08/09 03:15</h2>
            <p>スレッドのキャンセルの件については解決。</p>
            <p>＊</p>
            <p>fg::EventPropertiesをudev関係でも使うべきか、悩ましいところ。</p>
            <p>あまり実装方法がばらけてても分かりにくいし、統一してしまうか。</p>
        </div>
        <hr />
        <div>
            <h2>2017/08/08 04:10</h2>
            <p>ようやく原因判明かな。</p>
            <p>＊</p>
            <p>スレッドのキャンセル時にこけてる原因が分からなくて、かなり時間をかけてしまった。</p>
            <p>キャンセルかけたスレッド内でwaitしたり、wait中のスレッドにキャンセルかけたりしたらいかんってことね。</p>
            <p>その辺考慮したコードになっていなかった。</p>
            <p>すぐ修正しないとまずいな。</p>
        </div>
        <hr />
        <div>
            <h2>2017/08/05 00:35</h2>
            <p>ひとまず、ウィンドウ周りは対応した。</p>
            <p>＊</p>
            <p>メインウィンドウについても、fg::BasesystemContextに対してデータを設定することで処理を変更可能にした。</p>
            <p>しかしながら、構成は変更するべきだろうな。</p>
            <p>現状では、fg::BasesystemContextの内部で利用するデータはヘッダファイルに列挙型を用意し、特定のインデックスに特定のデータをセットすることで対応している。</p>
            <p>このやり方はよくない。</p>
            <p>将来的に、fg::BasesystemContext内部で利用するデータを増やしたり変更したりした時の影響が大きすぎる。</p>
            <p>fg::BasesystemContextに対して設定するものは、fg::EventParametersをラッピングし特殊化した型にするべきだろうな。</p>
            <p>＊</p>
            <p>とりあえず問題ないことは確認できたわけだし、ちゃちゃっとコントローラ周りについても対応してしまおう。</p>
            <p>それが済んだら、fg::BasesystemContext用のfg::EventParametersの追加を含めた様々な変更を行なっていくとしよう。</p>
        </div>
        <hr />
        <div>
            <h2>2017/07/29 23:50</h2>
            <p>fg::EventParameters関係を作り終えた。</p>
            <p>＊</p>
            <p>型の名前はこれでいいのかどうか。</p>
            <p>いまいちしっくりこない感じがあるが、まぁいいだろう。</p>
            <p>来週の前半には、既存のイベント関係の処理をこれで差し替えてしまいたいところ。</p>
            <p>ベースシステム周りは処理を差し替える以外にも色々変える予定なので、ちょっと時間がかかりそうだな。</p>
            <p>＊</p>
            <p>来週はもう8月なのか。</p>
            <p>まずいなぁ、これでは今年中にゲーム1本作るのは厳しそうだ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/07/28 03:50</h2>
            <p>fg::ThreadTaskの件については保留とした。</p>
            <p>＊</p>
            <p>今のところ大きな問題にはなっていないし、不要になって消す場合にも代替方法は明確だ。</p>
            <p>他の部分の構成が変わってしまうわけでもないので、とりあえずは放置でいいかなと。</p>
            <p>＊</p>
            <p>fg::ThreadTask以外の簡単な部分については処理し終わったので、ベースシステムのイベント処理関係に取りかかっている。</p>
            <p>ベースシステムの、とは言ったが、結局のところそれ以外の部分でもイベント処理関数は固定しない方がいいと思った。</p>
            <p>なので、汎用的にイベント処理関数を変更できる仕組みを考えた。</p>
            <p>複数の項目について、同期を取って変更可能な仕組みにできたとは思うのだが、いまいち扱いにくいような。</p>
            <p>インデックスで管理する仕組みだし、バグの温床になりそうで怖い。</p>
            <p>とは言え、これより良い方法が思い付かないんだよなぁ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/07/27 00:35</h2>
            <p>ちょっと行き詰まっている。</p>
            <p>＊</p>
            <p>イベント処理関数を完全に固定するやり方は、ベースシステム関連に関して言うならよくないかもしれない。</p>
            <p>画面が遷移すれば、画面の描画内容は変わるし、コントローラによる入力の扱い方も変わる。</p>
            <p>イベント処理関数が固定されている状態でそれに対応するためには、自前で分岐処理を書き、呼び出す関数を変えるなどする必要がある。</p>
            <p>しかしながら、そのような処理はごく一般的なものであり、わざわざゲーム側でやるべきことには思えない。</p>
            <p>＊</p>
            <p>全体的に構成を見直すべきかもしれない。</p>
            <p>上記以外にも、例えばfg::ThreadTaskとfg::WaitThreadTask。</p>
            <p>fg::ThreadTaskはいらないのではないだろうか。</p>
            <p>fg::WaitThreadTaskを用意したのは、スレッド数が固定であるfg::ThreadTaskにおいて、処理中に待機が入ってスレッドを占有してしまうと全体の処理が止まってしまうという懸念からだ。</p>
            <p>しかし、スレッド数を固定で用意することにあまり意味はないのではないだろうか。</p>
            <p>固定で用意したとしても、fg::WaitThreadTaskを使えばそれとは別にスレッドを増やせてしまう。</p>
            <p>もちろん、スレッドを増やし続けてしまうとメモリ圧迫などの問題が出るため、fg::WaitThreadTaskは必要な場合にのみ使う、と決めてはいる。</p>
            <p>とはいえ、実際のところfg::WaitThreadTaskの処理をfg::ThreadTaskで処理するのには問題があったとしても、その逆はない。</p>
            <p>無駄に複雑にしているだけにも思えるのだ。</p>
            <p>＊</p>
            <p>他には、描画イベントのパラメータだ。</p>
            <p>再描画関数では範囲を指定することが可能だし、再描画が必要な範囲は描画イベントのパラメータとして受け取ることができる。</p>
            <p>しかし、どのような範囲を指定したところで、現状では全画面が再描画の対象となってしまっている。</p>
            <p>クリッピングによって再描画範囲を指定することは可能だろうけど、そこまでする必要があるものなのかどうか。</p>
            <p>私の用意したインターフェースでは、描画イベント関数と再描画処理は別のスレッドで行なわれる。</p>
            <p>その2つで描画範囲を共有するのは困難なのだ。</p>
            <p>いっそ、常に全体を再描画するようにした方がすっきりするような。</p>
            <p>作るゲームにもよるだろうが、一部分のみよりも全体を再描画する機会の方が多いようにも思えるし。</p>
            <p>＊</p>
            <p>最初の話に戻るが、ベースシステムの構成をより高度なものにするべきかもしれない。</p>
            <p>イベント処理関数を変更可能にするなら、イベント処理関数は複数存在するため、整合性を保つためにイベント処理関数に対する処理は排他ロックをかけてから行なうことになる。</p>
            <p>ただ、単純にそうしてしまうと、1つのイベントを処理している時に他のイベントが処理できなくなる、という問題が発生する。</p>
            <p>そこで、ゲーム側のイベント処理をfg::ThreadTask化することを考えた。</p>
            <p>それであれば、fg::ThreadTaskを起動する時だけロックをかければいいので、処理中はロックをかける必要がなくなる。</p>
            <p>その場合、fg::ThreadTask起動前にベースシステム内で前処理をしておいたりする必要があるだろうな。</p>
            <p>＊</p>
            <p>古いコントローラ制御処理の削除も含めて、色々と修正を加える必要があるな。</p>
            <p>まずは分かりやすいところから進めていこう。</p>
            <p>削除関係が一番簡単だろうから、削除に関する2件を先に進めよう。</p>
            <p>その次に描画イベントの変更だ。</p>
            <p>ベースシステムの構成変更は大幅な変更なので最後だな。</p>
        </div>
        <hr />
        <div>
            <h2>2017/07/20 02:55</h2>
            <p>予想以上に困難だった。</p>
            <p>＊</p>
            <p>メンバの並び順が原因で、破棄時に処理がこける場合があった。</p>
            <p>こういうのはやはり、場合がある、という部分が厄介だ。</p>
            <p>全く同じ記述なのに毎回発生するわけでなく、発生する時としない時がある。</p>
            <p>マルチスレッド処理に起きがちで、原因の特定に時間がかかる問題だ。</p>
            <p>＊</p>
            <p>でもまぁ、今回の問題は今日で解決できた。</p>
            <p>ついでにOpenGL関係でも同じような問題が起きていたので、それも解決した。</p>
            <p>＊</p>
            <p>これでようやく次に進める。</p>
        </div>
        <hr />
        <div>
            <h2>2017/07/19 03:45</h2>
            <p>fg::BasesystemContextに、新たに作成したコントローラ制御処理を追加していっている。</p>
            <p>＊</p>
            <p>もうちょいで完了。</p>
            <p>完了したら、ゲーム側で入力データを取得し、コントローラ割り当てなどに利用する処理を作っていく。</p>
        </div>
        <hr />
        <div>
            <h2>2017/07/15 03:15</h2>
            <p>やる気減退が著しいが、とりあえずできたか。</p>
            <p>＊</p>
            <p>sucrose::ControllerManagerにfg::ControllerRawEvent呼び出し機能を追加した。</p>
            <p>これでコントローラとして使用できるデバイスが直接生成するデータを、イベントとして受け取れるようになった。</p>
            <p>このデータを使って、設定ファイルを生成できるようにしたい。</p>
            <p>＊</p>
            <p>しかし、これだと最近作ったfg::ControllerTesterがいらなくなるような。</p>
        </div>
        <hr />
        <div>
            <h2>2017/07/13 03:45</h2>
            <p>明日にはfg::ControllerRawEventに対応できるかな。</p>
            <p>＊</p>
            <p>昨日、デバイスファイルを開き直せばーと書いたが、それでどうにかなるなんて全く気のせいだった。</p>
            <p>現状得られるデータを見るに、オープン時の初回データは破棄するしかない、というより破棄するべきだな。</p>
            <p>例えボタンを押しながらジョイスティックを接続したところで、初回オープン時に得られるデータではボタンは押されていないことになっている。</p>
            <p>別のジョイスティックを使えば何か別の結果が得られる可能性がないわけではないだろうが、意味のないデータを得られる可能性がある時点で使い物にならないと判断するべきだろう。</p>
        </div>
        <hr />
        <div>
            <h2>2017/07/12 03:10</h2>
            <p>sucrose::ControllerManager作成開始。</p>
            <p>＊</p>
            <p>とりあえず、sucrose::ControllerManagerが受け取ったイベントをほぼそのまま流すイベントのみ対応する予定。</p>
            <p>実際に必要なボタンイベントや軸イベントについては、設定ファイルがないとどうしようもないから後回し。</p>
            <p>＊</p>
            <p>evdevのジョイスティック対応も追加するべきかもしれない。</p>
            <p>evdevでないジョイスティックの制御は、なぜか接続時の軸データがおかしいのが気にかかる。</p>
            <p>evdevの方なら大丈夫、という保証は全くないが。</p>
            <p>＊</p>
            <p>暫定的な対応としては、一度デバイスをオープン、クローズしてから再度オープンする、か？</p>
            <p>そうすればおかしなデータは読まずに捨てられるかもしれない。</p>
        </div>
        <hr />
        <div>
            <h2>2017/07/11 04:10</h2>
            <p>sucrose::UdevJoystickManager完成。</p>
            <p>＊</p>
            <p>次はsucrose::ControllerManagerだけど、その前にsucrose::UdevJoystickManagerを試しに使ってみよう。</p>
            <p>動作が確認できているのは単体レベルなので、他と組み合わせたりするとちゃんと動くかどうか、まだ不安だ。</p>
            <p>その辺を確認してから次に進む。</p>
        </div>
        <hr />
        <div>
            <h2>2017/07/08 04:25</h2>
            <p>後はsucrose::UdevJoystickManagerを作るだけになった。</p>
            <p>＊</p>
            <p>ジョイスティックの入出力自体は作った。</p>
            <p>接続と切断についての管理を、sucrose::UdevJoystickManagerで行なう。</p>
            <p>その辺が未完成だ。</p>
            <p>＊</p>
            <p>しかし、既存の型であるsucrose::GamepadManagerとそれに関連する型よりも、整った構成になったように思う。</p>
            <p>いい傾向だ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/07/07 03:15</h2>
            <p>udevを扱う型、sucrose::UdevManager完成。</p>
            <p>＊</p>
            <p>今は、sucrose::UdevManagerで検出したゲームパッドを扱う型として、sucrose::UdevJoystickManagerを作っている。</p>
            <p>接続、切断、ボタン、軸のイベントがあるので、多少めんどくさい。</p>
            <p>でもまぁ、大まかな構成は既存のものと同じなので、そこから持ってくれば明日中には完成するかな。</p>
            <p>とりあえず必要最低限な情報を扱うものを作る。</p>
            <p>まさに接続、切断、ボタン、軸のイベントを処理するだけのもの。</p>
            <p>デバイス名だとか、ボタン数だとか、軸数だとかについては取得しない。</p>
            <p>＊</p>
            <p>ただ、既存のものにはなかった要素として、デバイスを特定する情報は生成する。</p>
            <p>具体的には、接続したポートとデバイスを一意な情報として扱う。</p>
            <p>同じデバイスであっても、違うポートに接続すれば別物として扱うのだ。</p>
            <p>udevならそういった情報を取得できるので楽だが、例えばwindowsのdirectinputなんかで同じことはできるのだろうか。</p>
            <p>windowsだからできない、なんてことはないだろうけどdirectinput以外の機能が必要、とかなってくるとめんどくさそうだ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/07/06 04:00</h2>
            <p>udevを扱う型がもう少しで完成。</p>
            <p>＊</p>
            <p>udevで検出したデバイス情報を元にして、デバイスを管理する型に接続したり切断したり、といったことをさせる予定。</p>
            <p>とりあえず古い処理が存在するゲームパッドを対応する。</p>
            <p>他にもキーボードの対応も可能だと思うけど、後回しだな。</p>
            <p>様々な種類のデバイスを統括管理する型の方を先に作る。</p>
        </div>
        <hr />
        <div>
            <h2>2017/07/05 00:30</h2>
            <p>入力テストを行なう型について、作れるところまで作った。</p>
            <p>＊</p>
            <p>といっても、入力テストを行なう型、fg::ControllerTesterは中身ほぼ空っぽでなにもしない状態だけど。</p>
            <p>ここから先は、デバイスを扱う型を別に作り、fg::BasesystemContextに搭載しないと話が進まない。</p>
            <p>どのように構成すべきか、というところまで済ませた。</p>
            <p>明日は末端から作っていく。</p>
            <p>末端の処理は既に作ってあるものを流用できると思うので、さくさく作っていきたい。</p>
        </div>
        <hr />
        <div>
            <h2>2017/07/04 03:05</h2>
            <p>ID型の内容については後回しにすることにした。</p>
            <p>＊</p>
            <p>udevの接続時に得られる情報とか、その辺を実際に見てから決めることにする。</p>
            <p>あと、IDというのはゲームパッドではなく、ゲームパッドのボタン1つや軸1つにつき1つずつ用意することにしようと思う。</p>
            <p>私の考えている改訂版では、ゲームパッド自体を一意に示す情報があっても大して役に立たないのだ。</p>
            <p>ゲームパッドに搭載されている要素1つ1つに用があるので、それらに対して一意に示す情報があればいい。</p>
            <p>＊</p>
            <p>とりあえず、入力テストを行なう型を生成するために必要な情報をまとめた型を作った。</p>
            <p>中身空っぽの暫定的なID型も作ったし、明日は入力イベントの対応から入る。</p>
            <p>入力イベントが出来上がったら、いよいよ入力テスト処理だ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/07/01 03:35</h2>
            <p>また先走るところだった。</p>
            <p>＊</p>
            <p>初回設定を行うかどうか、なんて処理は後でいい。</p>
            <p>とにかく初回設定に必要な機能を作ろう。</p>
            <p>まず初回設定をできるようにする。</p>
            <p>次に初回設定を保存できるようにする。</p>
            <p>そして読み込み処理を作り、その後にようやく初回設定するかの判定処理を入れる。</p>
            <p>この順で片付けていくべきだろうな。</p>
            <p>＊</p>
            <p>というわけで、初回設定を行うために、ゲームパッドの入力を読み取るインターフェースを大体作った。</p>
            <p>ゲームパッドの入力値やゲームパッドを特定するための情報についてはまだちょっともやもやしているため、まだ作っていない。</p>
            <p>後者については、入力デバイスの種類、入力デバイス名、デバイスが接続されているポートを特定する情報、を文字列にまとめられればよさそうな気がするのだが。</p>
            <p>それらをID型として定義すればいける、か？</p>
        </div>
        <hr />
        <div>
            <h2>2017/06/30 03:30</h2>
            <p>おととい辺りに、SEGVについては解決した。</p>
            <p>＊</p>
            <p>ゲームパッドの扱いの改良版を作ろうとしているが、やはり自身にとっての未踏領域のためなかなか手が出ない。</p>
            <p>コントローラ設定アプリ起動時に、コントローラ設定数が0だった時初回設定を行うようにしよう、というのは決めた。</p>
            <p>しかしコントローラ設定数はどこから取得できるようにするべきか。</p>
            <p>fg::BasesystemContextからであるのは確定だが、そこから直接取得するか、コントローラ管理の参照を取得し、そこから取得するか。</p>
            <p>後々他にも色々な情報を取得することを考えると後者にするべきかもしれないが、前者の方が現時点では簡単だ。</p>
            <p>とりあえずはfg::BasesystemContextから直接取得する形でやろう。</p>
            <p>結局、最終的にその形で落ち着きそうな気もする。</p>
        </div>
        <hr />
        <div>
            <h2>2017/06/21 01:55</h2>
            <p>実に困った。</p>
            <p>＊</p>
            <p>ゲームのユーザーデータの破棄が、場合によってはSEGVで失敗する。</p>
            <p>その原因がいまいち分からない。</p>
            <p>少なくともへびゲームでは発生していなかったのだが、ユーザーデータの内容を少なくしていったら発生するようになった。</p>
            <p>＊</p>
            <p>色々いじくってたら、原因は分かった。</p>
            <p>ゲームのライブラリをアンロードした後に、ゲームのライブラリ内にあるユーザーデータ破棄関数を呼び出そうとしたためだ。</p>
            <p>しかし、それならユーザーデータの内容に関わらずに発生しなければ辻褄が合わないのだが。</p>
            <p>デバッガを使って調べた限りでは、そういう結論になった。</p>
            <p>＊</p>
            <p>実際、構成がおかしいのだ。</p>
            <p>ゲームのライブラリロード前に生成したインスタンスに対して、ゲームのライブラリ中で生成しているユーザーデータを設定してしまっている。</p>
            <p>これでは今回のようなバグが発生してしまうのは当然と言える。</p>
            <p>構成を大きく修正するべきかもしれない。</p>
        </div>
        <hr />
        <div>
            <h2>2017/06/16 03:45</h2>
            <p>へびゲームでOpenGLの描画タスクを使用するようにしたりなどした。</p>
            <p>＊</p>
            <p>OpenGLの描画タスクが想定通りに機能するか不安だったが、特に問題なく使用できて一安心。</p>
            <p>最終的に、へびゲームのソースを400行近く削減できた。</p>
            <p>OpenGLの描画タスクに分かりにくい処理をまとめた関係で、ゲーム側にそういった処理を書かずに済むようになったし、いい感じ。</p>
            <p>＊</p>
            <p>というわけで、明日からはゲームパッドの扱いの改訂版作成に戻ろう。</p>
            <p>描画処理が書きやすくなったから、前よりは楽に進められるはず。</p>
        </div>
        <hr />
        <div>
            <h2>2017/06/15 02:30</h2>
            <p>ゲーム初期化前にウィンドウを生成するように変更完了。</p>
            <p>＊</p>
            <p>ゲームパッドマネージャについてもゲーム初期化前に生成するようにしたので、ゲーム初期化後にはデータの設定とスレッドプールの開始をするだけになった。</p>
            <p>明日はへびゲームをどうにかするとしよう。</p>
        </div>
        <hr />
        <div>
            <h2>2017/06/14 02:30</h2>
            <p>ゲームパッドについても対応完了。</p>
            <p>＊</p>
            <p>明日は、ゲーム初期化より前にウィンドウを生成するように処理を変更する。</p>
            <p>それが済めばようやく、OpenGLの描画タスクを利用できるようになるな。</p>
        </div>
        <hr />
        <div>
            <h2>2017/06/13 03:30</h2>
            <p>なんとか、関数の追加はできた。</p>
            <p>＊</p>
            <p>fg::WindowInfoへのイベント関数及びユーザーデータ設定関数を追加して、さて古い関数を消して帳尻合わせるか、と思ったら他の部分にも追加が必要なことに気付いてやる気が下がった。</p>
            <p>fg::BasesystemArgsだ。</p>
            <p>とりあえず、そちらにもfg::WindowInfoに似た関数の追加を行なって、関数の追加については完了。</p>
            <p>古い関数の削除などは明日にする。</p>
            <p>＊</p>
            <p>想定外なことが起きるとやる気がぐーんと下がるの、よくないなぁ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/06/10 01:30</h2>
            <p>頭を絞って、どうにか便利そうなインターフェースになった気がする。</p>
            <p>＊</p>
            <p>イベント関数の設定と、イベント関数から参照できるユーザーデータの設定関数はそれぞれ別々に用意した。</p>
            <p>それだけだと、イベント関数で参照できるユーザーデータの型が分からず、void *をキャストする必要があり、ちょっと気分が悪い。</p>
            <p>そこで、可変長テンプレート関数を用意して、イベント関数とユーザーデータの設定を1つの関数で一気にできるようにした。</p>
            <p>この形にしたことで、イベント関数で参照するユーザーデータの型と、設定するユーザーデータの型を統一できるようになった。</p>
            <p>＊</p>
            <p>とはいえ、各設定関数の実装とテストがまだだ。</p>
            <p>来週の頭には済ませてしまいたい。</p>
            <p>問題ないようなら、同じ形でゲームパッドについてもちゃっちゃと実装してしまおう。</p>
            <p>そうすれば、ゲーム初期化より前にウィンドウを生成するように変更する作業に移れる。</p>
            <p>と思ったが、よく考えたらベースシステムの引数にイベント関数を設定する処理もあるんだったな。</p>
            <p>なかなか手間がかかりそうだ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/06/09 03:45</h2>
            <p>タスク生成関数のテンプレート修正完了。</p>
            <p>＊</p>
            <p>これによって、わざわざvoid *で渡されるユーザーデータをキャストして、とかやる必要がなくなった。</p>
            <p>違う型にキャストしてしまう、なんてミスも起こらなくなるし、いい感じ。</p>
            <p>＊</p>
            <p>さて、ウィンドウのイベントハンドラについて、インターフェースを修正しようと試しに記述したのだが、これでいいのか不安になる。</p>
            <p>タスク周りの修正がうまく行きすぎたから、相対的に見て微妙な感じに見えるだけだと思うのだが。</p>
            <p>＊</p>
            <p>実行時にデータを引き渡すタスクのようなもの、があれば便利かもしれない。</p>
        </div>
        <hr />
        <div>
            <h2>2017/06/08 04:10</h2>
            <p>苦戦したが、なんとかできた。</p>
            <p>＊</p>
            <p>OpenGLの描画タスク完成。</p>
            <p>それに伴って、タスクの型をちょっと修正した。</p>
            <p>OpenGLの描画タスクに加えた処理では自身を再度実行する可能性があるのだが、タスク内から再度自身を実行する、という処理ができなかったのだ。</p>
            <p>それができるように、型を修正して対応した。</p>
            <p>＊</p>
            <p>明日はタスク生成関数のテンプレートの定義修正から。</p>
        </div>
        <hr />
        <div>
            <h2>2017/06/07 01:30</h2>
            <p>さて、困ったことになった。</p>
            <p>＊</p>
            <p>現状では、インターフェースの変更についての修正をへびゲームに適用したので、動くようにはなった。</p>
            <p>しかし、OpenGLの描画タスクはまだ使えていない。</p>
            <p>ゲームの初期化時点ではまだfg::Windowが生成されていない、というのが問題だ。</p>
            <p>OpenGLの描画タスクは、生成関数の引数としてfg::Windowとfg::GLContextの参照を必要とする。</p>
            <p>fg::Windowが生成されていないゲーム初期化時点において、OpenGLの描画タスクを生成することができないのだ。</p>
            <p>＊</p>
            <p>しかしながら、ぱっと見た感じfg::Windowをゲーム初期化時点までに生成してはならない、というわけではないように見える。</p>
            <p>ゲーム初期化時にfg::Windowから呼び出されるイベントハンドラの生成などを行なっているため、それらを使うfg::Windowの生成はゲーム初期化の後、というだけの話だ。</p>
            <p>ゲーム初期化より前にfg::Windowを生成しつつ、ゲーム初期化時に生成したイベントハンドラが利用される形になれば、問題ないわけだ。</p>
            <p>そのくらいなら、ちょっと工夫すれば対応可能だろう。</p>
            <p>＊</p>
            <p>さて、どこから手を付けるかな。</p>
            <p>まずは、OpenGLの描画タスクについて、少し処理を追加する。</p>
            <p>それでOpenGLの描画タスクは完成とする。</p>
            <p>次にタスク生成関数のテンプレートの定義修正。</p>
            <p>それらが済んだら、ウィンドウとかゲームパッドのイベントハンドラについてのインターフェース修正かな。</p>
            <p>で、ベースシステムの処理を変更し、ゲーム初期化より前にウィンドウを生成する、と。</p>
            <p>大体そんな感じか。</p>
            <p>そこまでできれば、へびゲームでもOpenGLの描画タスクを使用できるようになるだろう。</p>
        </div>
        <hr />
        <div>
            <h2>2017/06/06 01:25</h2>
            <p>OpenGLの描画タスクについて、とりあえず自動テストは通した。</p>
            <p>＊</p>
            <p>明日、へびゲームで実際に使ってみよう。</p>
            <p>あと、タスク生成関数のテンプレートについて少し定義を変更する、というのもやる予定。</p>
        </div>
        <hr />
        <div>
            <h2>2017/06/03 03:00</h2>
            <p>タスク周りは完了した感じ。</p>
            <p>＊</p>
            <p>細かい修正と、タスク生成関数のバリエーション追加が完了したので、そこでバージョンを区切っておいた。</p>
            <p>ラッピングタスクの方はまだ。</p>
            <p>とりあえず、OpenGLの描画タスクを追加するつもり。</p>
            <p>このタスクによって、自前でfg::GLCurrentを生成したり、バッファのスワップをしたりということをしなくても済むようになる予定。</p>
            <p>OpenGLの描画タスク、と言っても単にfg::WaitThreadTaskを生成するだけだ。</p>
            <p>想定通りなら割と簡単に済むと思うのだけど、そううまくいくだろうか。</p>
        </div>
        <hr />
        <div>
            <h2>2017/06/02 03:40</h2>
            <p>やはり手間取った。</p>
            <p>*</p>
            <p>とはいえ、ファンクタを関数ポインタに変更するのは完了した。</p>
            <p>ただ、タスクを利用していた箇所に一部、このままだと違和感を感じる箇所があるので、そこは明日修正する。</p>
            <p>それが終わったら、タスク生成関数のバリエーション追加と、それを使ったラッピングタスクの追加、って感じか？</p>
            <p>そこまでやったら、前に作ったへびゲームを修正して動くようにしてみるか。</p>
            <p>前よりは整った記述になる、と思うのだけど。</p>
        </div>
        <hr />
        <div>
            <h2>2017/06/01 03:30</h2>
            <p>タスク起動インターフェースの修正が思ったよりも手間取ってしまった。</p>
            <p>＊</p>
            <p>なので、関数の呼び出し方変更についてはまだ。</p>
            <p>明日には仕上げる予定。</p>
            <p>あと、タスク生成関数のバリエーションを1つ追加する予定。</p>
            <p>タスクの関数から参照できるデータは、別の場所に格納されているデータの参照だけだが、タスクの中にデータを格納できるようにもしたい。</p>
            <p>そうしなければ、ラッピングしたタスクが作れなさそうなのだ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/05/31 03:15</h2>
            <p>いい調子だ。</p>
            <p>＊</p>
            <p>sucroseのタスク関係のソースファイルをベースシステム関係に統合完了。</p>
            <p>fgから、スレッドプール関係の記述を削除。</p>
            <p>あとは、タスク起動のインターフェース修正と、タスクで呼び出す関数をファンクタから関数ポインタに変える、といったところか。</p>
            <p>そのくらいなら、明日中にできるかな。</p>
        </div>
        <hr />
        <div>
            <h2>2017/05/30 03:30</h2>
            <p>もっと丁寧に進めることにした。</p>
            <p>＊</p>
            <p>とりあえず、sucroseのビルドルールを修正。</p>
            <p>自動テストのビルドで、sucroseで生成するライブラリとリンクすることでコンパイル回数を減らした。</p>
            <p>今までは依存しているソースファイルを全てコンパイルしていた。</p>
            <p>なので、ちょっとソースファイル追加するだけで色々な自動テストのビルドルールにソースファイルを追加しなければならず、面倒だった。</p>
            <p>今回の修正で、割と楽になったはず。</p>
            <p>candymakerの方もどうにかできるだろうか。</p>
            <p>＊</p>
            <p>で、fgのタスク関係のソースファイルをベースシステム関係に統合した。</p>
            <p>明日はsucrose側のソースファイルを移動し、統合する。</p>
            <p>そしたらインターフェースを修正し目標達成、の流れの予定。</p>
        </div>
        <hr />
        <div>
            <h2>2017/05/27 04:30</h2>
            <p>盛大に設計ミスってた。</p>
            <p>＊</p>
            <p>タスクについては作り直し。</p>
            <p>既存処理をちょっと改変すれば完了するので、最近書いた処理は全部削除。</p>
            <p>すごい徒労感。</p>
            <p>必死こいてある程度進めたけど、完了まではいけなかった。</p>
            <p>ちゃちゃっと来週前半に終わらせる。</p>
        </div>
        <hr />
        <div>
            <h2>2017/05/26 03:30</h2>
            <p>タスク管理も完成。</p>
            <p>＊</p>
            <p>やっぱりタスク管理で管理しないタスクは最終的に消してしまおうと思う。</p>
            <p>その前に、タスク管理まで作れたので既存処理の置き換え、削除を先にやる予定。</p>
        </div>
        <hr />
        <div>
            <h2>2017/05/25 03:15</h2>
            <p>待機タスクのキャンセラは作り終わった。</p>
            <p>＊</p>
            <p>タスク管理の方はちょっと構成を変えることもあって、今日中は難しかった。</p>
            <p>明日中には作り終えてしまいたいが。</p>
        </div>
        <hr />
        <div>
            <h2>2017/05/24 03:55</h2>
            <p>待機タスクについても作り終わった。</p>
            <p>＊</p>
            <p>あとは待機タスクのキャンセラとタスク管理。</p>
            <p>しかし、タスク管理で管理しないタスクというのは、使う機会あるんだろうか。</p>
            <p>いっそのこと、タスク管理で管理されたタスクだけでもいいのではないか。</p>
        </div>
        <hr />
        <div>
            <h2>2017/05/20 00:55</h2>
            <p>とりあえず、普通のタスクの方は作り終わった。</p>
            <p>＊</p>
            <p>来週中頃には待機タスクやタスク管理を作り終えたいところ。</p>
            <p>タスク管理の部分に関しては、ちょっと構成を変更する予定。</p>
            <p>複数のタスクが存在し、あるタスクから別のタスクを起動する、というようなことをやると、その別のタスクがすでに破棄されているのに起動しようとしてしまう、ということが起きかねない。</p>
            <p>そこでタスク管理というものを置き、それが存在している間は別のタスクの起動が成功し、破棄が始まれば起動が失敗するようになるので安全に複数のタスクを破棄できるようにしている。</p>
            <p>現状、これはタスクとタスク管理の2つを引数に取るタスク起動関数を使うことで対応しているが、これではタスク管理を用いていてもタスク管理を使用しないタスクの起動もできてしまう。</p>
            <p>後者はバグの温床であり、そういうことができない構成が望ましい。</p>
            <p>なので、ただのタスクとは別に、タスク管理によって管理されているタスク、というものを用意しようと思う。</p>
            <p>＊</p>
            <p>しかし、これをどのような位置付けにするか、ちょっと悩んでいる。</p>
            <p>型から別のものにしてしまうのが、確実な方法だろう。</p>
            <p>しかし、型は同じで、タスクで実行する関数をラッピングする、という方法でもできそうな気がする。</p>
            <p>その場合、ただのタスクと管理されているタスクを全く同じように扱うことができる。</p>
            <p>…が、そうすることによって何か得することがあるのか、というところに疑問が残る。</p>
            <p>型による判別ができなくなるため、むしろバグの温床になりそうな気が。</p>
        </div>
        <hr />
        <div>
            <h2>2017/05/18 01:30</h2>
            <p>やる気はびみょうだけど、ちょっとずつ進んでる。</p>
            <p>＊</p>
            <p>やはり、同じ名前の機能の追加はやりにくいな。</p>
            <p>仮の名前を置いて作業しないとうまくいかない。</p>
            <p>作り終えて、古い機能を削除するまでの辛抱だ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/05/16 03:25</h2>
            <p>モチベーションが上がらない。</p>
            <p>＊</p>
            <p>なので、別のところを進めることにした。</p>
            <p>基本的に、イベントハンドラという名前を使うことをやめることにする。</p>
            <p>大体これのせいで、ゲーム側のコードが長くなっているのだ。</p>
            <p>全てタスクで統一する形にしようと思う。</p>
            <p>現時点では汎用的に使える2種類のタスクがあるが、用途別にタスクを用意する。</p>
            <p>タスク内で使えるデータ、つまり引数が異なる感じだ。</p>
            <p>＊</p>
            <p>これに付随して、現時点ではスレッドプールというものをゲーム側から参照できるようにしているが、これもやめる。</p>
            <p>いちいちベースシステムのコンテキストからスレッドプールの参照を取得し、タスクを生成、なんてめんどくさいのだ。</p>
            <p>ベースシステムのコンテキストの参照を渡して生成してしまえばいいじゃないか。</p>
            <p>これに伴い、fg-threadはfg-basesystemに統合する。</p>
            <p>＊</p>
            <p>タスクで実行する関数は、C++だしファンクタ、std::functionで定義したものを使っていたが、Cの関数ポインタにしようと思う。</p>
            <p>そもそもテンプレートで定義するものを使うのは、なんだか気分が悪かったのだ。</p>
            <p>言語自体に用意されてるものの方が、何かと都合がよさそうな気がする。</p>
        </div>
        <hr />
        <div>
            <h2>2017/05/11 00:45</h2>
            <p>少し困ったことになった。</p>
            <p>＊</p>
            <p>ゲーム側で、fgなどのモジュールを使用するコードを含む部分について、自動テストコードを動かすことができない。</p>
            <p>モジュールのファイルパスを直接指定してリンクしてやれば動かせると思うが、それをどうやってビルドルールに組み込むか、という話になってくるな。</p>
        </div>
        <hr />
        <div>
            <h2>2017/05/09 01:45</h2>
            <p>突貫工事にはまるで向いてないな、この構成。</p>
            <p>＊</p>
            <p>とりあえず画面になんか表示しよう、と1ファイルにどんどん追加していったらすごくごちゃごちゃしてしまった。</p>
            <p>で、冷静になって一旦元に戻した。</p>
            <p>＊</p>
            <p>コントローラの設定のためのインターフェースは、まだまとまっていない。</p>
            <p>ゲームパッドを特定する情報と、押されたボタンを特定する情報があれば、とりあえずできるだろうか。</p>
            <p>その2つを、何番のコントローラに割り当てるのか、という情報と合わせて設定する感じで。</p>
        </div>
        <hr />
        <div>
            <h2>2017/05/02 02:10</h2>
            <p>画面作り始めた。</p>
            <p>＊</p>
            <p>ゲームパッドの扱いの改訂版を作るに当たり、どこから進めるべきか迷って、まず画面から始めることにした。</p>
            <p>ゲームパッドの初期設定を、画面見ながらいわゆるウィザード形式でできるようにする予定なので、画面がないと始まらないかな、と。</p>
            <p>ウィザードの説明文を表示するための機能が足りてないが、これは後回しでいいだろう。</p>
            <p>作っている私が把握できればいいので、適当に三角形でも表示しておけばいいのだ。</p>
            <p>＊</p>
            <p>問題は構成の方だ。</p>
            <p>かなり大掛かりで、ややこしい感じになりそうな気がする。</p>
            <p>うまいこと機能を分割して、小さく小さく作っていけたらいいのだが。</p>
        </div>
        <hr />
        <div>
            <h2>2017/04/29 03:40</h2>
            <p>体調が治ってきた。</p>
            <p>＊</p>
            <p>fg::ModuleContextがモジュース初期化より後でも使えることを確認した。</p>
            <p>adhocrepeaterを搭載したraspberrypiの調整をしたりなどもした。</p>
            <p>来週からセーブデータ機能を利用する処理の作成だな。</p>
        </div>
        <hr />
        <div>
            <h2>2017/04/26 03:10</h2>
            <p>fg::ModuleContextをモジュール破棄まで保持するように変更した。</p>
            <p>＊</p>
            <p>しかし、現状では初期化が成功するところまでしかテストコード書いてないな。</p>
            <p>明日、テストコードを追加して確認しよう。</p>
            <p>＊</p>
            <p>体調が思わしくない。</p>
            <p>気温が急激に変化したからだろうか。</p>
        </div>
        <hr />
        <div>
            <h2>2017/04/24 23:40</h2>
            <p>データ要素の文字列化についての修正をした。</p>
            <p>＊</p>
            <p>文字列への変換ではなく、ファイルデータ型に変換するように変更した。</p>
            <p>文字列化をするのはファイルに書き込むためだし、文字列化してからそれをファイルデータ型につっこむ、というのは回りくどいと思っていたのだ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/04/22 00:15</h2>
            <p>セーブデータの読み書き、とりあえず完了。</p>
            <p>＊</p>
            <p>とはいえ、これは暫定的な処理だ。</p>
            <p>まず、セーブデータディレクトリというものを用意していないため、セーブファイルはパッケージディレクトリに対して書き込まれるようになっている。</p>
            <p>それに加えて、データが平文なので容易に改竄できてしまう。</p>
            <p>＊</p>
            <p>しかしながら、とりあえずは機能するし次回からはセーブデータを必要とする機能の作成を、といきたいがまだちょっと無理だな。</p>
            <p>セーブデータの読み書きにはfg::ModuleContextが必要だが、fg::ModuleArgsから名前だけ変えただけの今の作りでは、モジュール初期化処理後にfg::ModuleContextは消滅してしまう。</p>
            <p>なので、ベースシステムが終了するまではfg::ModuleContextを保持しておくように変える必要がある。</p>
            <p>それ以外に、細かい修正もしておきたい。</p>
        </div>
        <hr />
        <div>
            <h2>2017/04/21 03:30</h2>
            <p>要素の文字列化は作り切った。</p>
            <p>＊</p>
            <p>セーブデータの書き込みと読み込み、明日中にいけるかな。</p>
            <p>新たに作る処理といえばファイル書き込みくらいだし、問題ないと思うけど。</p>
        </div>
        <hr />
        <div>
            <h2>2017/04/20 03:35</h2>
            <p>セーブデータの内容生成処理完成。</p>
            <p>＊</p>
            <p>次は要素の文字列化、そしてセーブデータ書き込みだな。</p>
            <p>明日中にそれを終わらせて、あさってに読み込みを作って完了、といけばきりがいいのだが。</p>
        </div>
        <hr />
        <div>
            <h2>2017/04/19 01:10</h2>
            <p>セーブデータの内容生成処理、もう少しで完成。</p>
            <p>＊</p>
            <p>残件は、リストやマップへの要素追加。</p>
            <p>現状の案では、引数のクローンを生成し、クローンを要素として追加する、という形が一番問題が起きにくいだろう考えている。</p>
            <p>そこが出来上がったら、いよいよセーブデータ書き込み処理に入る。</p>
            <p>要素の文字列化はまだやったことがないので、多少手間取るかもしれない。</p>
            <p>とはいえ、文字列からの解析処理に比べたらずっとましだろう。</p>
        </div>
        <hr />
        <div>
            <h2>2017/04/15 03:10</h2>
            <p>普通に考えて、セーブデータは書き込みが先だな。</p>
            <p>＊</p>
            <p>セーブデータを作成しないことには、読み込み機能なんて作っても意味ないし。</p>
            <p>やる気のせいもあって、今日はインターフェースを整えただけで終わってしまった。</p>
            <p>来週中には読み書きをできるようにしたいところ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/04/14 03:20</h2>
            <p>不要になった処理の削除完了。</p>
            <p>＊</p>
            <p>fg::FileR、fg::DirPathR、fg::ModuleArgsを削除した。</p>
            <p>パッケージ内に配置したファイルの読み込みがやりやすくなって、いい感じ。</p>
            <p>明日はセーブデータの読み込みをやる予定だけど、ちょっと構成をいじる必要がある気がする。</p>
        </div>
        <hr />
        <div>
            <h2>2017/04/13 02:50</h2>
            <p>既存処理の改訂版作成は完了。</p>
            <p>＊</p>
            <p>差し替えと既存処理の削除は、なかなか規模が大きいこともあり、やはり完了できなかった。</p>
            <p>特に、モジュール初期化関数の引数変更については、変える必要がある自動テストがあるし、ちょっとめんどう。</p>
            <p>明日には完了したい。</p>
        </div>
        <hr />
        <div>
            <h2>2017/04/12 03:20</h2>
            <p>進め方を少し間違えた。</p>
            <p>＊</p>
            <p>その関係で、ちょっと進行が遅れた。</p>
            <p>明日中には、処理の改訂と不要になった部分の削除を済ませてしまいたいが。</p>
        </div>
        <hr />
        <div>
            <h2>2017/04/11 02:55</h2>
            <p>パッケージ内のファイル取得処理の改訂版をとりあえず作った。</p>
            <p>＊</p>
            <p>fg::FileRやfg::DirPathRはいらなくなるので、その辺の処理も消して簡略化する予定。</p>
            <p>セーブデータ読み込み処理は、既存部分の改訂を済ませてからだな。</p>
        </div>
        <hr />
        <div>
            <h2>2017/04/07 02:30</h2>
            <p>いまいちしっくりこない。</p>
            <p>＊</p>
            <p>でもまぁ、こんなものだろう。</p>
            <p>パッケージ内のファイル取得と、セーブデータ読み込みについてのインターフェースを追加。</p>
            <p>とりあえずこれで作ってみようと思う。</p>
            <p>この構成なら、ファイル関係のモジュールがいらなくなるが処理自体は1つのモジュールに収めておけば済む形にできるな。</p>
        </div>
        <hr />
        <div>
            <h2>2017/04/06 03:50</h2>
            <p>パッケージ内のファイル取得インターフェースも変えるべきな気がしている。</p>
            <p>＊</p>
            <p>ファイルを開いてそれを読み込む、などということをいちいちやるようなインターフェースは違和感がある。</p>
            <p>処理が低レイヤーすぎる。</p>
            <p>いちいちそんなことをしなくても、ファイル取得といえばファイルの内容を全て読み込む以外にすることなんてないのだし。</p>
            <p>もっと単純な形でいいはずだ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/04/05 02:45</h2>
            <p>ヘッダファイルの問題は解決。</p>
            <p>＊</p>
            <p>あれ、よく考えたら今日追加したのはセーブデータの内部フォーマット作成関係のインターフェースじゃないか。</p>
            <p>いかんな、作業間違えてた。</p>
            <p>セーブデータ読み込みインターフェースを作らないと。</p>
        </div>
        <hr />
        <div>
            <h2>2017/04/04 03:30</h2>
            <p>やれやれ。</p>
            <p>＊</p>
            <p>既存処理の差し替えは完了。</p>
            <p>ユニークポインタ周りで不具合があった。</p>
            <p>ひとまず問題が起こらないようにしたけど、根本的な解決はまだ。</p>
            <p>ヘッダファイルのインクルードを忘れると、ビルドは通るが実行しようとするとリンクエラーで実行できない、という現象が発生している。</p>
            <p>どうすればいいのか大体は把握できているので、明日中には直す。</p>
        </div>
        <hr />
        <div>
            <h2>2017/04/01 02:30</h2>
            <p>セーブデータの内部フォーマット解析処理作成完了。</p>
            <p>＊</p>
            <p>来週から既存処理との差し替えと、セーブデータ読み込みインターフェースの整備と。</p>
            <p>そんな具合に進めていく予定。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/31 03:15</h2>
            <p>完了の目処はついた。</p>
            <p>＊</p>
            <p>明日中には、セーブデータの内部フォーマット解析処理を作り切れるはず。</p>
            <p>文字列について、処理を改良した上で完了した。</p>
            <p>同じような感じで、リストとマップを対応すれば完了。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/30 04:15</h2>
            <p>想像以上に処理がびみょう。</p>
            <p>＊</p>
            <p>処理どころかテストもびみょう。</p>
            <p>なので、元の処理に手を加えていく形で対応しようとしている。</p>
            <p>やる気減退してるというのもあるけど、さすがに1日では無理だった。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/29 01:40</h2>
            <p>演算子オーバーロードなんて消滅してしまえばいいのに。</p>
            <p>＊</p>
            <p>それに付随するADLとかいう概念が邪魔をして、無駄に時間を使ってしまった。</p>
            <p>しかしそのかいあって、ユニークポインタの宣言と定義をfgにまとめることができた。</p>
            <p>fgとsucroseとcandymaker、それぞれ別々に記述してるのが気持ち悪かったし、いい感じ。</p>
            <p>＊</p>
            <p>セーブデータの内部フォーマット解析用インターフェースの定義はできた。</p>
            <p>といっても、既に処理まで作ってある、文字列、リスト、マップのみ。</p>
            <p>できてる部分の書き換えなら簡単にできるし、数値型なんて現時点ではいらないし。</p>
            <p>明日中にcandymakerに追加したい。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/28 00:45</h2>
            <p>やる気減退中。</p>
            <p>＊</p>
            <p>セーブデータについては、もっときちんと考えてから取り掛かるべきだと思った。</p>
            <p>インターフェースを定義することにより、ゲーム側が簡単にセーブデータを作成したり、作成したデータを読み込んだり、だけで済む話ではない。</p>
            <p>セーブデータのフォーマットを定めることにより、ゲーム外から参照した場合にもセーブデータ名などの情報を参照したり、コピーや削除などをできるようにしたい。</p>
            <p>簡単に言えば、PlayStationのメモリーカード管理画面のような、ああいった機能を実現できるようにしたいのだ。</p>
            <p>そう考えると、とりあえずファイル書き込み機能を作ってセーブデータのファイルを作れるようにしました、という対応は今後を考えるとあまり意味がないと思うのだ。</p>
            <p>もちろん、内部的にはそういった処理も必要になるので、完全に無駄になるというわけでもないと思うが。</p>
            <p>＊</p>
            <p>そういう意味では、現在のゲームパッドの対応もよくない。</p>
            <p>ゲームパッドの接続や切断、どのゲームパッドのどのボタンが押された、などといった情報を直接ゲーム側に渡してしまっている。</p>
            <p>デバイスとゲーム側との間に制御プログラムを挟み込むことにより、柔軟なことができるようにしたいのだ。</p>
            <p>しかし、そのためにはセーブデータの概念は必須だろうな。</p>
            <p>デバイスをどのように管理するか、という情報はセーブデータとして格納するのだから。</p>
            <p>＊</p>
            <p>ちなみに、セーブデータの内部フォーマットについては、設定ファイルのものを改良した上で流用しようかと考えている。</p>
            <p>現時点ではリストやマップといった構造を除くと文字列値しか扱えないので、数値も扱えるようにする。</p>
            <p>そして、ファイル形式としてテキスト形式以外にバイナリ形式にも対応する。</p>
            <p>さすがに、プレイヤーが簡単に参照したり改変したり、ができるのはどうかと思うし。</p>
            <p>暗号化したテキスト形式をバイナリ形式として扱えば手軽か？</p>
            <p>それだとゲーム外からの参照が困難になるな。</p>
            <p>暗号化要素という概念でも追加して、一部の要素のみ暗号化、ということができるようにするか。</p>
            <p>＊</p>
            <p>さて、どこから進めるか。</p>
            <p>fgに、セーブデータの内部フォーマット解析インターフェースを定義するところからかな。</p>
            <p>ひとまず暗号化については後回しで。</p>
            <p>既に作ってある設定ファイル解析処理を使い回して、処理を実装。</p>
            <p>それを作ると設定ファイル解析処理と内容が被るため、差し替え。</p>
            <p>セーブファイル読み込みインターフェースの定義、実装。</p>
            <p>セーブファイル書き込みインターフェースの定義、実装。</p>
            <p>そこまで済めば、セーブファイルが必要になる機能も手を付けられるだろう。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/25 02:50</h2>
            <p>とりあえずOpenGL関数追加完了。</p>
            <p>＊</p>
            <p>へびゲームがきちんと動作することも確認済み。</p>
            <p>これであとはセーブデータの読み書きもできるようにすれば、それらしいゲームを作れる気がする。</p>
            <p>＊</p>
            <p>しかしOpenGL対応は、現時点は仮対応だな。</p>
            <p>もっとちゃんとやるなら、使用するバージョンやら拡張機能やらをゲーム側が指定し、そのチェックなどをするべきだろう。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/24 03:15</h2>
            <p>昨日のうちに、ウィンドウに対する処理の追加は完了した。</p>
            <p>＊</p>
            <p>具体的には、タイトル設定とウィンドウサイズ固定。</p>
            <p>今日からOpenGL対応。</p>
            <p>過去のプロジェクトで作った処理を流用して追加しようとしている。</p>
            <p>＊</p>
            <p>それが終わったら次はなんだろう。</p>
            <p>セーブデータ対応だろうか。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/22 02:35</h2>
            <p>ファイル名などの修正も完了。</p>
            <p>＊</p>
            <p>今までハードコーディングしていた、ウィンドウサイズの設定を引数から設定するように変更。</p>
            <p>合わせて、ウィンドウ内全てに対する再描画要求関数も追加した。</p>
            <p>あとはウィンドウのタイトル設定くらいか。</p>
            <p>ウィンドウ情報へのウィンドウタイトル設定関数の追加も忘れていたようなので、合わせて追加する。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/18 04:10</h2>
            <p>大まかには完了。</p>
            <p>＊</p>
            <p>前に作ったへびゲームのsucrose版関数呼び出し箇所をfg版に変更し、動作するところまで確認できた。</p>
            <p>残件は、ファイル名の修正と一時的に付けた型名、関数名の修正。</p>
            <p>さすがにその程度であれば、2時間もあれば十分完了できるだろう。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/17 03:10</h2>
            <p>足りなかったりいらなかったり、を解消。</p>
            <p>＊</p>
            <p>OpenGL関係のfg版インターフェース定義もやった。</p>
            <p>実装作って、sucrose版消して、を明日中にできるだろうか。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/16 02:55</h2>
            <p>sucrose版の削除も予想以上に面倒だった。</p>
            <p>＊</p>
            <p>OpenGLに関係するものについてもfg版を作らなければいけないようだ。</p>
            <p>他にも、関数定義位置の不備や実装漏れなどがあったりするので、それらまとめて今週中に終わらせるのを目標にやろう。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/14 01:00</h2>
            <p>ゲームパッドの追加は、あとは実際にゲームパッドを扱う部分だけ。</p>
            <p>＊</p>
            <p>ちゃちゃっと追加すればベースコンテキストの方も対応できる。</p>
            <p>それが済めば、いよいよsucrose版の削除に移れる。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/11 01:00</h2>
            <p>ゲームパッドについてもfgに定義を追加しなければならなかった。</p>
            <p>＊</p>
            <p>今日中？無理無理。</p>
            <p>来週の火曜ぐらいまでには片付けたいところ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/10 02:50</h2>
            <p>いつか起きるだろうと思っていた事態の対処でかなり時間を食ってしまった。</p>
            <p>＊</p>
            <p>やはり、先に宣言していないと参照できないというのは面倒だ。</p>
            <p>しかし今日加えた修正により、この点については今後同様の問題が発生しないようにできたはずだ。</p>
            <p>明日中に残件を片付けられるだろうか。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/09 02:50</h2>
            <p>sucrose版の利用箇所をfg版に差し替えるのは後回し。</p>
            <p>＊</p>
            <p>ウィンドウ関係とベースシステム関係、fg版を追加していっている。</p>
            <p>ベースシステムの内部にウィンドウで生成をしているし、ウィンドウの内部でベースシステムの機能を利用している。</p>
            <p>循環参照のような形なので、なかなか追加が面倒だ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/08 00:50</h2>
            <p>想像以上に面倒だった。</p>
            <p>＊</p>
            <p>とりあえずスレッド関係についてはfg版作成完了。</p>
            <p>sucrose版の利用箇所を差し替えるのはまだ。</p>
            <p>今週中には、ウィンドウ関係についてもfg版の作成とsucrose版の利用箇所差し替えまで終わらせたい。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/07 02:50</h2>
            <p>ウィンドウに関する定義を、全てfgに追加した。</p>
            <p>＊</p>
            <p>sucroseの定義をfgに変えている最中。</p>
            <p>最小の修正で変更していくには順序があるので、ちょっと面倒だ。</p>
            <p>明日中には完了したい。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/04 02:45</h2>
            <p>やはりやる気がびみょう。</p>
            <p>＊</p>
            <p>ウィンドウと、ウィンドウ生成時に必要な情報をまとめた型に関する定義を追加した。</p>
            <p>sucroseではイベントハンドラ集合としていたものに、ウィンドウのタイトルとサイズの情報を追加した感じ。</p>
            <p>イベントハンドラ削除関数は使う機会があるとは思えないので追加していない。</p>
            <p>イベントハンドラ呼び出し関数は、実装するライブラリ内に用意すればいいと判断したので追加していない。</p>
            <p>最初に想定していたよりもシンプルな感じになりそう。</p>
            <p>来週の頭には、イベントハンドラの定義を全部追加してしまいたい。</p>
            <p>できれば、実装側も整えられればいいのだが。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/03 01:45</h2>
            <p>ウィンドウ周りを整えるに当たり、fgに定義を追加することにした。</p>
            <p>＊</p>
            <p>fg::newWindow()の引数にfg::BaseContextの参照があるのでその定義の追加が先。</p>
            <p>fg::BaseContextの関連関数のfg::getThreadPool()の戻り値がfg::ThreadPoolの参照なのでその定義の追加が先。</p>
            <p>といった具合で、とりあえずfg-threadを新たに作った。</p>
            <p>fg::BaseContextの定義をfg-basesystemに追加したし、明日からウィンドウに入る。</p>
            <p>現状ではウィンドウのタイトルは無し、幅や高さは固定で生成、ウィンドウのサイズ変更可能となっているので、その辺をどうにかできるように関数を定義する。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/02 01:45</h2>
            <p>ひとまず、ファイル読み込み処理統一を対応した。</p>
            <p>＊</p>
            <p>その他細かい修正もしたが、これ次何をやろう。</p>
            <p>ウィンドウ出せるし、ゲームパッドも扱えるし。</p>
            <p>ウィンドウについては、サイズ固定じゃなかったりといい加減な感じあるが。</p>
            <p>へびゲームを作ったりもできたわけだし、ようやくゲーム自体の制作に入れるのだろうか。</p>
            <p>その場合、何を作るかが問題になるなぁ。</p>
            <p>＊</p>
            <p>ウィンドウ周りをもう少しきちんとしたら、windows向けのモジュール生成をやるというのもいいかもしれない。</p>
            <p>それをできるようにするためにも、玄箱T4を使えるようにしたというのもあるし。</p>
            <p>＊</p>
            <p>ああ、現状だとOpenGL関数を直接呼び出してるんだっけ。</p>
            <p>それだとOpenGL使えない場面でも関数呼び出せちゃって気持ち悪いんだよなぁ。</p>
            <p>古いプロジェクトではその対応も入れてたし、ウィンドウ周りと合わせてそこをやってしまうか。</p>
        </div>
        <hr />
        <div>
            <h2>2017/03/01 01:00</h2>
            <p>rootfsはメモリ上で問題ない、というのが結論。</p>
            <p>＊</p>
            <p>USBメモリにrootfsを構築して玄箱T4を動かしたが、処理時間を計測したところそこまで差が出なかった。</p>
            <p>USBメモリ上のrootfsだと壊れる可能性があり、修復の手間などを考慮するとメモリ上に展開する方がいいだろう。</p>
            <p>＊</p>
            <p>メモリ上にrootfsを展開する場合、TFTPで別のマシンからダウンロードしてくるのだが、ダウンロードだけで30秒程度かかる。</p>
            <p>一度起動してしまえば関係ないとはいえ、多少長いのが気になっていた。</p>
            <p>その件に関しては、ジャンボフレームに対応するようにMTUとtftpコマンドのブロックサイズ指定で解決。</p>
            <p>ほんの数秒でダウンロードが完了するようになった。</p>
            <p>＊</p>
            <p>明日からcandymakerの開発に戻る。</p>
            <p>前に書いた内容だと、ファイル読み込み処理が2つあるからそれを片方に統一するところからやる、とか書いてある。</p>
            <p>しかしそれはやらずとも動いてるわけだし、後回しでいいような気もする。</p>
            <p>まぁ、どこから進めるかは明日状態を見てから決めよう。</p>
        </div>
        <hr />
        <div>
            <h2>2017/02/28 00:41</h2>
            <p>金曜日の時点でハードディスク搭載まではできた、のだが。</p>
            <p>＊</p>
            <p>sambaだけでは不十分な感じがある。</p>
            <p>アクセスしたユーザーでしかファイルにアクセスできないのは不便だ。</p>
            <p>ファイルサーバーとして使うなら問題ないんだけど、linuxのrootfs作る時など、ファイル権限をrootにしたい時もあるし。</p>
            <p>なので、そういった作業用にnfsも必要だと思った。</p>
            <p>＊</p>
            <p>というわけで今日、nfs、hdparm、NTPクライアントを追加したものを作った。</p>
            <p>機能としてはこれで十分なんだけど、rootfsをメモリ上に展開するのは、メモリが128MBしかない玄箱T4では厳しい感じがある。</p>
            <p>ファイル転送速度にも影響が出ているような。</p>
            <p>少なくとも金曜日の時点で、samba上にあるlinuxカーネルのビルドをしようとしてもうまくいかなかったし。</p>
            <p>TFTPでブートしてから、nfsかUSBメモリ上にあるrootfsで動作させて、メモリ上からは退避させようと思う。</p>
            <p>とりあえずはUSBメモリで対応するかな。</p>
            <p>それでファイル転送速度とかが改善されればいいのだが。</p>
            <p>スワップを使用していた時の使用量から考えると、90MBほどメモリが使えれば問題ないはずなのだ。</p>
            <p>まだ2月なわけだし、明日までは玄箱T4の件をやることにする。</p>
        </div>
        <hr />
        <div>
            <h2>2017/02/24 04:35</h2>
            <p>あとはハードディスクを搭載するだけ、になったはず。</p>
            <p>＊</p>
            <p>実際に動かしてみないことにはなんとも言えない。</p>
            <p>しかし、よく考えたらhdparm入れてなかった。</p>
            <p>まぁ、まだ起動しっぱなしにするわけでもないし。</p>
            <p>土日中にビルドしてしまうか。</p>
            <p>あとNTPクライアントも入れてなかったな。</p>
        </div>
        <hr />
        <div>
            <h2>2017/02/23 04:05</h2>
            <p>adhocrepeaterで複数のデバイスを扱えるようにした。</p>
            <p>＊</p>
            <p>しかし、実際に使ってみないことにはちゃんとできてるか分からない。</p>
            <p>週末に動作確認する予定。</p>
            <p>＊</p>
            <p>玄箱T4は、ディスクレスでの稼働と、ハードディスク4台の移植で完了としよう。</p>
            <p>ソフトウェア構成は明日中に完了させたい。</p>
        </div>
        <hr />
        <div>
            <h2>2017/02/22 04:25</h2>
            <p>玄箱T4のemerge完了。</p>
            <p>＊</p>
            <p>しかし困った。</p>
            <p>無線LANアダプタがきちんと動かない。</p>
            <p>ファームウェアがどうのとdmesgにはあるものの、きちんとsys-kernel/linux-firmwareは入れてあるし。</p>
            <p>対応していると思われるファームウェアも含まれてるしで、いまいち原因が分からない。</p>
            <p>そもそも玄箱T4に無線LANアダプタを付けるという構成がおかしいかもしれない。</p>
            <p>玄箱T4やらメインのマシンやらは、有線LANで構成すべきか。</p>
            <p>しかしそれ用にdhcpやらdnsやら、iptablesやらを用意するのは、これまた手間だなぁ。</p>
            <p>とりあえずは固定IPで、iptablesとかその辺はなしでやるか。</p>
            <p>＊</p>
            <p>その辺いじくってたりも並行してやっていたせいもあり、adhocrepeaterの進みはいまいち。</p>
            <p>ひとまず設定ファイルの追加項目について、テストを作った。</p>
            <p>明日中に完了させて、木金で玄箱T4の方も完了させたい。</p>
        </div>
        <hr />
        <div>
            <h2>2017/02/21 01:00</h2>
            <p>想定外に時間がかかっている。</p>
            <p>＊</p>
            <p>玄箱T4でemergeをしているが、想像以上に進みが遅い。</p>
            <p>昨日の夜からやっているので、せめて今日の昼頃には終わるかと思ったのに。</p>
            <p>distccでコンパイルは高速なマシンでやっているものの、それにしたって遅い。</p>
            <p>＊</p>
            <p>adhocrepeaterや玄箱T4の件は、2月中には決着させたい。</p>
            <p>adhocrepeaterの1ポート構成化も、やるべきなのかどうか。</p>
            <p>現状の2ポート構成でも、とりあえず問題はないわけだしなぁ。</p>
            <p>気になるところと言えば、扱えるデバイスの数ぐらいか。</p>
            <p>現状、1つのデバイスしか相手にできない。</p>
            <p>簡単な修正で解決できると思うし、そこぐらいはどうにかするか。</p>
            <p>＊</p>
            <p>3月からはcandymakerの方を進める予定。</p>
        </div>
        <hr />
        <div>
            <h2>2017/02/18 04:36</h2>
            <p>nfs？知らんな。</p>
            <p>＊</p>
            <p>カーネルとファイルシステムを、全て外部からTFTPでダウンロードして起動することに成功。</p>
            <p>起動後は全てメモリ上に配置されるため、有線LANの接続が必要なのは起動時のみ。</p>
            <p>起動中ずっと接続していなければならないnfsとは違う。</p>
            <p>＊</p>
            <p>ファイルシステムに関しては、gentooのstage3を展開したものをほんの少しいじったもので確認しただけ。</p>
            <p>なので、来週はそこをどうにかして、完成といきたいところだ。</p>
            <p>＊</p>
            <p>メモリ使用量は起動直後で40MB弱といったところ。</p>
            <p>まぁ、セットアッププログラムでインストールできるdebianはもうちょい多かった気がするから問題ないだろう。</p>
            <p>stage3をハードディスクに入れて起動した時には3MB弱だから多少気になるが、ファイルシステムが40MB近くあるのだから当然である。</p>
            <p>まぁ、mdraidやらsambaやら、必要なツールつっこんでも容量は大して変わらんだろう。</p>
        </div>
        <hr />
        <div>
            <h2>2017/02/17 04:30</h2>
            <p>動いた動いた。</p>
            <p>＊</p>
            <p>バージョン4.9.9のカーネルに、玄箱T4のカスタマイズパッチを適用したソースをビルドしたカーネルが玄箱T4で動作した。</p>
            <p>miconaplも一応問題なく動いていたようなので、おそらく問題なく手直しできたのだろう。</p>
            <p>しかし現状、miconaplはセットアッププログラムでインストールできるdebian上でなければ動作できていない。</p>
            <p>miconaplはバイナリだし、やはりこれもビルドツールのバージョンの差異の影響だろうか。</p>
            <p>とはいえ、公開されているマイコンの仕様書に沿って互換性のあるツールを自作すれば、この問題はクリアできるようだ。</p>
            <p>しかし、やりたかったのはファンの回転速度を落とすこと程度なので、そんなにすぐ作る必要もないだろう。</p>
            <p>＊</p>
            <p>明日中に、玄箱T4でnfs bootやnfs rootをできるようにしたいところだ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/02/16 04:30</h2>
            <p>玄箱T4の方をやってる。</p>
            <p>＊</p>
            <p>起動させるだけなら簡単にできるかと思ってたけど、そんなことはなかった。</p>
            <p>カーネルのビルドは問題なかった。</p>
            <p>FIT対応とかいうのも問題なく作れる。</p>
            <p>問題は、2.6.30.8のカーネルだとFATAL: kernel too oldとかいって起動でこける。</p>
            <p>ソースのバージョンに対して、gccとかのビルドツールが新しすぎるのかもしれないが、確証はない。</p>
            <p>新しいバージョンのソースならいけるかと思い、カスタマイズ分の差分を適用しようとしたら面倒なことになった。</p>
            <p>元のソースが古いせいか、構成が新しくなったせいでそのままでは使えない処理とか、そういうのが多くて手直しが必要になる。</p>
            <p>とりあえず、ビルドが通るようにしたいところだ。</p>
            <p>＊</p>
            <p>raspberrypiと同じく、ディスクレス環境にしたいがメモリ128MBだし。</p>
            <p>さすがにきびしい気がする。</p>
        </div>
        <hr />
        <div>
            <h2>2017/02/14 02:25</h2>
            <p>確認が取れたので0.2.0として確定。</p>
            <p>＊</p>
            <p>1ポート構成の0.3.0を作る前に、raspberrypiの方を先にやることにした。</p>
            <p>といっても、今日で完成した感じはある。</p>
            <p>他に何かなければ、adhocrepeaterの方に戻って0.3.0を、と行きたいところだけど。</p>
            <p>明日用事で出かけるし、今週中は厳しそう。</p>
            <p>構成自体、結構変える必要があるだろうし。</p>
        </div>
        <hr />
        <div>
            <h2>2017/02/11 03:40</h2>
            <p>別のポートを使用する構成が完成。</p>
            <p>＊</p>
            <p>したと思うんだけど、実際に使ってみないことにはなんとも言えないなぁ。</p>
            <p>多分大丈夫だと思うんだけど、1人ではなかなかテストしづらい。</p>
            <p>明日動作確認して、問題なければ0.2.0として確定。</p>
            <p>＊</p>
            <p>問題ないようなら、1ポート構成に修正する。</p>
            <p>それを来週中に完成させたら、とりあえず一段落にしたい。</p>
            <p>あまりadhocrepeaterばかりやっていても仕方ないし。</p>
            <p>＊</p>
            <p>adhocrepeaterの次は、raspberrypiと玄箱T4かな。</p>
            <p>しかし面倒だからなぁ。</p>
            <p>玄箱T4については、ぱぱっとできそうならやる、ぐらいだな。</p>
        </div>
        <hr />
        <div>
            <h2>2017/02/10 04:00</h2>
            <p>方針変更。</p>
            <p>＊</p>
            <p>試したこともないことを、急にやろうとするのは無茶だ。</p>
            <p>できないことはないだろうけど、奇妙な、後々手を付けにくい構成になってしまうだろう。</p>
            <p>なので、まずは簡単な作りのものを作ることにした。</p>
            <p>SSID転送用に、別のポートを使用する。</p>
            <p>これであれば、多少分かりやすい構成で作ることができる。</p>
            <p>もちろん、これは暫定的な構成の予定だ。</p>
            <p>うまくいったのを確認してから、効率のいい、よりよい構成に変更する。</p>
            <p>＊</p>
            <p>というわけで、その構成でSSID送信処理は作った。</p>
            <p>SSID受信処理ももう少しでできる。</p>
            <p>明日中にはSSID受信処理を完成させて、それを組み込む予定。</p>
        </div>
        <hr />
        <div>
            <h2>2017/02/08 19:40</h2>
            <p>SSID強制変更対応完了。</p>
            <p>＊</p>
            <p>やはり、比較的簡単に対応できた。</p>
            <p>ちょっと面倒に考えていたせいで多少手間取ったが、最終的にはシンプルにできたと思う。</p>
            <p>＊</p>
            <p>問題はSSID転送の対応だ。</p>
            <p>こちらはちょっと修正して完了、とはいかないだろう。</p>
            <p>デバイスのデータ中継に混ぜて転送する予定なので、その選別とか必要になる。</p>
            <p>それをどのように表現するかが問題だ。</p>
            <p>＊</p>
            <p>どんな変更を加えたところで、設定ファイルの項目追加はなさそうな気がする。</p>
            <p>名前変更くらいはあるかもしれないけど。</p>
            <p>ならば今日中に、今日までの変更で追加するべき項目の対応は済ませておくべきか。</p>
            <p>そうすれば、木金はSSID転送に集中できる。</p>
            <p>＊</p>
            <p>送信についてはどうとでもなるだろう。</p>
            <p>問題は受信だろうな。</p>
        </div>
        <hr />
        <div>
            <h2>2017/02/08 04:15</h2>
            <p>SSIDの履歴機能追加完了。</p>
            <p>＊</p>
            <p>pspautoconnector2に実装していた機能では無駄、というより不自然な処理があったので、それを省いた上で実装した。</p>
            <p>adhocrepeaterでは別の箇所で同様の処理をしているため、必要ないのだ。</p>
            <p>＊</p>
            <p>明日から、できれば明日中に、SSID強制変更の対応をする。</p>
            <p>方法については大体まとまっている。</p>
            <p>pspautoconnector2よりも機能を分割しているため、対応しやすそうな気がする。</p>
            <p>実際にやってみなければ、なんとも言えないが。</p>
            <p>＊</p>
            <p>しかし、自動テストはどうしよう。</p>
            <p>SsidChangerに強制変更用の関数を追加する、というのも違うし。</p>
            <p>SsidChangerのSSID変更関数の仕様変更で対応する形になりそうだな。</p>
            <p>その関数用のテストを作るか。</p>
        </div>
        <hr />
        <div>
            <h2>2017/02/07 04:15</h2>
            <p>v0.1.0として確定。</p>
            <p>＊</p>
            <p>今週中には、SSID変動に対応させたい。</p>
            <p>相手にSSIDを送信して、相手も同じSSIDに設定するところまで。</p>
            <p>とりあえず、SSIDの履歴機能を追加する。</p>
            <p>今のままでは、周囲に複数のネットワークが存在する場合に、順々にチェックしていくようなことができない。</p>
            <p>pspautoconnector2に実装済みの機能だし、明日中には完成させて次に行く予定。</p>
            <p>＊</p>
            <p>次というのは、SSIDの強制変更だ。</p>
            <p>特定のSSIDを検出したら、そのSSIDに強制的に変更する。</p>
            <p>＊</p>
            <p>その次はSSIDの転送機能だろうな。</p>
            <p>検出したSSIDの他者への送信と、他者から受信したSSIDの処理。</p>
            <p>そこまでできれば、SSID変動に完全に対応できるはず。</p>
            <p>ここまで、できれば今週中に。</p>
        </div>
        <hr />
        <div>
            <h2>2017/02/04 04:00</h2>
            <p>設定ファイルの読み込み完了。</p>
            <p>＊</p>
            <p>明日試しに動かしてみて、特に問題ないようならバージョン0.1.0のプロトタイプ完成。</p>
            <p>全体的な動作確認以外の確認事項としては、データ中継の効率に変化があるかどうか。</p>
            <p>データ中継処理を、前に作ったものから変えているためだ。</p>
            <p>効率が良くなっているといいのだが。</p>
        </div>
        <hr />
        <div>
            <h2>2017/02/03 04:10</h2>
            <p>残るは、データ送信機と受信機の設定。</p>
            <p>＊</p>
            <p>それ以外は一通り対応した。</p>
            <p>明日中には、今作ってある部分については設定ファイルをいじることで色々できるようになり、一応動かせる状態になるはず。</p>
            <p>あくまでプロトタイプであり、機能はまだまだ足りないが。</p>
            <p>＊</p>
            <p>かなり行き当たりばったりで作ってたpspautoconnector2と違って、比較的ソースが見やすい気がする。</p>
            <p>pspautoconnector2には引数10個以上の関数とかあってわけわからなかったし。</p>
            <p>その原因は設定ファイルのデータを1つ1つ引数で渡していた、というのもある。</p>
            <p>今回はその辺、設定の型ごと一気に渡す形に変えたので、引数が多くなりすぎず見やすい感じ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/02/02 04:00</h2>
            <p>設定ファイルの対応開始。</p>
            <p>＊</p>
            <p>テスト用データのビルドルールとか、その辺の動作がおかしかったり、記述が気に入らないので直したりしていたら多少手間はかかったが、とりあえず軌道に乗った。</p>
            <p>後は、設定データを追加し、それを読み込む処理の追加、読み込んだデータの使用。</p>
            <p>それを追加していけば完成する。</p>
        </div>
        <hr />
        <div>
            <h2>2017/02/01 04:00</h2>
            <p>というわけで、他者から受信したデータをPSPに送信する処理完成。</p>
            <p>＊</p>
            <p>明日から設定ファイルの読み込みと、読み込んだデータの使用。</p>
            <p>できれば全て作ってしまいたいけど、それなりに量あるしできるか分からない。</p>
            <p>設定ファイルの解析処理自体はpspautoconnector2のものを使うから、そこで詰まったりはしないが。</p>
        </div>
        <hr />
        <div>
            <h2>2017/01/31 00:30</h2>
            <p>ネットワークへの接続の確立処理ができたようだ。</p>
            <p>＊</p>
            <p>対象のSSIDが見つかるまでスキャンを繰り返すことで対応。</p>
            <p>変更するSSIDの選択処理については、とりあえずはなくてもどうにかなるし、後々追加する。</p>
            <p>PSPから受信したデータの送信処理はできたので、明日からは他者から受信したデータをPSPに送信する処理を作る。</p>
            <p>明日から、というか明日中に作ってしまいたい。</p>
        </div>
        <hr />
        <div>
            <h2>2017/01/28 04:30</h2>
            <p>蓄積されているデータからのSSID変更処理は一応完成。</p>
            <p>＊</p>
            <p>変更するSSIDの選択処理は作っていないため、そこは追加する必要があるけど。</p>
            <p>＊</p>
            <p>既存のネットワークに接続するにはSSIDの検索を行なえば、と昨日書いたが、やはりというかそこまで単純なものではないようだ。</p>
            <p>SSID設定後、あまりに速くSSIDの検索をかけてもうまく行かなかった。</p>
            <p>だから、何回か繰り返して検索処理をかける必要があるだろう。</p>
            <p>具体的には、設定したSSIDが見つかるまで。</p>
        </div>
        <hr />
        <div>
            <h2>2017/01/27 04:15</h2>
            <p>やはりアドホック接続についてはきちんと理解できていなかったようだ。</p>
            <p>＊</p>
            <p>アクセスポイントをanyに設定すれば既存のネットワークに接続するようになる、と思ったのだがそんなことはなかった。</p>
            <p>SSIDの検索を行なうべきだろうな。</p>
            <p>複数回行なう必要はない。</p>
            <p>1回行なえば、見つかり次第アクセスポイントのアドレスに変更されるようだ。</p>
            <p>iwlistならうまくいったが、iwlibを利用したプログラムでも同じ動くになるかどうかは分からない。</p>
            <p>明日試しに処理を追加してみよう。</p>
            <p>＊</p>
            <p>SSID変更要求の呼び出しは追加したが、蓄積されているデータからSSIDを変更する処理はまだ。</p>
            <p>この部分も明日作ってしまえればいいのだが。</p>
            <p>そうすれば、PSPから受信したデータの送信処理は完了になる。</p>
        </div>
        <hr />
        <div>
            <h2>2017/01/26 04:20</h2>
            <p>受信したデータが処理対象かどうかのチェック、完了。</p>
            <p>＊</p>
            <p>データを受信できなかった場合のSSID変更要求、関数作成完了。</p>
            <p>あとはそれの呼び出し処理追加と、すでに蓄積されているデータからSSIDを変更する処理の追加。</p>
            <p>これでPSPから受信したデータの送信処理は完了。</p>
            <p>次は、他者から受信したデータをPSPへ送信する処理。</p>
            <p>こっちは多少単純にできるはずだ。</p>
            <p>それが出来上がったら、設定ファイルの読み込みに取り掛かる。</p>
            <p>これをやらないと、とりあえずプロトタイプで使ってみる、ということができない。</p>
            <p>データの中継が完了すれば、とりあえず使える状態にはなるわけだし。</p>
        </div>
        <hr />
        <div>
            <h2>2017/01/25 04:00</h2>
            <p>やる気はびみょうだが、大枠はできたっぽい。</p>
            <p>＊</p>
            <p>残りは、受信したデータが処理対象かどうかのチェックと、データを受信できなかった場合のSSID変更要求。</p>
            <p>後者に関しては、とりあえず関数を追加する必要があるなぁ。</p>
            <p>前者はどうやって処理しよう。</p>
            <p>MACアドレスのチェックなんだけど、まぁmemcmp()しておけばいいか？</p>
        </div>
        <hr />
        <div>
            <h2>2017/01/24 04:00</h2>
            <p>型は全て作った。</p>
            <p>＊</p>
            <p>後は組み合わせて機能にするだけ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/01/21 03:00</h2>
            <p>UDPによる送受信と、生パケットの送受信ができるソケットをそれぞれ作った。</p>
            <p>＊</p>
            <p>あとは、パケットの配列の定義とパケットの配列を管理する型の作成。</p>
            <p>それができれば、PSPから受信したデータの送信処理が作れる。</p>
        </div>
        <hr />
        <div>
            <h2>2017/01/20 03:55</h2>
            <p>思うようにやる気が出なくてよくない。</p>
            <p>＊</p>
            <p>UDPによるデータ送出処理がまだ途中。</p>
            <p>パケットを管理する型は作った。</p>
            <p>ソケット通信をする型は明日中に全て作ってしまいたい。</p>
        </div>
        <hr />
        <div>
            <h2>2017/01/19 03:25</h2>
            <p>盛大に勘違いしていたようだ。</p>
            <p>＊</p>
            <p>SSID設定処理でSSIDの検出なんかいらない。</p>
            <p>アクセスポイントをanyに設定すれば、既存のネットワークに接続するようになるらしい。</p>
            <p>無理解から勝手なことやろうとしてた。</p>
            <p>簡単に言えば、昨日やったSSID検出処理の共通化は完全に無駄になった。</p>
            <p>モチベーションの低下がやばい。</p>
            <p>＊</p>
            <p>アクセスポイントをanyに、という情報も、実際に試して確認しただけなので、それが正しい仕様なのかどうかは分からない。</p>
            <p>anyじゃなくても、とりあえずアクセスポイントを何かしら設定すれば接続できたし。</p>
            <p>アドホック接続に関する詳しい仕様がどっかにまとまって書かれていればいいのだけど。</p>
            <p>その辺はRFCとかIEEEとかなんとかなんだろうか。</p>
            <p>＊</p>
            <p>そんなわけで、モチベーション下がりつつもPSPからデータを受信し、それを他者に送信する処理を作り始めている。</p>
            <p>必要な追加機能は、PSPからデータを受信するための生パケット取得用ソケットと、他者に送信するためのUDPソケット。</p>
            <p>あとは、一時的にパケットを溜め込むバッファもあった方がいいだろう。</p>
            <p>PSPからデータを受信する処理と、そのデータを他者に送信する処理はそれぞれ別のスレッドにする。</p>
            <p>バッファはその橋渡しだ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/01/18 03:15</h2>
            <p>想定以上にめんどくさい。</p>
            <p>＊</p>
            <p>SSID設定処理でもSSIDの検出を行なうため、SSID検出処理を共通化した。</p>
            <p>SSID検出スレッドの処理を、共通化したSSID検出処理で行なうようにするところまで完了。</p>
            <p>これで明日にはSSID設定処理にSSID検出を追加できる。</p>
            <p>＊</p>
            <p>多少やる気が落ちてきてるのも、やはり効率に影響している。</p>
            <p>次にやることまでちゃんと考えておかないと、モチベーションの維持ができんな。</p>
            <p>この次はいよいよ中継処理に入る。</p>
            <p>PSPから受信したデータを他者に送信する。</p>
            <p>pspautoconnector2にはなかった処理だ。</p>
            <p>PSPからデータが受信できなかったら、SSID設定処理に対してSSID変更しろ、と要求を投げる感じ。</p>
            <p>SSID設定処理には、まだそれに対応するための処理を作っていないので、合わせて機能追加をしていく。</p>
            <p>＊</p>
            <p>その次は他者から受信したデータをPSPに送信する処理か？</p>
            <p>で、検出したSSIDについて他者に送信する処理と、他者から受信したSSIDの処理。</p>
            <p>それでメインの処理は多分全部。</p>
            <p>後は設定ファイルの読み込みと、その適用。</p>
            <p>そんなところだろう。</p>
        </div>
        <hr />
        <div>
            <h2>2017/01/17 04:00</h2>
            <p>SSID設定処理作成中。</p>
            <p>＊</p>
            <p>とりあえず設定するだけならできたが、これ多分接続前にネットワークを検出している必要があるな。</p>
            <p>pspautoconnector2がうまく動いていない時があったのも、そのせいかもしれない。</p>
            <p>明日中には設定処理を作り終えたい。</p>
        </div>
        <hr />
        <div>
            <h2>2017/01/14 02:20</h2>
            <p>SSID検出に反応してSSIDを設定する処理を作っている。</p>
            <p>＊</p>
            <p>SSID検出に反応して、というイベント処理がもうちょいで出来上がる。</p>
            <p>イベント処理については、大体sucroseと同じような感じで処理している。</p>
            <p>来週の頭には、SSID設定処理まで仕上げたいなぁ。</p>
        </div>
        <hr />
        <div>
            <h2>2017/01/13 01:40</h2>
            <p>周囲のSSIDを検出する処理を作った。</p>
            <p>＊</p>
            <p>pspautoconnector2ではチャンネルを考慮していなかったが、今回は一致するもの以外扱わないことにした。</p>
            <p>この方が、混線を防げていいだろう。</p>
            <p>＊</p>
            <p>次に作るべきは、SSIDの設定処理だな。</p>
            <p>しかし、目的のSSIDかどうか確認するにはデータを受信してみないと分からないしどうしよう。</p>
            <p>などと考えたが、今回はデータの転送もするんだし、その辺はそっちに任せるか。</p>
            <p>＊</p>
            <p>SSIDの設定については、大きく分けて2種類のルートで行なおうと思う。</p>
            <p>1つは、SSIDの検出に反応して行なう設定。</p>
            <p>もう1つは、ネットワークの切断に反応して行なう設定。</p>
            <p>まず前者から作り始める。</p>
            <p>後者はデータの読み取りができるようになってから。</p>
        </div>
        <hr />
        <div>
            <h2>2017/01/12 01:20</h2>
            <p>SSIDをまとめる型を作った。</p>
            <p>＊</p>
            <p>まだ完全ではないが。</p>
            <p>例えば、イベントハンドラを登録できるようにして、新しいSSIDがつっこまれた時に呼び出すようにしたい。</p>
            <p>が、それを作るのはもうちょい先でいい。</p>
            <p>明日には、周囲のSSIDを見つけ次第つっこんでいく処理を作る。</p>
        </div>
        <hr />
        <div>
            <h2>2017/01/10 23:30</h2>
            <p>pspautoconnector2の改良版、adhocrepeaterの開発に取り掛かっている。</p>
            <p>＊</p>
            <p>pspautoconnector2のソースを見てたら、テストコード全く書いてないしひどかった。</p>
            <p>adhocrepeaterはテストファーストでがんがんテスト作っていくことにする。</p>
        </div>
        <hr />
        <div>
            <h2>2017/01/07 00:35</h2>
            <p>パッケージ内のファイルを読み込めることを確認。</p>
            <p>＊</p>
            <p>具体的にどのディレクトリである、という情報に触れることがなく、いい感じ。</p>
            <p>最初はsucroseに作ってたけど、candymaker内に移動した。</p>
            <p>candymakerでパッケージパスを生成する必要があるためだ。</p>
            <p>＊</p>
            <p>candymakerに実装されているインターフェースについても、なんらかの処理が必要になりそうだな。</p>
            <p>現状何もしてないから、ロードするとcandymakerと競合してしまうモジュールもロード可能な状態になっていてよくない。</p>
            <p>あと、パッケージ情報ファイルなどを読み込むために書いたファイル読み込み処理はそのままになっている。</p>
            <p>今回追加したfgの仕様のファイル読み込み処理に置き換えて、古い処理は削除したいところだ。</p>
            <p>とはいえ、処理が被っていて気分悪い程度であり、なんらかの問題を起こしているわけでもない。</p>
            <p>他の作業を終えて、candymakerの作成に戻ってきた時に、最初にやるとしよう。</p>
        </div>
        <hr />
        <div>
            <h2>2017/01/05 17:52</h2>
            <p>年が明けてしまった。</p>
            <p>＊</p>
            <p>ファイル読み込み関係の処理作った。</p>
            <p>これを使ってパッケージ内のファイルにアクセスする。</p>
            <p>そこまでやったら一区切り付くし、別の作業をやりたい。</p>
            <p>pspautoconnector2の改修とか、放置してある玄箱T4を使えるようにしたりとか。</p>
            <p>今週中には終わらせて…って、あと1日しかないではないか。</p>
        </div>
        <hr />
        <div>
            <p><a href="/">戻る</a></p>
        </div>
    </body>
</html>
